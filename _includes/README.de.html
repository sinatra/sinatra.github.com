<div class='toc'>
	<ol class='level-1'>
		<li><a href='#Routen'>Routen</a></li>
		<ol class='level-2'>
			<li><a href='#Bedingungen'>Bedingungen</a></li>
			<li><a href='#R&uuml;ckgabewerte'>R&uuml;ckgabewerte</a></li>
			<li><a href='#Eigene%20Routen-Muster'>Eigene Routen-Muster</a></li>
		</ol>
		<li><a href='#Statische%20Dateien'>Statische Dateien</a></li>
		<li><a href='#Views/Templates'>Views/Templates</a></li>
		<ol class='level-3'>
				<li><a href='#Direkte%20Templates'>Direkte Templates</a></li>
			</ol>
			<li><a href='#Verf&uuml;gbare%20Templatesprachen'>Verf&uuml;gbare Templatesprachen</a></li>
			<li><a href='#Haml%20Templates'>Haml Templates</a></li>
			<li><a href='#Erb%20Templates'>Erb Templates</a></li>
			<li><a href='#Builder%20Templates'>Builder Templates</a></li>
			<li><a href='#Nokogiri%20Templates'>Nokogiri Templates</a></li>
			<li><a href='#Sass%20Templates'>Sass Templates</a></li>
			<li><a href='#SCSS%20Templates'>SCSS Templates</a></li>
			<li><a href='#Less%20Templates'>Less Templates</a></li>
			<li><a href='#Liquid%20Templates'>Liquid Templates</a></li>
			<li><a href='#Markdown%20Templates'>Markdown Templates</a></li>
			<li><a href='#Textile%20Templates'>Textile Templates</a></li>
			<li><a href='#RDoc%20Templates'>RDoc Templates</a></li>
			<li><a href='#Radius%20Templates'>Radius Templates</a></li>
			<li><a href='#Markaby%20Templates'>Markaby Templates</a></li>
			<li><a href='#RABL%20Templates'>RABL Templates</a></li>
			<li><a href='#Slim%20Templates'>Slim Templates</a></li>
			<li><a href='#Creole%20Templates'>Creole Templates</a></li>
			<li><a href='#CoffeeScript%20Templates'>CoffeeScript Templates</a></li>
			<ol class='level-3'>
				<li><a href='#Stylus%20Templates'>Stylus Templates</a></li>
				<li><a href='#Yajl%20Templates'>Yajl Templates</a></li>
			</ol>
			<li><a href='#WLang%20Templates'>WLang Templates</a></li>
			<li><a href='#Auf%20Variablen%20in%20Templates%20zugreifen'>Auf Variablen in Templates zugreifen</a></li>
			<li><a href='#Templates%20mit%20%3Ccode%3Eyield%3C/code%3E%20und%20verschachtelte%20Layouts'>Templates mit <code>yield</code> und verschachtelte Layouts</a></li>
			<li><a href='#Inline-Templates'>Inline-Templates</a></li>
			<li><a href='#Benannte%20Templates'>Benannte Templates</a></li>
			<li><a href='#Dateiendungen%20zuordnen'>Dateiendungen zuordnen</a></li>
			<li><a href='#Eine%20eigene%20Template-Engine%20hinzuf&uuml;gen'>Eine eigene Template-Engine hinzuf&uuml;gen</a></li>
		</ol>
		<li><a href='#Filter'>Filter</a></li>
		<li><a href='#Helfer'>Helfer</a></li>
		<ol class='level-2'>
			<li><a href='#Sessions%20verwenden'>Sessions verwenden</a></li>
		</ol>
		<li><a href='#Anhalten'>Anhalten</a></li>
		<li><a href='#Weiterspringen'>Weiterspringen</a></li>
		<ol class='level-2'>
			<li><a href='#Eine%20andere%20Route%20ansteuern'>Eine andere Route ansteuern</a></li>
			<li><a href='#Body,%20Status-Code%20und%20Header%20setzen'>Body, Status-Code und Header setzen</a></li>
			<li><a href='#Response-Streams'>Response-Streams</a></li>
			<li><a href='#Logger'>Logger</a></li>
		</ol>
		<li><a href='#Mime-Types'>Mime-Types</a></li>
		<ol class='level-2'>
			<li><a href='#URLs%20generieren'>URLs generieren</a></li>
			<li><a href='#Browser-Umleitung'>Browser-Umleitung</a></li>
			<li><a href='#Cache%20einsetzen'>Cache einsetzen</a></li>
			<li><a href='#Dateien%20versenden'>Dateien versenden</a></li>
		</ol>
		<li><a href='#Das%20Request-Objekt'>Das Request-Objekt</a></li>
		<ol class='level-2'>
			<li><a href='#Anh&auml;nge'>Anh&auml;nge</a></li>
			<li><a href='#Umgang%20mit%20Datum%20und%20Zeit'>Umgang mit Datum und Zeit</a></li>
			<li><a href='#Nachschlagen%20von%20Template-Dateien'>Nachschlagen von Template-Dateien</a></li>
		</ol>
		<li><a href='#Konfiguration'>Konfiguration</a></li>
		<ol class='level-2'>
			<li><a href='#Einstellung%20des%20Angriffsschutzes'>Einstellung des Angriffsschutzes</a></li>
		</ol>
		<li><a href='#M&ouml;gliche%20Einstellungen'>M&ouml;gliche Einstellungen</a></li>
		<li><a href='#Umgebungen'>Umgebungen</a></li>
		<li><a href='#Fehlerbehandlung'>Fehlerbehandlung</a></li>
		<ol class='level-2'>
			<li><a href='#Nicht%20gefunden'>Nicht gefunden</a></li>
			<li><a href='#Fehler'>Fehler</a></li>
		</ol>
		<li><a href='#Rack-Middleware'>Rack-Middleware</a></li>
		<li><a href='#Testen'>Testen</a></li>
		<ol class='level-2'>
			<li><a href='#Modularer%20vs.%20klassischer%20Stil'>Modularer vs. klassischer Stil</a></li>
			<li><a href='#Eine%20modulare%20Applikation%20bereitstellen'>Eine modulare Applikation bereitstellen</a></li>
			<li><a href='#Eine%20klassische%20Anwendung%20mit%20einer%20config.ru%20verwenden'>Eine klassische Anwendung mit einer config.ru verwenden</a></li>
			<li><a href='#Wann%20sollte%20eine%20config.ru-Datei%20verwendet%20werden?'>Wann sollte eine config.ru-Datei verwendet werden?</a></li>
			<li><a href='#Sinatra%20als%20Middleware%20nutzen'>Sinatra als Middleware nutzen</a></li>
			<li><a href='#Dynamische%20Applikationserstellung'>Dynamische Applikationserstellung</a></li>
		</ol>
		<li><a href='#Geltungsbereich%20und%20Bindung'>Geltungsbereich und Bindung</a></li>
		<ol class='level-2'>
			<li><a href='#Anwendungs-%20oder%20Klassen-Scope'>Anwendungs- oder Klassen-Scope</a></li>
			<li><a href='#Anfrage-%20oder%20Instanz-Scope'>Anfrage- oder Instanz-Scope</a></li>
			<li><a href='#Delegation-Scope'>Delegation-Scope</a></li>
		</ol>
		<li><a href='#Kommandozeile'>Kommandozeile</a></li>
		<li><a href='#Systemanforderungen'>Systemanforderungen</a></li>
		<li><a href='#Der%20neuste%20Stand%20(The%20Bleeding%20Edge)'>Der neuste Stand (The Bleeding Edge)</a></li>
		<ol class='level-2'>
			<li><a href='#Mit%20Bundler'>Mit Bundler</a></li>
			<li><a href='#Eigenes%20Repository'>Eigenes Repository</a></li>
			<li><a href='#Gem%20erstellen'>Gem erstellen</a></li>
		</ol>
		<li><a href='#Versions-Verfahren'>Versions-Verfahren</a></li>
		<li><a href='#Mehr'>Mehr</a></li>
	</ol>
</div>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>

<p><em>Wichtig: Dieses Dokument ist eine &Uuml;bersetzung aus dem Englischen und unter
Umst&auml;nden nicht auf dem aktuellen Stand.</em></p>

<p>Sinatra ist eine
<a href="http://de.wikipedia.org/wiki/Dom%C3%A4nenspezifische_Sprache">DSL</a>, die das
schnelle Erstellen von Webanwendungen in Ruby mit minimalem Aufwand
erm&ouml;glicht:</p>

<pre><code class="ruby"># myapp.rb
require 'sinatra'
get '/' do
  'Hallo Welt!'
end
</code></pre>

<p>Einfach via <code>rubygems</code> installieren und starten:</p>

<pre><code class="ruby">gem install sinatra
ruby myapp.rb
</code></pre>

<p>Die Seite kann nun unter http://localhost:4567 betrachtet werden.</p>

<p>Es wird empfohlen, den Thin-Server via <code>gem install thin</code> zu installieren, den
Sinatra dann, soweit vorhanden, automatisch verwendet.</p>

<a name='Routen'></a>
<h2>Routen</h2>

<p>In Sinatra wird eine Route durch eine HTTP-Methode und ein URL-Muster definiert.
Jeder dieser Routen wird ein Ruby-Block zugeordnet:</p>

<pre><code class="ruby">get '/' do
  .. zeige etwas ..
end

post '/' do
  .. erstelle etwas ..
end

put '/' do
  .. update etwas ..
end

delete '/' do
  .. entferne etwas ..
end

options '/' do
  .. zeige, was wir k&ouml;nnen ..
end

link '/' do
  .. verbinde etwas ..
end

unlink '/' do
  .. trenne etwas ..
end

</code></pre>

<p>Die Routen werden in der Reihenfolge durchlaufen, in der sie definiert wurden.
Das erste Routen-Muster, das mit dem Request &uuml;bereinstimmt, wird ausgef&uuml;hrt.</p>

<p>Die Muster der Routen k&ouml;nnen benannte Parameter beinhalten, die &uuml;ber den
<code>params</code>-Hash zug&auml;nglich gemacht werden:</p>

<pre><code class="ruby">get '/hallo/:name' do
  # passt auf "GET /hallo/foo" und "GET /hallo/bar"
  # params[:name] ist 'foo' oder 'bar'
  "Hallo #{params[:name]}!"
end
</code></pre>

<p>Man kann auf diese auch mit Block-Parametern zugreifen:</p>

<pre><code class="ruby">get '/hallo/:name' do |n|
  "Hallo #{n}!"
end
</code></pre>

<p>Routen-Muster k&ouml;nnen auch mit Splat- oder Wildcard-Parametern &uuml;ber das
<code>params[:splat]</code>-Array angesprochen werden:</p>

<pre><code class="ruby">get '/sag/*/zu/*' do
  # passt auf /sag/hallo/zu/welt
  params[:splat] # =&gt; ["hallo", "welt"]
end

get '/download/*.*' do
  # passt auf /download/pfad/zu/datei.xml
  params[:splat] # =&gt; ["pfad/zu/datei", "xml"]
end
</code></pre>

<p>Oder mit Block-Parametern:</p>

<pre><code class="ruby">get '/download/*.*' do |pfad, endung|
  [pfad, endung] # =&gt; ["Pfad/zu/Datei", "xml"]
end
</code></pre>

<p>Routen mit regul&auml;ren Ausdr&uuml;cken sind auch m&ouml;glich:</p>

<pre><code class="ruby">get %r{/hallo/([\w]+)} do
  "Hallo, #{params[:captures].first}!"
end
</code></pre>

<p>Und auch hier k&ouml;nnen Block-Parameter genutzt werden:</p>

<pre><code class="ruby">get %r{/hallo/([\w]+)} do |c|
  "Hallo, #{c}!"
end
</code></pre>

<p>Routen-Muster k&ouml;nnen auch mit optionalen Parametern ausgestattet werden:</p>

<pre><code class="ruby">get '/posts.?:format?' do
  # passt auf "GET /posts" sowie jegliche Erweiterung
  # wie "GET /posts.json", "GET /posts.xml" etc.
end
</code></pre>

<p>Anmerkung: Solange man den sog. Path Traversal Attack-Schutz nicht deaktiviert
(siehe weiter unten), kann es sein, dass der Request-Pfad noch vor dem
Abgleich mit den Routen modifiziert wird.</p>

<a name='Bedingungen'></a>
<h3>Bedingungen</h3>

<p>An Routen k&ouml;nnen eine Vielzahl von Bedingungen angeh&auml;ngt werden, die erf&uuml;llt
sein m&uuml;ssen, damit der Block ausgef&uuml;hrt wird. M&ouml;glich w&auml;re etwa eine
Einschr&auml;nkung des User-Agents:</p>

<pre><code class="ruby">get '/foo', :agent =&gt; /Songbird (\d\.\d)[\d\/]*?/ do
  "Du verwendest Songbird Version #{params[:agent][0]}"
end

get '/foo' do
  # passt auf andere Browser
end
</code></pre>

<p>Andere mitgelieferte Bedingungen sind <code>host_name</code> und <code>provides</code>:</p>

<pre><code class="ruby">get '/', :host_name =&gt; /^admin\./ do
  "Adminbereich, Zugriff verweigert!"
end

get '/', :provides =&gt; 'html' do
  haml :index
end

get '/', :provides =&gt; ['rss', 'atom', 'xml'] do
  builder :feed
end
</code></pre>

<p>Es k&ouml;nnen auch andere Bedingungen relativ einfach hinzugef&uuml;gt werden:</p>

<pre><code class="ruby">set(:probability) { |value| condition { rand &lt;= value } }

get '/auto_gewinnen', :probability =&gt; 0.1 do
  "Du hast gewonnen!"
end

get '/auto_gewinnen' do
  "Tut mir leid, verloren."
end
</code></pre>

<p>Bei Bedingungen, die mehrere Werte annehmen k&ouml;nnen, sollte ein Splat verwendet
werden:</p>

<pre><code class="ruby">set(:auth) do |*roles|   # &lt;- hier kommt der Splat ins Spiel
  condition do
    unless logged_in? &amp;&amp; roles.any? {|role| current_user.in_role? role }
      redirect "/login/", 303
    end
  end
end

get "/mein/account/", :auth =&gt; [:user, :admin] do
  "Mein Account"
end

get "/nur/admin/", :auth =&gt; :admin do
  "Nur Admins d&uuml;rfen hier rein!"
end
</code></pre>

<a name='R&uuml;ckgabewerte'></a>
<h3>R&uuml;ckgabewerte</h3>

<p>Durch den R&uuml;ckgabewert eines Routen-Blocks wird mindestens der Response-Body
festgelegt, der an den HTTP-Client, bzw. die n&auml;chste Rack-Middleware,
weitergegeben wird. Im Normalfall handelt es sich hierbei, wie in den
vorangehenden Beispielen zu sehen war, um einen String. Es werden allerdings
auch andere Werte akzeptiert.</p>

<p>Es kann jedes g&uuml;ltige Objekt zur&uuml;ckgegeben werden, bei dem es sich entweder um
einen Rack-R&uuml;ckgabewert, einen Rack-Body oder einen HTTP-Status-Code handelt:</p>

<p>Damit l&auml;sst sich relativ einfach Streaming implementieren:</p>

<pre><code class="ruby">class Stream
  def each
    100.times { |i| yield "#{i}\n" }
  end
end

get('/') { Stream.new }
</code></pre>

<p>Ebenso kann die <code>stream</code>-Helfer-Methode (s.u.) verwendet werden, die Streaming
direkt in die Route integriert.</p>

<a name='Eigene%20Routen-Muster'></a>
<h3>Eigene Routen-Muster</h3>

<p>Wie oben schon beschrieben, ist Sinatra von Haus aus mit Unterst&uuml;tzung f&uuml;r
String-Muster und Regul&auml;re Ausdr&uuml;cke zum Abgleichen von Routen ausgestattet.
Das muss aber noch nicht alles sein, es k&ouml;nnen ohne gro&szlig;en Aufwand eigene
Routen-Muster erstellt werden:</p>

<pre><code class="ruby">class AllButPattern
  Match = Struct.new(:captures)

  def initialize(except)
    @except   = except
    @captures = Match.new([])
  end

  def match(str)
    @captures unless @except === str
  end
end

def all_but(pattern)
  AllButPattern.new(pattern)
end

get all_but("/index") do
  # ...
end
</code></pre>

<p>Beachte, dass das obige Beispiel etwas &uuml;bertrieben wirkt. Es geht auch einfacher:</p>

<pre><code class="ruby">get // do
  pass if request.path_info == "/index"
  # ...
end
</code></pre>

<p>Oder unter Verwendung eines negativen look ahead:</p>

<pre><code class="ruby">get %r{^(?!/index$)} do
  # ...
end
</code></pre>

<a name='Statische%20Dateien'></a>
<h2>Statische Dateien</h2>

<p>Statische Dateien werden aus dem <code>./public</code>-Ordner ausgeliefert. Es ist m&ouml;glich,
einen anderen Ort zu definieren, indem man die <code>:public_folder</code>-Option setzt:</p>

<pre><code class="ruby">set :public_folder, File.dirname(__FILE__) + '/static'
</code></pre>

<p>Zu beachten ist, dass der Ordnername public nicht Teil der URL ist. Die Datei
<code>./public/css/style.css</code> ist unter <code>http://example.com/css/style.css</code> zu finden.</p>

<p>Um den <code>Cache-Control</code>-Header mit Informationen zu versorgen, verwendet man
die <code>:static_cache_control</code>-Einstellung (s.u.).</p>

<a name='Views/Templates'></a>
<h2>Views/Templates</h2>

<p>Alle Templatesprachen verwenden ihre eigene Renderingmethode, die jeweils
einen String zur&uuml;ckgibt:</p>

<pre><code class="ruby">get '/' do
  erb :index
end
</code></pre>

<p>Dieses Beispiel rendert <code>views/index.erb</code>.</p>

<p>Anstelle eines Templatenamens kann man auch direkt die Templatesprache verwenden:</p>

<pre><code class="ruby">get '/' do
  code = "&lt;%= Time.now %&gt;"
  erb code
end
</code></pre>

<p>Templates nehmen ein zweite Argument an, den Options-Hash:</p>

<pre><code class="ruby">get '/' do
  erb :index, :layout =&gt; :post
end
</code></pre>

<p>Dieses Beispiel rendert <code>views/index.erb</code> eingebettet in <code>views/post.erb</code>
(Voreinstellung ist <code>views/layout.erb</code>, sofern es vorhanden ist.)</p>

<p>Optionen, die Sinatra nicht versteht, werden an das Template weitergereicht:</p>

<pre><code class="ruby">get '/' do
  haml :index, :format =&gt; :html5
end
</code></pre>

<p>F&uuml;r alle Templates k&ouml;nnen auch generelle Einstellungen festgelegt werden:</p>

<pre><code class="ruby">set :haml, :format =&gt; :html5

get '/' do
  haml :index
end
</code></pre>

<p>Optionen, die an die Rendermethode weitergegeben werden, &uuml;berschreiben die
Einstellungen, die mit <code>set</code> festgelegt wurden.</p>

<p>Einstellungen:</p>

<dl>
<dt>locals</dt>
  <dd>Liste von lokalen Variablen, die and das Dokument weitergegeben werden.
    Praktisch f&uuml;r Partials:

    <tt>erb "", :locals =&gt; {:foo =&gt; "bar"}</tt>
</dd>
      
  <dt>default_encoding</dt>
  <dd>Gibt die Stringkodierung an, die verwendet werden soll. Voreingestellt
    auf <tt>settings.default_encoding</tt>.</dd>
      
  <dt>views</dt>
  <dd>Ordner, aus dem die Templates heraus geladen werden. Voreingestellt auf
    <tt>settings.views</tt>.</dd>
      
  <dt>layout</dt>
  <dd>Legt fest, ob ein Layouttemplate verwendet werden soll oder nicht
    (<tt>true</tt> oder<tt>false</tt>). Ist es ein Symbol, dann legt es fest,
    welches Template als Layout verwendet wird:

    <tt>erb :index, :layout =&gt; !request.xhr?</tt>
</dd>
      
  <dt>content_type</dt>
  <dd>Content-Type den das Template ausgibt. Voreinstellung h&auml;ngt von der
    Templatesprache ab.</dd>
      
  <dt>scope</dt>
  <dd>Scope, in dem das Template gerendert wird. Liegt standardm&auml;&szlig;ig innerhalb
    der App-Instanz. Wird Scope ge&auml;ndert, sind Instanzvariablen und
    Helfermethoden nicht verf&uuml;gbar.</dd>
      
  <dt>layout_engine</dt>
  <dd>Legt fest, welcher Renderer f&uuml;r das Layout verantwortlich ist. Hilfreich
    f&uuml;r Sprachen, die sonst keine Templates unterst&uuml;tzen. Voreingestellt auf
    den Renderer, der f&uuml;r das Template verwendet wird:

    <tt>set :rdoc, :layout_engine =&gt; :erb</tt>
</dd>
  <dt>layout_options</dt>
  <dd>Besondere Einstellungen, die nur f&uuml;r das Rendering verwendet werden:

    <tt>set :rdoc, :layout_options =&gt; { :views =&gt; 'views/layouts' }</tt>
</dd>
</dl>
<p>Sinatra geht davon aus, dass die Templates sich im <code>./views</code> Verzeichnis
befinden. Es kann jedoch ein anderer Ordner festgelegt werden:</p>

<pre><code class="ruby">set :views, settings.root + '/templates'
</code></pre>

<p>Es ist zu beachten, dass immer mit Symbolen auf Templates verwiesen werden muss,
auch dann, wenn sie sich in einem Unterordner befinden:</p>

<pre><code class="ruby">haml :'unterverzeichnis/template'
</code></pre>

<p>Rendering-Methoden rendern jeden String direkt.</p>

<a name='Direkte%20Templates'></a>
<h4>Direkte Templates</h4>

<pre><code class="ruby">get '/' do
  haml '%div.title Hallo Welt'
end
</code></pre>

<p>Hier wird der String direkt gerendert.</p>

<a name='Verf&uuml;gbare%20Templatesprachen'></a>
<h3>Verf&uuml;gbare Templatesprachen</h3>

<p>Einige Sprachen haben mehrere Implementierungen. Um festzulegen, welche
verwendet wird (und dann auch Thread-sicher ist), verwendet man am besten zu
Beginn ein <code>'require'</code>:</p>

<pre><code class="ruby">require 'rdiscount' # oder require 'bluecloth'
get('/') { markdown :index }
</code></pre>

<a name='Haml%20Templates'></a>
<h3>Haml Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="http://haml.info/">haml</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.haml</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>haml :index, :format =&gt; :html5</tt></td>
  </tr>
</table>
<a name='Erb%20Templates'></a>
<h3>Erb Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td>
<a href="http://www.kuwata-lab.com/erubis/">erubis</a> oder erb 
    (Standardbibliothek von Ruby)</td>
  </tr>
<tr>
<td>Dateierweiterungen</td>
    <td>
<tt>.erb</tt>, <tt>.rhtml</tt> oder <tt>.erubis</tt> (nur Erubis)</td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>
<a name='Builder%20Templates'></a>
<h3>Builder Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="http://builder.rubyforge.org/">builder</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.builder</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>builder { |xml| xml.em "Hallo" }</tt></td>
  </tr>
</table>
<p>Nimmt ebenso einen Block f&uuml;r Inline-Templates entgegen (siehe Beispiel).</p>

<a name='Nokogiri%20Templates'></a>
<h3>Nokogiri Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="http://nokogiri.org/">nokogiri</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>nokogiri { |xml| xml.em "Hallo" }</tt></td>
  </tr>
</table>
<p>Nimmt ebenso einen Block f&uuml;r Inline-Templates entgegen (siehe Beispiel).</p>

<a name='Sass%20Templates'></a>
<h3>Sass Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="http://sass-lang.com/">sass</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.sass</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>sass :stylesheet, :style =&gt; :expanded</tt></td>
  </tr>
</table>
<a name='SCSS%20Templates'></a>
<h3>SCSS Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="http://sass-lang.com/">sass</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.scss</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>scss :stylesheet, :style =&gt; :expanded</tt></td>
  </tr>
</table>
<a name='Less%20Templates'></a>
<h3>Less Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="http://www.lesscss.org/">less</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.less</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>less :stylesheet</tt></td>
  </tr>
</table>
<a name='Liquid%20Templates'></a>
<h3>Liquid Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="http://www.liquidmarkup.org/">liquid</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.liquid</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>liquid :index, :locals =&gt; { :key =&gt; 'Wert' }</tt></td>
  </tr>
</table>
<p>Da man aus dem Liquid-Template heraus keine Ruby-Methoden aufrufen kann
(ausgenommen <code>yield</code>), wird man &uuml;blicherweise locals verwenden wollen, mit
denen man Variablen weitergibt.</p>

<a name='Markdown%20Templates'></a>
<h3>Markdown Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td>Eine der folgenden Bibliotheken: 
        <a href="https://github.com/rtomayko/rdiscount" title="RDiscount">RDiscount</a>,
        <a href="https://github.com/vmg/redcarpet" title="RedCarpet">RedCarpet</a>,
        <a href="http://deveiate.org/projects/BlueCloth" title="BlueCloth">BlueCloth</a>,
        <a href="http://kramdown.rubyforge.org/" title="kramdown">kramdown</a> oder
        <a href="http://maruku.rubyforge.org/" title="maruku">maruku</a>
    </td>
  </tr>
<tr>
<td>Dateierweiterungen</td>
    <td>
<tt>.markdown</tt>, <tt>.mkd</tt> und <tt>.md</tt>
</td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>markdown :index, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>
<p>Da man aus den Markdown-Templates heraus keine Ruby-Methoden aufrufen und auch
keine locals verwenden kann, wird man Markdown &uuml;blicherweise in Kombination
mit anderen Renderern verwenden wollen:</p>

<pre><code class="ruby">erb :overview, :locals =&gt; { :text =&gt; markdown(:einfuehrung) }
</code></pre>

<p>Beachte, dass man die <code>markdown</code>-Methode auch aus anderen Templates heraus
aufrufen kann:</p>

<pre><code class="ruby">%h1 Gru&szlig; von Haml!
%p= markdown(:Gr&uuml;&szlig;e)
</code></pre>

<p>Da man Ruby nicht von Markdown heraus aufrufen kann, k&ouml;nnen auch Layouts nicht
in Markdown geschrieben werden. Es ist aber m&ouml;glich, einen Renderer f&uuml;r die
Templates zu verwenden und einen anderen f&uuml;r das Layout, indem die
<code>:layout_engine</code>-Option verwendet wird.</p>

<a name='Textile%20Templates'></a>
<h3>Textile Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="http://redcloth.org/">RedCloth</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.textile</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>textile :index, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>
<p>Da man aus dem Textile-Template heraus keine Ruby-Methoden aufrufen und auch
keine locals verwenden kann, wird man Textile &uuml;blicherweise in Kombination mit
anderen Renderern verwenden wollen:</p>

<pre><code class="ruby">erb :overview, :locals =&gt; { :text =&gt; textile(:einfuehrung) }
</code></pre>

<p>Beachte, dass man die <code>textile</code>-Methode auch aus anderen Templates heraus
aufrufen kann:</p>

<pre><code class="ruby">%h1 Gru&szlig; von Haml!
%p= textile(:Gr&uuml;&szlig;e)
</code></pre>

<p>Da man Ruby nicht von Textile heraus aufrufen kann, k&ouml;nnen auch Layouts nicht
in Textile geschrieben werden. Es ist aber m&ouml;glich, einen Renderer f&uuml;r die
Templates zu verwenden und einen anderen f&uuml;r das Layout, indem die
<code>:layout_engine</code>-Option verwendet wird.</p>

<a name='RDoc%20Templates'></a>
<h3>RDoc Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="http://rdoc.rubyforge.org/">rdoc</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.rdoc</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>textile :README, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>
<p>Da man aus dem RDoc-Template heraus keine Ruby-Methoden aufrufen und auch
keine locals verwenden kann, wird man RDoc &uuml;blicherweise in Kombination mit
anderen Renderern verwenden wollen:</p>

<pre><code class="ruby">erb :overview, :locals =&gt; { :text =&gt; rdoc(:einfuehrung) }
</code></pre>

<p>Beachte, dass man die <code>rdoc</code>-Methode auch aus anderen Templates heraus
aufrufen kann:</p>

<pre><code class="ruby">%h1 Gru&szlig; von Haml!
%p= rdoc(:Gr&uuml;&szlig;e)
</code></pre>

<p>Da man Ruby nicht von RDoc heraus aufrufen kann, k&ouml;nnen auch Layouts nicht in
RDoc geschrieben werden. Es ist aber m&ouml;glich, einen Renderer f&uuml;r die Templates
zu verwenden und einen anderen f&uuml;r das Layout, indem die
<code>:layout_engine</code>-Option verwendet wird.</p>

<a name='Radius%20Templates'></a>
<h3>Radius Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="http://radius.rubyforge.org/">radius</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.radius</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>radius :index, :locals =&gt; { :key =&gt; 'Wert' }</tt></td>
  </tr>
</table>
<p>Da man aus dem Radius-Template heraus keine Ruby-Methoden aufrufen kann, wird
man &uuml;blicherweise locals verwenden wollen, mit denen man Variablen weitergibt.</p>

<a name='Markaby%20Templates'></a>
<h3>Markaby Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="http://markaby.github.com/">markaby</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.mab</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>markaby { h1 "Willkommen!" }</tt></td>
  </tr>
</table>
<p>Nimmt ebenso einen Block f&uuml;r Inline-Templates entgegen (siehe Beispiel).</p>

<a name='RABL%20Templates'></a>
<h3>RABL Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="https://github.com/nesquena/rabl">rabl</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.rabl</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>
<a name='Slim%20Templates'></a>
<h3>Slim Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="http://slim-lang.com/">slim</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.slim</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>
<a name='Creole%20Templates'></a>
<h3>Creole Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="https://github.com/minad/creole">creole</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.creole</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>creole :wiki, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>
<p>Da man aus dem Creole-Template heraus keine Ruby-Methoden aufrufen und auch
keine locals verwenden kann, wird man Creole &uuml;blicherweise in Kombination mit
anderen Renderern verwenden wollen:</p>

<pre><code class="ruby">erb :overview, :locals =&gt; { :text =&gt; creole(:einfuehrung) }
</code></pre>

<p>Beachte, dass man die <code>creole</code>-Methode auch aus anderen Templates heraus
aufrufen kann:</p>

<pre><code class="ruby">%h1 Gru&szlig; von Haml!
%p= creole(:Gr&uuml;&szlig;e)
</code></pre>

<p>Da man Ruby nicht von Creole heraus aufrufen kann, k&ouml;nnen auch Layouts nicht in
Creole geschrieben werden. Es ist aber m&ouml;glich, einen Renderer f&uuml;r die Templates
zu verwenden und einen anderen f&uuml;r das Layout, indem die <code>:layout_engine</code>-Option
verwendet wird.</p>

<a name='CoffeeScript%20Templates'></a>
<h3>CoffeeScript Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td>
<a href="https://github.com/josh/ruby-coffee-script">coffee-script</a> und eine <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme">M&ouml;glichkeit JavaScript auszuf&uuml;hren</a>.</td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.coffee</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>
<a name='Stylus%20Templates'></a>
<h4>Stylus Templates</h4>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td>
      <a href="https://github.com/lucasmazza/ruby-stylus" title="Ruby Stylus">
        Stylus
      </a> und eine M&ouml;glichkeit 
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        JavaScript auszuf&uuml;hren
      </a>.
    </td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.styl</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>stylus :index</tt></td>
  </tr>
</table>
<p>Um Stylus-Templates ausf&uuml;hren zu k&ouml;nnen, m&uuml;ssen <code>stylus</code> und <code>stylus/tilt</code>
zuerst geladen werden:</p>

<pre><code class="ruby">require 'sinatra'
require 'stylus'
require 'stylus/tilt'

get '/' do
  stylus :example
end
</code></pre>

<a name='Yajl%20Templates'></a>
<h4>Yajl Templates</h4>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="https://github.com/brianmario/yajl-ruby" title="yajl-ruby">yajl-ruby</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.yajl</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td>
      <tt>
        yajl :index,
             :locals =&gt; { :key =&gt; 'qux' },
             :callback =&gt; 'present',
             :variable =&gt; 'resource'
      </tt>
    </td>
  </tr>
</table>
<p>Die Template-Quelle wird als Ruby-String evaluiert. Die daraus resultierende
json Variable wird mit Hilfe von <code>#to_json</code> umgewandelt:</p>

<pre><code class="ruby">json = { :foo =&gt; 'bar' }
json[:baz] = key
</code></pre>

<p>Die <code>:callback</code> und <code>:variable</code> Optionen k&ouml;nnen mit dem gerenderten Objekt
verwendet werden:</p>

<pre><code class="ruby">var resource = {"foo":"bar","baz":"qux"}; present(resource);
</code></pre>

<a name='WLang%20Templates'></a>
<h3>WLang Templates</h3>

<table>
<tr>
<td>Abh&auml;ngigkeit</td>
    <td><a href="https://github.com/blambeau/wlang/">wlang</a></td>
  </tr>
<tr>
<td>Dateierweiterung</td>
    <td><tt>.wlang</tt></td>
  </tr>
<tr>
<td>Beispiel</td>
    <td><tt>wlang :index, :locals =&gt; { :key =&gt; 'value' }</tt></td>
  </tr>
</table>
<p>Ruby-Methoden in wlang aufzurufen entspricht nicht den idiomatischen Vorgaben
von wlang, es bietet sich deshalb an, <code>:locals</code> zu verwenden. Layouts, die
wlang und <code>yield</code> verwenden, werden aber trotzdem unterst&uuml;tzt.</p>

<p>Rendert den eingebetteten Template-String.</p>

<a name='Auf%20Variablen%20in%20Templates%20zugreifen'></a>
<h3>Auf Variablen in Templates zugreifen</h3>

<p>Templates werden in demselben Kontext ausgef&uuml;hrt wie Routen. Instanzvariablen
in Routen sind auch direkt im Template verf&uuml;gbar:</p>

<pre><code class="ruby">get '/:id' do
  @foo = Foo.find(params[:id])
  haml '%h1= @foo.name'
end
</code></pre>

<p>Oder durch einen expliziten Hash von lokalen Variablen:</p>

<pre><code class="ruby">get '/:id' do
  foo = Foo.find(params[:id])
  haml '%h1= bar.name', :locals =&gt; { :bar =&gt; foo }
end
</code></pre>

<p>Dies wird typischerweise bei Verwendung von Subtemplates (partials) in anderen
Templates eingesetzt.</p>

<a name='Templates%20mit%20%3Ccode%3Eyield%3C/code%3E%20und%20verschachtelte%20Layouts'></a>
<h3>Templates mit <code>yield</code> und verschachtelte Layouts</h3>

<p>Ein Layout ist &uuml;blicherweise ein Template, dass ein <code>yield</code> aufruft. Ein solches
Template kann entweder wie oben beschrieben &uuml;ber die <code>:template</code> option
verwendet werden oder mit einem Block gerendert werden:</p>

<pre><code class="ruby">erb :post, :layout =&gt; false do
  erb :index
end
</code></pre>

<p>Dieser Code entspricht weitestgehend <code>erb :index, :layout =&gt; :post</code>.</p>

<p>Bl&ouml;cke an Render-Methoden weiterzugeben ist besonders bei verschachtelten
Layouts hilfreich:</p>

<pre><code class="ruby">erb :main_layout, :layout =&gt; false do
  erb :admin_layout do
    erb :user
  end
end
</code></pre>

<p>Der gleiche Effekt kann auch mit weniger Code erreicht werden:</p>

<pre><code class="ruby">erb :admin_layout, :layout =&gt; :main_layout do
  erb :user
end
</code></pre>

<p>Zur Zeit nehmen folgende Renderer Bl&ouml;cke an: <code>erb</code>, <code>haml</code>, <code>liquid</code>, <code>slim</code>
und <code>wlang</code>.</p>

<p>Das gleich gilt auch f&uuml;r die allgemeine <code>render</code> Methode.</p>

<a name='Inline-Templates'></a>
<h3>Inline-Templates</h3>

<p>Templates k&ouml;nnen auch am Ende der Datei definiert werden:</p>

<pre><code class="ruby">require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Hallo Welt!!!!!
</code></pre>

<p>Anmerkung: Inline-Templates, die in der Datei definiert sind, die <code>require
'sinatra'</code> aufruft, werden automatisch geladen. Um andere Inline-Templates in
anderen Dateien aufzurufen, muss explizit <code>enable :inline_templates</code> verwendet
werden.</p>

<a name='Benannte%20Templates'></a>
<h3>Benannte Templates</h3>

<p>Templates k&ouml;nnen auch mit der Top-Level <code>template</code>-Methode definiert werden:</p>

<pre><code class="ruby">template :layout do
  "%html\n  =yield\n"
end

template :index do
  '%div.title Hallo Welt!'
end

get '/' do
  haml :index
end
</code></pre>

<p>Wenn ein Template mit dem Namen "layout" existiert, wird es bei jedem Aufruf
verwendet. Durch <code>:layout =&gt; false</code> kann das Ausf&uuml;hren verhindert werden:</p>

<pre><code class="ruby">get '/' do
  haml :index, :layout =&gt; request.xhr?
end
</code></pre>

<a name='Dateiendungen%20zuordnen'></a>
<h3>Dateiendungen zuordnen</h3>

<p>Um eine Dateiendung einer Template-Engine zuzuordnen, kann <code>Tilt.register</code>
genutzt werden. Wenn etwa die Dateiendung <code>tt</code> f&uuml;r Textile-Templates genutzt
werden soll, l&auml;sst sich dies wie folgt bewerkstelligen:</p>

<pre><code class="ruby">Tilt.register :tt, Tilt[:textile]
</code></pre>

<a name='Eine%20eigene%20Template-Engine%20hinzuf&uuml;gen'></a>
<h3>Eine eigene Template-Engine hinzuf&uuml;gen</h3>

<p>Zu allererst muss die Engine bei Tilt registriert und danach eine
Rendering-Methode erstellt werden:</p>

<pre><code class="ruby">Tilt.register :mtt, MeineTolleTemplateEngine

helpers do
  def mtt(*args) render(:mtt, *args) end
end

get '/' do
  mtt :index
end
</code></pre>

<p>Dieser Code rendert <code>./views/application.mtt</code>. Siehe
<a href="https://github.com/rtomayko/tilt">github.com/rtomayko/tilt</a>, um mehr &uuml;ber
Tilt zu erfahren.</p>

<a name='Filter'></a>
<h2>Filter</h2>

<p>Before-Filter werden vor jedem Request in demselben Kontext, wie danach die
Routen, ausgef&uuml;hrt. So k&ouml;nnen etwa Request und Antwort ge&auml;ndert werden.
Gesetzte Instanzvariablen in Filtern k&ouml;nnen in Routen und Templates verwendet
werden:</p>

<pre><code class="ruby">before do
  @note = 'Hi!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @note #=&gt; 'Hi!'
  params[:splat] #=&gt; 'bar/baz'
end
</code></pre>

<p>After-Filter werden nach jedem Request in demselben Kontext ausgef&uuml;hrt und
k&ouml;nnen ebenfalls Request und Antwort &auml;ndern. In Before-Filtern gesetzte
Instanzvariablen k&ouml;nnen in After-Filtern verwendet werden:</p>

<pre><code class="ruby">after do
  puts response.status
end
</code></pre>

<p>Filter k&ouml;nnen optional auch mit einem Muster ausgestattet werden, welches auf
den Request-Pfad passen muss, damit der Filter ausgef&uuml;hrt wird:</p>

<pre><code class="ruby">before '/protected/*' do
  authenticate!
end

after '/create/:slug' do |slug|
  session[:last_slug] = slug
end
</code></pre>

<p>&Auml;hnlich wie Routen k&ouml;nnen Filter auch mit weiteren Bedingungen eingeschr&auml;nkt
werden:</p>

<pre><code class="ruby">before :agent =&gt; /Songbird/ do
  # ...
end

after '/blog/*', :host_name =&gt; 'example.com' do
  # ...
end
</code></pre>

<a name='Helfer'></a>
<h2>Helfer</h2>

<p>Durch die Top-Level <code>helpers</code>-Methode werden sogenannte Helfer-Methoden
definiert, die in Routen und Templates verwendet werden k&ouml;nnen:</p>

<pre><code class="ruby">helpers do
  def bar(name)
    "#{name}bar"
  end
end

get '/:name' do
  bar(params[:name])
end
</code></pre>

<a name='Sessions%20verwenden'></a>
<h3>Sessions verwenden</h3>

<p>Sessions werden verwendet, um Zust&auml;nde zwischen den Requests zu speichern. Sind
sie aktiviert, kann ein Session-Hash je Benutzer-Session verwendet werden:</p>

<pre><code class="ruby">enable :sessions

get '/' do
  "value = " &lt;&lt; session[:value].inspect
end

get '/:value' do
  session[:value] = params[:value]
end
</code></pre>

<p>Beachte, dass <code>enable :sessions</code> alle Daten in einem Cookie speichert. Unter
Umst&auml;nden kann dies negative Effekte haben, z.B. verursachen viele Daten
h&ouml;heren, teilweise &uuml;berfl&uuml;ssigen Traffic. Um das zu vermeiden, kann eine Rack-
Session-Middleware verwendet werden. Dabei wird auf <code>enable :sessions</code>
verzichtet und die Middleware wie &uuml;blich im Programm eingebunden:</p>

<pre><code class="ruby">use Rack::Session::Pool, :expire_after =&gt; 2592000

get '/' do
  "value = " &lt;&lt; session[:value].inspect
end

get '/:value' do
  session[:value] = params[:value]
end
</code></pre>

<p>Um die Sicherheit zu erh&ouml;hen, werden Cookies, die Session-Daten f&uuml;hren, mit
einem sogenannten Session-Secret signiert. Da sich dieses Geheimwort bei jedem
Neustart der Applikation automatisch &auml;ndert, ist es sinnvoll, ein eigenes zu
w&auml;hlen, damit sich alle Instanzen der Applikation dasselbe Session-Secret
teilen:</p>

<pre><code class="ruby">set :session_secret, 'super secret'
</code></pre>

<p>Zur weiteren Konfiguration kann man einen Hash mit Optionen in den <code>sessions</code>
Einstellungen ablegen.</p>

<pre><code class="ruby">set :sessions, :domain =&gt; 'foo.com'
</code></pre>

<a name='Anhalten'></a>
<h2>Anhalten</h2>

<p>Zum sofortigen Stoppen eines Request in einem Filter oder einer Route:</p>

<pre><code class="ruby">halt
</code></pre>

<p>Der Status kann beim Stoppen auch angegeben werden:</p>

<pre><code class="ruby">halt 410
</code></pre>

<p>Oder auch den Response-Body:</p>

<pre><code class="ruby">halt 'Hier steht der Body'
</code></pre>

<p>Oder beides:</p>

<pre><code class="ruby">halt 401, 'verschwinde!'
</code></pre>

<p>Sogar mit Headern:</p>

<pre><code class="ruby">halt 402, {'Content-Type' =&gt; 'text/plain'}, 'Rache'
</code></pre>

<p>Nat&uuml;rlich ist es auch m&ouml;glich, ein Template mit <code>halt</code> zu verwenden:</p>

<pre><code class="ruby">halt erb(:error)
</code></pre>

<a name='Weiterspringen'></a>
<h2>Weiterspringen</h2>

<p>Eine Route kann mittels <code>pass</code> zu der n&auml;chsten passenden Route springen:</p>

<pre><code class="ruby">get '/raten/:wer' do
  pass unless params[:wer] == 'Frank'
  'Du hast mich!'
end

get '/raten/*' do
  'Du hast mich nicht!'
end
</code></pre>

<p>Der Block wird sofort verlassen und es wird nach der n&auml;chsten treffenden Route
gesucht. Ein 404-Fehler wird zur&uuml;ckgegeben, wenn kein treffendes Routen-Muster
gefunden wird.</p>

<a name='Eine%20andere%20Route%20ansteuern'></a>
<h3>Eine andere Route ansteuern</h3>

<p>Manchmal entspricht <code>pass</code> nicht den Anforderungen, wenn das Ergebnis einer
anderen Route gefordert wird. Um das zu erreichen, l&auml;sst sich <code>call</code> nutzen:</p>

<pre><code class="ruby">get '/foo' do
  status, headers, body = call env.merge("PATH_INFO" =&gt; '/bar')
  [status, headers, body.map(&amp;:upcase)]
end

get '/bar' do
  "bar"
end
</code></pre>

<p>Beachte, dass in dem oben angegeben Beispiel die Performance erheblich erh&ouml;ht
werden kann, wenn <code>"bar"</code> in eine Helfer-Methode umgewandelt wird, auf die
<code>/foo</code> und <code>/bar</code> zugreifen k&ouml;nnen.</p>

<p>Wenn der Request innerhalb derselben Applikations-Instanz aufgerufen und keine
Kopie der Instanz erzeugt werden soll, kann <code>call!</code> anstelle von <code>call</code>
verwendet werden.</p>

<p>Die Rack-Spezifikationen enthalten weitere Informationen zu <code>call</code>.</p>

<a name='Body,%20Status-Code%20und%20Header%20setzen'></a>
<h3>Body, Status-Code und Header setzen</h3>

<p>Es ist m&ouml;glich und empfohlen, den Status-Code sowie den Response-Body mit
einem Returnwert in der Route zu setzen. In manchen Situationen kann es jedoch
sein, dass der Body an irgendeiner anderen Stelle w&auml;hrend der Ausf&uuml;hrung
gesetzt wird. Das l&auml;sst sich mit der Helfer-Methode <code>body</code> bewerkstelligen.
Wird <code>body</code> verwendet, l&auml;sst sich der Body jederzeit &uuml;ber diese Methode
aufrufen:</p>

<pre><code class="ruby">get '/foo' do
  body "bar"
end

after do
  puts body
end
</code></pre>

<p>Ebenso ist es m&ouml;glich, einen Block an <code>body</code> weiterzureichen, der dann vom
Rack-Handler ausgef&uuml;hrt wird (l&auml;sst sich z.B. zur Umsetzung von Streaming
einsetzen, siehe auch "R&uuml;ckgabewerte").</p>

<p>Vergleichbar mit <code>body</code> lassen sich auch Status-Code und Header setzen:</p>

<pre><code class="ruby">get '/foo' do
  status 418
  headers \
    "Allow"   =&gt; "BREW, POST, GET, PROPFIND, WHEN",
    "Refresh" =&gt; "Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"
  halt "Ich bin ein Teekesselchen"
end
</code></pre>

<p>Genau wie bei <code>body</code> liest ein Aufrufen von <code>headers</code> oder <code>status</code> ohne
Argumente den aktuellen Wert aus.</p>

<a name='Response-Streams'></a>
<h3>Response-Streams</h3>

<p>In manchen Situationen sollen Daten bereits an den Client zur&uuml;ckgeschickt
werden, bevor ein vollst&auml;ndiger Response bereit steht. Manchmal will man die
Verbindung auch erst dann beenden und Daten so lange an den Client
zur&uuml;ckschicken, bis er die Verbindung abbricht. F&uuml;r diese F&auml;lle gibt es die
<code>stream</code>-Helfer-Methode, die es einem erspart eigene L&ouml;sungen zu schreiben:</p>

<pre><code class="ruby">get '/' do
  stream do |out|
    out &lt;&lt; "Das ist ja mal wieder fanta -\n"
    sleep 0.5
    out &lt;&lt; " (bitte warten&hellip;) \n"
    sleep 1
    out &lt;&lt; "- stisch!\n"
  end
end
</code></pre>

<p>Damit lassen sich Streaming-APIs realisieren, sog. 
<a href="http://dev.w3.org/html5/eventsource/">Server Sent Events</a> die als Basis f&uuml;r
<a href="http://en.wikipedia.org/wiki/WebSocket">WebSockets</a> dienen. Ebenso k&ouml;nnen sie
verwendet werden, um den Durchsatz zu erh&ouml;hen, wenn ein Teil der Daten von
langsamen Ressourcen abh&auml;ngig ist.</p>

<p>Es ist zu beachten, dass das Verhalten beim Streaming, insbesondere die Anzahl
nebenl&auml;ufiger Anfragen, stark davon abh&auml;ngt, welcher Webserver f&uuml;r die
Applikation verwendet wird. Einige Server, z.B. WEBRick, unterst&uuml;tzen
Streaming nicht oder nur teilweise. Sollte der Server Streaming nicht
unterst&uuml;tzen, wird ein vollst&auml;ndiger Response-Body zur&uuml;ckgeschickt, sobald der
an <code>stream</code> weitergegebene Block abgearbeitet ist. Mit Shotgun funktioniert
Streaming z.B. &uuml;berhaupt nicht.</p>

<p>Ist der optionale Parameter <code>keep_open</code> aktiviert, wird beim gestreamten Objekt
<code>close</code> nicht aufgerufen und es ist einem &uuml;berlassen dies an einem beliebigen
sp&auml;teren Zeitpunkt nachholen. Die Funktion ist jedoch nur bei Event-gesteuerten
Serven wie Thin oder Rainbows m&ouml;glich, andere Server werden trotzdem den Stream
beenden:</p>

<pre><code class="ruby"># Durchgehende Anfrage (long polling)

set :server, :thin
connections = []

get '/subscribe' do
  # Client-Registrierung beim Server, damit Events mitgeteilt werden k&ouml;nnen
  stream(:keep_open) { |out| connections &lt;&lt; out }

  # tote Verbindungen entfernen 
  connections.reject!(&amp;:closed?)

  # R&uuml;ckmeldung
  "Angemeldet"
end

post '/message' do
  connections.each do |out|
    # Den Client &uuml;ber eine neue Nachricht in Kenntnis setzen
    # notify client that a new message has arrived
    out &lt;&lt; params[:message] &lt;&lt; "\n"

    # Den Client zur erneuten Verbindung auffordern
    out.close
  end

  # R&uuml;ckmeldung
  "Mitteiling erhalten"
end
</code></pre>

<a name='Logger'></a>
<h3>Logger</h3>

<p>Im Geltungsbereich eines Request stellt die <code>logger</code> Helfer-Methode eine <code>Logger</code>
Instanz zur Verf&uuml;gung:</p>

<pre><code class="ruby">get '/' do
  logger.info "es passiert gerade etwas"
  # ...
end
</code></pre>

<p>Der Logger &uuml;bernimmt dabei automatisch alle im Rack-Handler eingestellten 
Log-Vorgaben. Ist Loggen ausgeschaltet, gibt die Methode ein Leerobjekt zur&uuml;ck.
In den Routen und Filtern muss man sich also nicht weiter darum k&uuml;mmern.</p>

<p>Beachte, dass das Loggen standardm&auml;&szlig;ig nur f&uuml;r <code>Sinatra::Application</code>
voreingestellt ist. Wird &uuml;ber <code>Sinatra::Base</code> vererbt, muss es erst aktiviert
werden:</p>

<pre><code class="ruby">class MyApp &lt; Sinatra::Base
  configure :production, :development  do
    enable :logging
  end
end
</code></pre>

<p>Damit auch keine Middleware das Logging aktivieren kann, muss die <code>logging</code>
Einstellung auf <code>nil</code> gesetzt werden. Das hei&szlig;t aber auch, dass <code>logger</code> in
diesem Fall <code>nil</code> zur&uuml;ckgeben wird. &Uuml;blicherweise wird das eingesetzt, wenn ein
eigener Logger eingerichtet werden soll. Sinatra wird dann verwenden, was in 
<code>env['rack.logger']</code> eingetragen ist.</p>

<a name='Mime-Types'></a>
<h2>Mime-Types</h2>

<p>Wenn <code>send_file</code> oder statische Dateien verwendet werden, kann es vorkommen,
dass Sinatra den Mime-Typ nicht kennt. Registriert wird dieser mit <code>mime_type</code>
per Dateiendung:</p>

<pre><code class="ruby">configure do
  mime_type :foo, 'text/foo'
end
</code></pre>

<p>Es kann aber auch der <code>content_type</code>-Helfer verwendet werden:</p>

<pre><code class="ruby">get '/' do
  content_type :foo
  "foo foo foo"
end
</code></pre>

<a name='URLs%20generieren'></a>
<h3>URLs generieren</h3>

<p>Zum Generieren von URLs sollte die <code>url</code>-Helfer-Methode genutzen werden, so z.B.
beim Einsatz von Haml:</p>

<pre><code class="ruby">%a{:href =&gt; url('/foo')} foo
</code></pre>

<p>Soweit vorhanden, wird R&uuml;cksicht auf Proxys und Rack-Router genommen.</p>

<p>Diese Methode ist ebenso &uuml;ber das Alias <code>to</code> zu erreichen (siehe Beispiel unten).</p>

<a name='Browser-Umleitung'></a>
<h3>Browser-Umleitung</h3>

<p>Eine Browser-Umleitung kann mithilfe der <code>redirect</code>-Helfer-Methode erreicht
werden:</p>

<pre><code class="ruby">get '/foo' do
  redirect to('/bar')
end
</code></pre>

<p>Weitere Parameter werden wie Argumente der <code>halt</code>-Methode behandelt:</p>

<pre><code class="ruby">redirect to('/bar'), 303
redirect 'http://google.com', 'Hier bist du falsch'
</code></pre>

<p>Ebenso leicht l&auml;sst sich ein Schritt zur&uuml;ck mit dem Alias <code>redirect back</code>
erreichen:</p>

<pre><code class="ruby">get '/foo' do
  "&lt;a href='/bar'&gt;mach was&lt;/a&gt;"
end

get '/bar' do
  mach_was
  redirect back
end
</code></pre>

<p>Um Argumente an ein Redirect weiterzugeben, k&ouml;nnen sie entweder dem Query
&uuml;bergeben:</p>

<pre><code class="ruby">redirect to('/bar?summe=42')
</code></pre>

<p>oder eine Session verwendet werden:</p>

<pre><code class="ruby">enable :sessions

get '/foo' do
  session[:secret] = 'foo'
  redirect to('/bar')
end

get '/bar' do
  session[:secret]
end
</code></pre>

<a name='Cache%20einsetzen'></a>
<h3>Cache einsetzen</h3>

<p>Ein sinnvolles Einstellen von Header-Daten ist die Grundlage f&uuml;r ein
ordentliches HTTP-Caching.</p>

<p>Der Cache-Control-Header l&auml;sst sich ganz einfach einstellen:</p>

<pre><code class="ruby">get '/' do
  cache_control :public
  "schon gecached!"
end
</code></pre>

<p>Profitipp: Caching im before-Filter aktivieren</p>

<pre><code class="ruby">before do
  cache_control :public, :must_revalidate, :max_age =&gt; 60
end
</code></pre>

<p>Bei Verwendung der <code>expires</code>-Helfermethode zum Setzen des gleichnamigen Headers,
wird <code>Cache-Control</code> automatisch eigestellt:</p>

<pre><code class="ruby">before do
  expires 500, :public, :must_revalidate
end
</code></pre>

<p>Um alles richtig zu machen, sollten auch <code>etag</code> oder <code>last_modified</code> verwendet
werden. Es wird empfohlen, dass diese Helfer aufgerufen werden <strong>bevor</strong> die
eigentliche Arbeit anf&auml;ngt, da sie sofort eine Antwort senden, wenn der Client
eine aktuelle Version im Cache vorh&auml;lt:</p>

<pre><code class="ruby">get '/article/:id' do
  @article = Article.find params[:id]
  last_modified @article.updated_at
  etag @article.sha1
  erb :article
end
</code></pre>

<p>ebenso ist es m&ouml;glich einen 
<a href="http://de.wikipedia.org/wiki/HTTP_ETag">schwachen ETag</a> zu verwenden:</p>

<pre><code class="ruby">etag @article.sha1, :weak
</code></pre>

<p>Diese Helfer f&uuml;hren nicht das eigentliche Caching aus, sondern geben die daf&uuml;r
notwendigen Informationen an den Cache weiter. F&uuml;r schnelle Reverse-Proxy
Cache-L&ouml;sungen bietet sich z.B.
<a href="https://github.com/rtomayko/rack-cache">rack-cache</a> an:</p>

<pre><code class="ruby">require "rack/cache"
require "sinatra"

use Rack::Cache

get '/' do
  cache_control :public, :max_age =&gt; 36000
  sleep 5
  "hello"
end
</code></pre>

<p>Um den <code>Cache-Control</code>-Header mit Informationen zu versorgen, verwendet man die
<code>:static_cache_control</code>-Einstellung (s.u.).</p>

<p>Nach RFC 2616 sollte sich die Anwendung anders verhalten, wenn ein If-Match oder
ein If-None_match Header auf <code>*</code> gesetzt wird in Abh&auml;ngigkeit davon, ob die
Resource bereits existiert. Sinatra geht davon aus, dass Ressourcen bei sicheren
Anfragen (z.B. bei get oder Idempotenten Anfragen wie put) bereits existieren,
wobei anderen Ressourcen (besipielsweise bei post), als neue Ressourcen
behandelt werden. Dieses Verhalten l&auml;sst sich mit der <code>:new_resource</code> Option
&auml;ndern:</p>

<pre><code class="ruby">get '/create' do
  etag '', :new_resource =&gt; true
  Article.create
  erb :new_article
end
</code></pre>

<p>Soll das schwache ETag trotzdem verwendet werden, verwendet man die <code>:kind</code>
Option:</p>

<pre><code class="ruby">etag '', :new_resource =&gt; true, :kind =&gt; :weak
</code></pre>

<a name='Dateien%20versenden'></a>
<h3>Dateien versenden</h3>

<p>Zum Versenden von Dateien kann die <code>send_file</code>-Helfer-Methode verwendet werden:</p>

<pre><code class="ruby">get '/' do
  send_file 'foo.png'
end
</code></pre>

<p>F&uuml;r <code>send_file</code> stehen einige Hash-Optionen zur Verf&uuml;gung:</p>

<pre><code class="ruby">send_file 'foo.png', :type =&gt; :jpg
</code></pre>

<dl>
<dt>filename</dt>
  <dd>Dateiname als Response. Standardwert ist der eigentliche Dateiname.</dd>

  <dt>last_modified</dt>
  <dd>Wert f&uuml;r den Last-Modified-Header, Standardwert ist <tt>mtime</tt> der
    Datei.</dd>
  
  <dt>type</dt>
  <dd>Content-Type, der verwendet werden soll. Wird, wenn nicht angegeben, von
    der Dateiendung abgeleitet.</dd>
  
  <dt>disposition</dt>
  <dd>Verwendet f&uuml;r Content-Disposition. M&ouml;gliche Werte sind: <tt>nil</tt>
    (Standard), <tt>:attachment</tt> und <tt>:inline</tt>.</dd>
  
  <dt>length</dt>
  <dd>Content-Length-Header. Standardwert ist die Dateigr&ouml;&szlig;e.</dd>
</dl>
<p>Soweit vom Rack-Handler unterst&uuml;tzt, werden neben der &Uuml;bertragung &uuml;ber den
Ruby-Prozess auch andere M&ouml;glichkeiten genutzt. Bei Verwendung der
<code>send_file</code>-Helfer-Methode k&uuml;mmert sich Sinatra selbstst&auml;ndig um die
Range-Requests.</p>

<a name='Das%20Request-Objekt'></a>
<h2>Das Request-Objekt</h2>

<p>Auf das <code>request</code>-Objekt der eigehenden Anfrage kann vom Anfrage-Scope aus
zugegriffen werden:</p>

<pre><code class="ruby"># App l&auml;uft unter http://example.com/example
get '/foo' do
  t = %w[text/css text/html application/javascript]
  request.accept              # ['text/html', '*/*']
  request.accept? 'text/xml'  # true
  request.preferred_type(t)   # 'text/html'
  request.body                # Request-Body des Client (siehe unten)
  request.scheme              # "http"
  request.script_name         # "/example"
  request.path_info           # "/foo"
  request.port                # 80
  request.request_method      # "GET"
  request.query_string        # ""
  request.content_length      # L&auml;nge des request.body
  request.media_type          # Medientypus von request.body
  request.host                # "example.com"
  request.get?                # true (&auml;hnliche Methoden f&uuml;r andere Verben)
  request.form_data?          # false
  request["irgendein_param"]  # Wert von einem Parameter; [] ist die Kurzform f&uuml;r den params Hash
  request.referrer            # Der Referrer des Clients oder '/'
  request.user_agent          # User-Agent (verwendet in der :agent Bedingung)
  request.cookies             # Hash des Browser-Cookies
  request.xhr?                # Ist das hier ein Ajax-Request?
  request.url                 # "http://example.com/example/foo"
  request.path                # "/example/foo"
  request.ip                  # IP-Adresse des Clients
  request.secure?             # false (true wenn SSL)
  request.forwarded?          # true (Wenn es hinter einem Reverse-Proxy verwendet wird)
  request.env                 # vollst&auml;ndiger env-Hash von Rack &uuml;bergeben
end
</code></pre>

<p>Manche Optionen, wie etwa <code>script_name</code> oder <code>path_info</code>, sind auch
schreibbar:</p>

<pre><code class="ruby">before { request.path_info = "/" }

get "/" do
  "Alle Anfragen kommen hier an!"
end
</code></pre>

<p>Der <code>request.body</code> ist ein IO- oder StringIO-Objekt:</p>

<pre><code class="ruby">post "/api" do
  request.body.rewind # falls schon jemand davon gelesen hat
  daten = JSON.parse request.body.read
  "Hallo #{daten['name']}!"
end
</code></pre>

<a name='Anh&auml;nge'></a>
<h3>Anh&auml;nge</h3>

<p>Damit der Browser erkennt, dass ein Response gespeichert und nicht im Browser
angezeigt werden soll, kann der <code>attachment</code>-Helfer verwendet werden:</p>

<pre><code class="ruby">get '/' do
  attachment
  "Speichern!"
end
</code></pre>

<p>Ebenso kann eine Dateiname als Parameter hinzugef&uuml;gt werden:</p>

<pre><code class="ruby">get '/' do
  attachment "info.txt"
  "Speichern!"
end
</code></pre>

<a name='Umgang%20mit%20Datum%20und%20Zeit'></a>
<h3>Umgang mit Datum und Zeit</h3>

<p>Sinatra bietet eine <code>time_for</code>-Helfer-Methode, die aus einem gegebenen Wert ein
Time-Objekt generiert. Ebenso kann sie nach <code>DateTime</code>, <code>Date</code> und &auml;hnliche
Klassen konvertieren:</p>

<pre><code class="ruby">get '/' do
  pass if Time.now &gt; time_for('Dec 23, 2012')
  "noch Zeit"
end
</code></pre>

<p>Diese Methode wird intern f&uuml;r +expires, <code>last_modiefied</code> und ihresgleichen
verwendet. Mit ein paar Handgriffen l&auml;sst sich diese Methode also in ihrem
Verhalten erweitern, indem man <code>time_for</code> in der eigenen Applikation 
&uuml;berschreibt:</p>

<pre><code class="ruby">helpers do
  def time_for(value)
    case value
    when :yesterday then Time.now - 24*60*60
    when :tomorrow  then Time.now + 24*60*60
    else super
    end
  end
end

get '/' do
  last_modified :yesterday
  expires :tomorrow
  "Hallo"
end
</code></pre>

<a name='Nachschlagen%20von%20Template-Dateien'></a>
<h3>Nachschlagen von Template-Dateien</h3>

<p>Die <code>find_template</code>-Helfer-Methode wird genutzt, um Template-Dateien zum Rendern
aufzufinden:</p>

<pre><code class="ruby">find_template settings.views, 'foo', Tilt[:haml] do |file|
  puts "k&ouml;nnte diese hier sein: #{file}"
end
</code></pre>

<p>Das ist zwar nicht wirklich brauchbar, aber wenn man sie &uuml;berschreibt, kann sie
n&uuml;tzlich werden, um eigene Nachschlage-Mechanismen einzubauen. Zum Beispiel
dann, wenn mehr als nur ein view-Verzeichnis verwendet werden soll:</p>

<pre><code class="ruby">set :views, ['views', 'templates']

helpers do
  def find_template(views, name, engine, &amp;block)
    Array(views).each { |v| super(v, name, engine, &amp;block) }
  end
end
</code></pre>

<p>Ein anderes Beispiel w&auml;re, verschiedene Vereichnisse f&uuml;r verschiedene Engines
zu verwenden:</p>

<pre><code class="ruby">set :views, :sass =&gt; 'views/sass', :haml =&gt; 'templates', :default =&gt; 'views'

helpers do
  def find_template(views, name, engine, &amp;block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:default]
    super(folder, name, engine, &amp;block)
  end
end
</code></pre>

<p>Ebensogut k&ouml;nnte eine Extension aber auch geschrieben und mit anderen geteilt
werden!</p>

<p>Beachte, dass <code>find_template</code> nicht pr&uuml;ft, ob eine Datei tats&auml;chlich existiert.
Es wird lediglich der angegebene Block aufgerufen und nach allen m&ouml;glichen
Pfaden gesucht. Das ergibt kein Performance-Problem, da <code>render</code> <code>block</code> 
verwendet, sobald eine Datei gefunden wurde. Ebenso werden Template-Pfade samt
Inhalt gecached, solange nicht im Entwicklungsmodus gearbeitet wird. Das sollte
im Hinterkopf behalten werden, wenn irgendwelche verr&uuml;ckten Methoden
zusammenbastelt werden.</p>

<a name='Konfiguration'></a>
<h2>Konfiguration</h2>

<p>Wird einmal beim Starten in jedweder Umgebung ausgef&uuml;hrt:</p>

<pre><code class="ruby">configure do
  # setze eine Option
  set :option, 'wert'

  # setze mehrere Optionen
  set :a =&gt; 1, :b =&gt; 2

  # das gleiche wie `set :option, true`
  enable :option

  # das gleiche wie `set :option, false`
  disable :option

  # dynamische Einstellungen mit Bl&ouml;cken
  set(:css_dir) { File.join(views, 'css') }
end
</code></pre>

<p>L&auml;uft nur, wenn die Umgebung (RACK_ENV-Umgebungsvariable) auf <code>:production</code>
gesetzt ist:</p>

<pre><code class="ruby">configure :production do
  ...
end
</code></pre>

<p>L&auml;uft nur, wenn die Umgebung auf <code>:production</code> oder auf <code>:test</code> gesetzt ist:</p>

<pre><code class="ruby">configure :production, :test do
  ...
end
</code></pre>

<p>Diese Einstellungen sind &uuml;ber <code>settings</code> erreichbar:</p>

<pre><code class="ruby">configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # =&gt; true
  settings.foo  # =&gt; 'bar'
  ...
end
</code></pre>

<a name='Einstellung%20des%20Angriffsschutzes'></a>
<h3>Einstellung des Angriffsschutzes</h3>

<p>Sinatra verwendet
<a href="https://github.com/rkh/rack-protection#readme">Rack::Protection</a>, um die
Anwendung vor h&auml;ufig vorkommenden Angriffen zu sch&uuml;tzen. Diese Voreinstellung
l&auml;sst sich selbstverst&auml;ndlich deaktivieren, der damit verbundene
Geschwindigkeitszuwachs steht aber in keinem Verh&auml;tnis zu den m&ouml;glichen
Risiken.</p>

<pre><code class="ruby">disable :protection
</code></pre>

<p>Um einen bestimmten Schutzmechanismus zu deaktivieren, f&uuml;gt man <code>protection</code>
einen Hash mit Optionen hinzu:</p>

<pre><code class="ruby">set :protection, :except =&gt; :path_traversal
</code></pre>

<p>Neben Strings akzeptiert <code>:except</code> auch Arrays, um gleich mehrere
Schutzmechanismen zu deaktivieren:</p>

<pre><code class="ruby">set :protection, :except =&gt; [:path_traversal, :session_hijacking]
</code></pre>

<a name='M&ouml;gliche%20Einstellungen'></a>
<h2>M&ouml;gliche Einstellungen</h2>

<dl>
<dt>absolute_redirects</dt>
  <dd>Wenn ausgeschaltet, wird Sinatra relative Redirects zulassen. Jedoch ist
  Sinatra dann nicht mehr mit RFC 2616 (HTTP 1.1) konform, das nur absolute
  Redirects zul&auml;sst. Sollte eingeschaltet werden, wenn die Applikation hinter
  einem Reverse-Proxy liegt, der nicht ordentlich eingerichtet ist. Beachte,
  dass die <tt>url</tt>-Helfer-Methode nach wie vor absolute URLs erstellen
  wird, es sei denn, es wird als zweiter Parameter <tt>false</tt> angegeben.
  Standardm&auml;&szlig;ig nicht aktiviert.</dd>

  <dt>add_charsets</dt>
  <dd>Mime-Types werden hier automatisch der Helfer-Methode
  <tt>content_type</tt> zugeordnet. Es empfielt sich, Werte hinzuzuf&uuml;gen statt
  sie zu &uuml;berschreiben: <tt>settings.add_charsets 
  </tt>
</dd>

  <dt>app_file</dt>
  <dd>Pfad zur Hauptdatei der Applikation. Wird verwendet, um das Wurzel-,
  Inline-, View- und &ouml;ffentliche Verzeichnis des Projekts festzustellen.</dd>

  <dt>bind</dt>
  <dd>IP-Address, an die gebunden wird (Standardwert: <tt>0.0.0.0</tt>). Wird
  nur f&uuml;r den eingebauten Server verwendet.</dd>

  <dt>default_encoding</dt>
  <dd>Das Encoding, falls keines angegeben wurde. Standardwert ist
  <tt>"utf-8"</tt>.</dd>

  <dt>dump_errors</dt>
  <dd>Fehler im Log anzeigen.</dd>

  <dt>environment</dt>
  <dd>Momentane Umgebung. Standardm&auml;&szlig;ig auf <tt>content_type</tt> oder
  <tt>"development"</tt> eingestellt, soweit ersteres nicht vorhanden.</dd>

  <dt>logging</dt>
  <dd>Den Logger verwenden.</dd>

  <dt>lock</dt>
  <dd>Jeder Request wird gelocked. Es kann nur ein Request pro Ruby-Prozess
  gleichzeitig verarbeitet werden. Eingeschaltet, wenn die Applikation
  threadsicher ist. Standardm&auml;&szlig;ig nicht aktiviert.</dd>

  <dt>method_override</dt>
  <dd>Verwende <tt>_method</tt>, um put/delete-Formulardaten in Browsern zu
  verwenden, die dies normalerweise nicht unterst&uuml;tzen.</dd>

  <dt>port</dt>
  <dd>Port f&uuml;r die Applikation. Wird nur im internen Server verwendet.</dd>

  <dt>prefixed_redirects</dt>
  <dd>Entscheidet, ob <tt>request.script_name</tt> in Redirects eingef&uuml;gt wird
  oder nicht, wenn kein absoluter Pfad angegeben ist. Auf diese Weise verh&auml;lt
  sich <tt>redirect '/foo'</tt> so, als w&auml;re es ein <tt>redirect
  to('/foo')</tt>. Standardm&auml;&szlig;ig nicht aktiviert.</dd>

  <dt>protection</dt>
  <dd>Legt fest, ob der Schutzmechanismus f&uuml;r h&auml;ufig Vorkommende Webangriffe
  auf Webapplikationen aktiviert wird oder nicht. Weitere Informationen im
  vorhergehenden Abschnitt.</dd>

  <dt>public_folder</dt>
  <dd>Das &ouml;ffentliche Verzeichnis, aus dem Daten zur Verf&uuml;gung gestellt werden
  k&ouml;nnen. Wird nur dann verwendet, wenn statische Daten zur Verf&uuml;gung gestellt
  werden k&ouml;nnen (s.u. <tt>static</tt> Option). Leitet sich von der
  <tt>app_file</tt> Einstellung ab, wenn nicht gesetzt.</dd>

  <dt>public_dir</dt>
  <dd>Alias f&uuml;r <tt>public_folder</tt>, s.o.</dd>

  <dt>reload_templates</dt>
  <dd>Im development-Modus aktiviert.</dd>

  <dt>root</dt>
  <dd>Wurzelverzeichnis des Projekts. Leitet sich von der <tt>app_file</tt>
  Einstellung ab, wenn nicht gesetzt.</dd>

  <dt>raise_errors</dt>
  <dd>Einen Ausnahmezustand aufrufen. Beendet die Applikation. Ist automatisch
  aktiviert, wenn die Umgebung auf <tt>"test"</tt> eingestellt ist. Ansonsten
  ist diese Option deaktiviert.</dd>

  <dt>run</dt>
  <dd>Wenn aktiviert, wird Sinatra versuchen, den Webserver zu starten. Nicht
  verwenden, wenn Rackup oder anderes verwendet werden soll.</dd>

  <dt>running</dt>
  <dd>L&auml;uft der eingebaute Server? Diese Einstellung nicht &auml;ndern!</dd>

  <dt>server</dt>
  <dd>Server oder Liste von Servern, die als eingebaute Server zur Verf&uuml;gung
  stehen. Standardm&auml;&szlig;ig auf <tt>[&lsquo;thin&rsquo;, &lsquo;mongrel&rsquo;, &lsquo;webrick&rsquo;]</tt>
  voreingestellt. Die Anordnung gibt die Priorit&auml;t vor.</dd>

  <dt>sessions</dt>
  <dd>Sessions auf Cookiebasis mittels
  <tt>Rack::Session::Cookie</tt>aktivieren. F&uuml;r weitere Infos bitte in der
  Sektion &lsquo;Sessions verwenden&rsquo; nachschauen.</dd>

  <dt>show_exceptions</dt>
  <dd>Bei Fehlern einen Stacktrace im Browseranzeigen. Ist automatisch
  aktiviert, wenn die Umgebung auf <tt>"development"</tt> eingestellt ist.
  Ansonsten ist diese Option deaktiviert. Kann auch auf <tt>:after_handler</tt>
  gestellt werden, um eine anwendungsspezifische Fehlerbehandlung auszul&ouml;sen,
  bevor der Fehlerverlauf im Browser angezeigt wird.</dd>

  <dt>static</dt>
  <dd>Entscheidet, ob Sinatra statische Dateien zur Verf&uuml;gung stellen soll oder
  nicht. Sollte nicht aktiviert werden, wenn ein Server verwendet wird, der
  dies auch selbstst&auml;ndig erledigen kann. Deaktivieren wird die Performance
  erh&ouml;hen. Standardm&auml;&szlig;ig aktiviert.</dd>

  <dt>static_cache_control</dt>
  <dd>Wenn Sinatra statische Daten zur Verf&uuml;gung stellt, k&ouml;nnen mit dieser
  Einstellung die <tt>Cache-Control</tt> Header zu den Responses hinzugef&uuml;gt
  werden. Die Einstellung verwendet dazu die <tt>cache_control</tt>
  Helfer-Methode. Standardm&auml;&szlig;ig deaktiviert. Ein Array wird verwendet, um
  mehrere Werte gleichzeitig zu &uuml;bergeben: <tt>set :static_cache_control,
  [:public, :max_age =&gt; 300]</tt>
</dd>

  <dt>threaded</dt>
  <dd>Wird es auf <tt>true</tt> gesetzt, wird Thin aufgefordert
  <tt>EventMachine.defer</tt> zur Verarbeitung des Requests einzusetzen.</dd>
  
  <dt>views</dt>
  <dd>Verzeichnis der Views. Leitet sich von der <tt>app_file</tt> Einstellung
  ab, wenn nicht gesetzt.</dd>

  <dt>x_cascade</dt>
  <dd>Einstellung, ob der X-Cascade Header bei fehlender Route gesetzt wird oder
  nicht. Standardeinstellung ist <tt>true</tt>.</dd>
</dl>
<a name='Umgebungen'></a>
<h2>Umgebungen</h2>

<p>Es gibt drei voreingestellte Umgebungen in Sinatra: <code>"development"</code>,
<code>"production"</code> und <code>"test"</code>. Umgebungen k&ouml;nnen &uuml;ber die <code>RACK_ENV</code>
Umgebungsvariable gesetzt werden. Die Standardeinstellung ist <code>"development"</code>.
In diesem Modus werden alle Templates zwischen Requests neu geladen. Dazu gibt
es besondere Fehlerseiten f&uuml;r 404 Stati und Fehlermeldungen. In <code>"production"</code>
und <code>"test"</code> werden Templates automatisch gecached.</p>

<p>Um die Anwendung in einer anderen Umgebung auszuf&uuml;hren kann man die <code>-e</code>
Option verwenden:</p>

<pre><code>ruby my_app.rb -e [ENVIRONMENT]
</code></pre>

<p>In der Anwendung kann man die die Methoden  <code>development?</code>, <code>test?</code> und
<code>production?</code> verwenden, um die aktuelle Umgebung zu erfahren.</p>

<a name='Fehlerbehandlung'></a>
<h2>Fehlerbehandlung</h2>

<p>Error-Handler laufen in demselben Kontext wie Routen und Filter, was bedeutet,
dass alle Goodies wie <code>haml</code>, <code>erb</code>, <code>halt</code>, etc. verwendet werden k&ouml;nnen.</p>

<a name='Nicht%20gefunden'></a>
<h3>Nicht gefunden</h3>

<p>Wenn eine <code>Sinatra::NotFound</code>-Exception geworfen wird oder der Statuscode 404
ist, wird der <code>not_found</code>-Handler ausgef&uuml;hrt:</p>

<pre><code class="ruby">not_found do
  'Seite kann nirgendwo gefunden werden.'
end
</code></pre>

<a name='Fehler'></a>
<h3>Fehler</h3>

<p>Der <code>error</code>-Handler wird immer ausgef&uuml;hrt, wenn eine Exception in einem
Routen-Block oder in einem Filter geworfen wurde. Die Exception kann &uuml;ber die
<code>sinatra.error</code>-Rack-Variable angesprochen werden:</p>

<pre><code class="ruby">error do
  'Entschuldige, es gab einen h&auml;sslichen Fehler - ' + env['sinatra.error'].name
end
</code></pre>

<p>Benutzerdefinierte Fehler:</p>

<pre><code class="ruby">error MeinFehler do
  'Au weia, ' + env['sinatra.error'].message
end
</code></pre>

<p>Dann, wenn das passiert:</p>

<pre><code class="ruby">get '/' do
  raise MeinFehler, 'etwas Schlimmes ist passiert'
end
</code></pre>

<p>bekommt man dieses:</p>

<pre><code>Au weia, etwas Schlimmes ist passiert
</code></pre>

<p>Alternativ kann ein Error-Handler auch f&uuml;r einen Status-Code definiert werden:</p>

<pre><code class="ruby">error 403 do
  'Zugriff verboten'
end

get '/geheim' do
  403
end
</code></pre>

<p>Oder ein Status-Code-Bereich:</p>

<pre><code class="ruby">error 400..510 do
  'Hallo?'
end
</code></pre>

<p>Sinatra setzt verschiedene <code>not_found</code>- und <code>error</code>-Handler in der
Development-Umgebung ein, um hilfreiche Debugging Informationen und Stack Traces
anzuzeigen.</p>

<a name='Rack-Middleware'></a>
<h2>Rack-Middleware</h2>

<p>Sinatra baut auf <a href="http://rack.rubyforge.org/">Rack</a>, einem minimalistischen
Standard-Interface f&uuml;r Ruby-Webframeworks. Eines der interessantesten Features
f&uuml;r Entwickler ist der Support von Middlewares, die zwischen den Server und
die Anwendung geschaltet werden und so HTTP-Request und/oder Antwort
&uuml;berwachen und/oder manipulieren k&ouml;nnen.</p>

<p>Sinatra macht das Erstellen von Middleware-Verkettungen mit der
Top-Level-Methode <code>use</code> zu einem Kinderspiel:</p>

<pre><code class="ruby">require 'sinatra'
require 'meine_middleware'

use Rack::Lint
use MeineMiddleware

get '/hallo' do
  'Hallo Welt'
end
</code></pre>

<p>Die Semantik von <code>use</code> entspricht der gleichnamigen Methode der
<a href="http://rack.rubyforge.org/doc/classes/Rack/Builder.html">Rack::Builder</a>-DSL
(meist verwendet in Rackup-Dateien). Ein Beispiel daf&uuml;r ist, dass die
<code>use</code>-Methode mehrere/verschiedene Argumente und auch Bl&ouml;cke entgegennimmt:</p>

<pre><code class="ruby">use Rack::Auth::Basic do |username, password|
  username == 'admin' &amp;&amp; password == 'geheim'
end
</code></pre>

<p>Rack bietet eine Vielzahl von Standard-Middlewares f&uuml;r Logging, Debugging,
URL-Routing, Authentifizierung und Session-Verarbeitung. Sinatra verwendet
viele von diesen Komponenten automatisch, abh&auml;ngig von der Konfiguration. So
muss <code>use</code> h&auml;ufig nicht explizit verwendet werden.</p>

<p>Hilfreiche Middleware gibt es z.B. hier:
<a href="https://github.com/rack/rack/tree/master/lib/rack">rack</a>,
<a href="https://github.com/rack/rack-contrib#readme">rack-contrib</a>, mit
<a href="http://coderack.org/">CodeRack</a> oder im <a href="https://github.com/rack/rack/wiki/List-of-Middleware">Rack
wiki</a>.</p>

<a name='Testen'></a>
<h2>Testen</h2>

<p>Sinatra-Tests k&ouml;nnen mit jedem auf Rack aufbauendem Test-Framework geschrieben
werden. <a href="http://rdoc.info/github/brynary/rack-test/master/frames">Rack::Test</a>
wird empfohlen:</p>

<pre><code class="ruby">require 'my_sinatra_app'
require 'test/unit'
require 'rack/test'

class MyAppTest &lt; Test::Unit::TestCase
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_my_default
    get '/'
    assert_equal 'Hallo Welt!', last_response.body
  end

  def test_with_params
    get '/meet', :name =&gt; 'Frank'
    assert_equal 'Hallo Frank!', last_response.body
  end

  def test_with_rack_env
    get '/', {}, 'HTTP_USER_AGENT' =&gt; 'Songbird'
    assert_equal "Du verwendest Songbird!", last_response.body
  end
end
</code></pre>

<p>Hinweis: Wird Sinatra modular verwendet, muss <tt>Sinatra::Application</tt> mit
dem Namen der Applikations-Klasse ersetzt werden.</p>

<p>[[##]] Sinatra::Base - Middleware, Bibliotheken und modulare Anwendungen</p>

<p>Das Definieren einer Top-Level-Anwendung funktioniert gut f&uuml;r
Mikro-Anwendungen, hat aber Nachteile, wenn wiederverwendbare Komponenten wie
Middleware, Rails Metal, einfache Bibliotheken mit Server-Komponenten oder
auch Sinatra-Erweiterungen geschrieben werden sollen.</p>

<p>Das Top-Level geht von einer Konfiguration f&uuml;r eine Mikro-Anwendung aus (wie
sie z.B. bei einer einzelnen Anwendungsdatei, <code>./public</code> und <code>./views</code> Ordner,
Logging, Exception-Detail-Seite, usw.). Genau hier kommt <code>Sinatra::Base</code> ins
Spiel:</p>

<pre><code class="ruby">require 'sinatra/base'

class MyApp &lt; Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Hallo Welt!'
  end
end
</code></pre>

<p>Die MyApp-Klasse ist eine unabh&auml;ngige Rack-Komponente, die als Middleware,
Endpunkt oder via Rails Metal verwendet werden kann. Verwendet wird sie durch
<code>use</code> oder <code>run</code> von einer Rackup-<code>config.ru</code>-Datei oder als Server-Komponente
einer Bibliothek:</p>

<pre><code class="ruby">MyApp.run! :host =&gt; 'localhost', :port =&gt; 9090
</code></pre>

<p>Die Methoden der <code>Sinatra::Base</code>-Subklasse sind genau dieselben wie die der
Top-Level-DSL. Die meisten Top-Level-Anwendungen k&ouml;nnen mit nur zwei
Ver&auml;nderungen zu <code>Sinatra::Base</code> konvertiert werden:</p>

<ul>
<li>  Die Datei sollte <code>require 'sinatra/base'</code> anstelle von <code>require
'sinatra/base'</code> aufrufen, ansonsten werden alle von Sinatras DSL-Methoden
in den Top-Level-Namespace importiert.</li>
<li>  Alle Routen, Error-Handler, Filter und Optionen der Applikation m&uuml;ssen in
einer Subklasse von <code>Sinatra::Base</code> definiert werden.</li>
</ul>
<p><code>Sinatra::Base</code> ist ein unbeschriebenes Blatt. Die meisten Optionen sind per
Standard deaktiviert. Das betrifft auch den eingebauten Server. Siehe
<a href="http://sinatra.github.com/configuration.html">Optionen und Konfiguration</a> f&uuml;r
Details &uuml;ber m&ouml;gliche Optionen.</p>

<a name='Modularer%20vs.%20klassischer%20Stil'></a>
<h3>Modularer vs. klassischer Stil</h3>

<p>Entgegen h&auml;ufiger Meinungen gibt es nichts gegen den klassischen Stil
einzuwenden. Solange es die Applikation nicht beeintr&auml;chtigt, besteht kein
Grund, eine modulare Applikation zu erstellen.</p>

<p>Der gr&ouml;&szlig;te Nachteil der klassischen Sinatra Anwendung gegen&uuml;ber einer
modularen ist die Einschr&auml;nkung auf eine Sinatra Anwendung pro Ruby-Prozess.
Sollen mehrere zum Einsatz kommen, muss auf den modularen Stil umgestiegen
werden. Dabei ist es kein Problem klassische und modulare Anwendungen
miteinander zu vermischen.</p>

<p>Bei einem Umstieg, sollten einige Unterschiede in den Einstellungen beachtet
werden:</p>

<table>
<tr>
<th>Szenario</th>
    <th>Classic</th>
    <th>Modular</th>
  </tr>
<tr>
<td>app_file</td>
    <td>Sinatra ladende Datei</td>
    <td>Sinatra::Base subklassierende Datei</td>
  </tr>
<tr>
<td>run</td>
    <td>$0 == app_file</td>
    <td>false</td>
  </tr>
<tr>
<td>logging</td>
    <td>true</td>
    <td>false</td>
  </tr>
<tr>
<td>method_override</td>
    <td>true</td>
    <td>false</td>
  </tr>
<tr>
<td>inline_templates</td>
    <td>true</td>
    <td>false</td>
  </tr>
<tr>
<td>static</td>
    <td>true</td>
    <td>false</td>
  </tr>
</table>
<a name='Eine%20modulare%20Applikation%20bereitstellen'></a>
<h3>Eine modulare Applikation bereitstellen</h3>

<p>Es gibt zwei &uuml;bliche Wege, eine modulare Anwendung zu starten. Zum einen &uuml;ber
<code>run!</code>:</p>

<pre><code class="ruby"># mein_app.rb
require 'sinatra/base'

class MeinApp &lt; Sinatra::Base
  # ... Anwendungscode hierhin ...

  # starte den Server, wenn die Ruby-Datei direkt ausgef&uuml;hrt wird
  run! if app_file == $0
end
</code></pre>

<p>Starte mit:</p>

<pre><code>ruby mein_app.rb
</code></pre>

<p>Oder &uuml;ber eine <code>config.ru</code>-Datei, die es erlaubt, einen beliebigen
Rack-Handler zu verwenden:</p>

<pre><code class="ruby"># config.ru (mit rackup starten)
require './mein_app'
run MeineApp
</code></pre>

<p>Starte:</p>

<pre><code>rackup -p 4567
</code></pre>

<a name='Eine%20klassische%20Anwendung%20mit%20einer%20config.ru%20verwenden'></a>
<h3>Eine klassische Anwendung mit einer config.ru verwenden</h3>

<p>Schreibe eine Anwendungsdatei:</p>

<pre><code class="ruby"># app.rb
require 'sinatra'

get '/' do
  'Hallo Welt!'
end
</code></pre>

<p>sowie eine dazugeh&ouml;rige <code>config.ru</code>-Datei:</p>

<pre><code class="ruby">require './app'
run Sinatra::Application
</code></pre>

<a name='Wann%20sollte%20eine%20config.ru-Datei%20verwendet%20werden?'></a>
<h3>Wann sollte eine config.ru-Datei verwendet werden?</h3>

<p>Anzeichen daf&uuml;r, dass eine <code>config.ru</code>-Datei gebraucht wird:</p>

<ul>
<li>  Es soll ein anderer Rack-Handler verwendet werden (Passenger, Unicorn,
Heroku, ...).</li>
<li>  Es gibt mehr als nur eine Subklasse von <code>Sinatra::Base</code>.</li>
<li>  Sinatra soll als Middleware verwendet werden, nicht als Endpunkt.</li>
</ul>
<p><strong>Es gibt keinen Grund, eine <code>config.ru</code>-Datei zu verwenden, nur weil eine
Anwendung im modularen Stil betrieben werden soll. Ebenso wird keine Anwendung
mit modularem Stil ben&ouml;tigt, um eine <code>config.ru</code>-Datei zu verwenden.</strong></p>

<a name='Sinatra%20als%20Middleware%20nutzen'></a>
<h3>Sinatra als Middleware nutzen</h3>

<p>Es ist nicht nur m&ouml;glich, andere Rack-Middleware mit Sinatra zu nutzen, es
kann au&szlig;erdem jede Sinatra-Anwendung selbst als Middleware vor jeden
beliebigen Rack-Endpunkt gehangen werden. Bei diesem Endpunkt muss es sich
nicht um eine andere Sinatra-Anwendung handeln, es kann jede andere
Rack-Anwendung sein (Rails/Ramaze/Camping/...):</p>

<pre><code class="ruby">require 'sinatra/base'

class LoginScreen &lt; Sinatra::Base
  enable :sessions

  get('/login') { haml :login }

  post('/login') do
    if params[:name] == 'admin' &amp;&amp; params[:password] == 'admin'
      session['user_name'] = params[:name]
    else
      redirect '/login'
    end
  end
end

class MyApp &lt; Sinatra::Base
  # Middleware wird vor Filtern ausgef&uuml;hrt
  use LoginScreen

  before do
    unless session['user_name']
      halt "Zugriff verweigert, bitte &lt;a href='/login'&gt;einloggen&lt;/a&gt;."
    end
  end

  get('/') { "Hallo #{session['user_name']}." }
end
</code></pre>

<a name='Dynamische%20Applikationserstellung'></a>
<h3>Dynamische Applikationserstellung</h3>

<p>Manche Situationen erfordern die Erstellung neuer Applikationen zur Laufzeit,
ohne dass sie einer Konstanten zugeordnet werden. Dies l&auml;sst sich mit
<code>Sinatra.new</code> erreichen:</p>

<pre><code class="ruby">require 'sinatra/base'
my_app = Sinatra.new { get('/') { "hallo" } }
my_app.run!
</code></pre>

<p>Die Applikation kann mit Hilfe eines optionalen Parameters erstellt werden:</p>

<pre><code class="ruby"># config.ru
require 'sinatra/base'

controller = Sinatra.new do
  enable :logging
  helpers MyHelpers
end

map('/a') do
  run Sinatra.new(controller) { get('/') { 'a' } }
end

map('/b') do
  run Sinatra.new(controller) { get('/') { 'b' } }
end
</code></pre>

<p>Das ist besonders dann interessant, wenn Sinatra-Erweiterungen getestet werden
oder Sinatra in einer Bibliothek Verwendung findet.</p>

<p>Ebenso lassen sich damit hervorragend Sinatra-Middlewares erstellen:</p>

<pre><code class="ruby">require 'sinatra/base'

use Sinatra do
  get('/') { ... }
end

run RailsProject::Application
</code></pre>

<a name='Geltungsbereich%20und%20Bindung'></a>
<h2>Geltungsbereich und Bindung</h2>

<p>Der Geltungsbereich (Scope) legt fest, welche Methoden und Variablen zur
Verf&uuml;gung stehen.</p>

<a name='Anwendungs-%20oder%20Klassen-Scope'></a>
<h3>Anwendungs- oder Klassen-Scope</h3>

<p>Jede Sinatra-Anwendung entspricht einer <code>Sinatra::Base</code>-Subklasse. Falls die
Top- Level-DSL verwendet wird (<code>require 'sinatra'</code>), handelt es sich um
<code>Sinatra::Application</code>, andernfalls ist es jene Subklasse, die explizit
angelegt wurde. Auf Klassenebene stehen Methoden wie <code>get</code> oder <code>before</code> zur
Verf&uuml;gung, es gibt aber keinen Zugriff auf das <code>request</code>-Object oder die
<code>session</code>, da nur eine einzige Klasse f&uuml;r alle eingehenden Anfragen genutzt
wird.</p>

<p>Optionen, die via <code>set</code> gesetzt werden, sind Methoden auf Klassenebene:</p>

<pre><code class="ruby">class MyApp &lt; Sinatra::Base
  # Hey, ich bin im Anwendungsscope!
  set :foo, 42
  foo # =&gt; 42

  get '/foo' do
    # Hey, ich bin nicht mehr im Anwendungs-Scope!
  end
end
</code></pre>

<p>Im Anwendungs-Scope befindet man sich:</p>

<ul>
<li>  In der Anwendungs-Klasse.</li>
<li>  In Methoden, die von Erweiterungen definiert werden.</li>
<li>  Im Block, der an <code>helpers</code> &uuml;bergeben wird.</li>
<li>  In Procs und Bl&ouml;cken, die an <code>set</code> &uuml;bergeben werden.</li>
<li>  Der an <code>Sinatra.new</code> &uuml;bergebene Block</li>
</ul>
<p>Auf das Scope-Objekt (die Klasse) kann wie folgt zugegriffen werden:</p>

<ul>
<li>  &Uuml;ber das Objekt, das an den <code>configure</code>-Block &uuml;bergeben wird (<code>configure {
|c| ... }</code>).</li>
<li>  <code>settings</code> aus den anderen Scopes heraus.</li>
</ul>
<a name='Anfrage-%20oder%20Instanz-Scope'></a>
<h3>Anfrage- oder Instanz-Scope</h3>

<p>F&uuml;r jede eingehende Anfrage wird eine neue Instanz der Anwendungs-Klasse
erstellt und alle Handler in diesem Scope ausgef&uuml;hrt. Aus diesem Scope heraus
kann auf <code>request</code> oder <code>session</code> zugegriffen und Methoden wie <code>erb</code> oder
<code>haml</code> aufgerufen werden. Au&szlig;erdem kann mit der <code>settings</code>-Method auf den
Anwendungs-Scope zugegriffen werden:</p>

<pre><code class="ruby">class MyApp &lt; Sinatra::Base
  # Hey, ich bin im Anwendungs-Scope!
  get '/neue_route/:name' do
    # Anfrage-Scope f&uuml;r '/neue_route/:name'
    @value = 42

    settings.get "/#{params[:name]}" do
      # Anfrage-Scope f&uuml;r "/#{params[:name]}"
      @value # =&gt; nil (nicht dieselbe Anfrage)
    end

    "Route definiert!"
  end
end
</code></pre>

<p>Im Anfrage-Scope befindet man sich:</p>

<ul>
<li>  In get/head/post/put/delete-Bl&ouml;cken</li>
<li>  In before/after-Filtern</li>
<li>  In Helfer-Methoden</li>
<li>  In Templates</li>
</ul>
<a name='Delegation-Scope'></a>
<h3>Delegation-Scope</h3>

<p>Vom Delegation-Scope aus werden Methoden einfach an den Klassen-Scope
weitergeleitet. Dieser verh&auml;lt sich jedoch nicht 100%ig wie der Klassen-Scope,
da man nicht die Bindung der Klasse besitzt: Nur Methoden, die explizit als
delegierbar markiert wurden, stehen hier zur Verf&uuml;gung und es kann nicht auf
die Variablen des Klassenscopes zugegriffen werden (mit anderen Worten: es
gibt ein anderes <code>self</code>). Weitere Delegationen k&ouml;nnen mit
<code>Sinatra::Delegator.delegate :methoden_name</code> hinzugef&uuml;gt werden.</p>

<p>Im Delegation-Scop befindet man sich:</p>

<ul>
<li>  Im Top-Level, wenn <code>require 'sinatra'</code> aufgerufen wurde.</li>
<li>  In einem Objekt, das mit dem <code>Sinatra::Delegator</code>-Mixin erweitert wurde.</li>
</ul>
<p>Schau am besten im Code nach: Hier ist <a href="http://github.com/sinatra/sinatra/blob/master/lib/sinatra/base.rb#L1064">Sinatra::Delegator
mixin</a> definiert und wird in den [globalen Namespace
eingebunden](http://github.com/sinatra/sinatra/blob/master/lib/sinatra/main.rb</p>

<a name='Kommandozeile'></a>
<h2>Kommandozeile</h2>

<p>Sinatra-Anwendungen k&ouml;nnen direkt von der Kommandozeile aus gestartet werden:</p>

<pre><code>ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-h HOST] [-s HANDLER]
</code></pre>

<p>Die Optionen sind:</p>

<pre><code>-h # Hilfe
-p # Port setzen (Standard ist 4567)
-h # Host setzen (Standard ist 0.0.0.0)
-e # Umgebung setzen (Standard ist development)
-s # Rack-Server/Handler setzen (Standard ist thin)
-x # Mutex-Lock einschalten (Standard ist off)
</code></pre>

<a name='Systemanforderungen'></a>
<h2>Systemanforderungen</h2>

<p>Die folgenden Versionen werden offiziell unterst&uuml;tzt:</p>

<dl>
<dt>Ruby 1.8.7</dt>
  <dd>1.8.7 wird vollst&auml;ndig unterst&uuml;tzt, aber solange nichts dagegen spricht,
  wird ein Update auf 1.9.2 oder ein Umstieg auf JRuby/Rubinius empfohlen.
  Unterst&uuml;tzung f&uuml;r 1.8.7 wird es mindestens bis Sinatra 2.0 und Ruby 2.0
  geben, es sei denn, dass der unwahrscheinliche Fall eintritt und 1.8.8
  rauskommt. Doch selbst dann ist es eher wahrscheinlich, dass 1.8.7 weiterhin
  unterst&uuml;tzt wird. <b>Ruby 1.8.6 wird nicht mehr unterst&uuml;tzt.</b> Soll Sinatra
  unter 1.8.6 eingesetzt werden, muss Sinatra 1.2 verwendet werden, dass noch
  bis zum Release von Sinatra 1.4.0 fortgef&uuml;hrt wird.</dd>

  <dt>Ruby 1.9.2</dt>
  <dd>1.9.2 wird voll unterst&uuml;tzt und empfohlen. Version 1.9.2p0 sollte nicht
  verwendet werden, da unter Sinatra immer wieder Segfaults auftreten.
  Unterst&uuml;tzung wird es mindestens bis zum Release von Ruby 1.9.4/2.0 geben und
  das letzte Sinatra Release f&uuml;r 1.9 wird so lange unterst&uuml;tzt, wie das Ruby
  Core-Team 1.9 pflegt.</dd>

  <dt>Ruby 1.9.3</dt>
  <dd>1.9.3 wird vollst&auml;ndig unterst&uuml;tzt und empfohlen. Achtung, bei einem
  Wechsel zu 1.9.3 werden alle Sessions ung&uuml;ltig.</dd>

  <dt>Rubinius</dt>
  <dd>Rubinius (rbx &gt;= 1.2.4) wird offiziell unter Einbezug aller Templates
  unterst&uuml;tzt. Die kommende 2.0 Version wird ebenfalls unterst&uuml;tzt, samt 1.9
  Modus.</dd>

  <dt>JRuby</dt>
  <dd>JRuby wird offiziell unterst&uuml;tzt (JRuby &gt;= 1.6.7). Probleme mit
  Template- Bibliotheken Dritter sind nicht bekannt. Falls JRuby zum Einsatz
  kommt, sollte aber darauf geachtet werden, dass ein JRuby-Rack-Handler zum
  Einsatz kommt &ndash; die Thin und Mongrel Web-Server werden bisher nicht
  unterst&uuml;tz. JRubys Unterst&uuml;tzung f&uuml;r C-Erweiterungen sind zur Zeit ebenfalls
  experimenteller Natur, betrifft im Moment aber nur die RDiscount, Redcarpet,
  RedCloth und [[Yajl]] Templates.</dd>
</dl>
<p>Weiterhin werden wir die kommende Ruby-Versionen im Auge behalten.</p>

<p>Die nachfolgend aufgef&uuml;hrten Ruby-Implementierungen werden offiziell nicht von
Sinatra unterst&uuml;tzt, funktionieren aber normalerweise:</p>

<ul>
<li>  Ruby Enterprise Edition</li>
<li>  &Auml;ltere Versionen von JRuby und Rubinius</li>
<li>  MacRuby, Maglev, IronRuby</li>
<li>  Ruby 1.9.0 und 1.9.1 (wird jedoch nicht empfohlen, s.o.)</li>
</ul>
<p>Nicht offiziell unterst&uuml;tzt bedeutet, dass wenn Sachen nicht funktionieren,
wir davon ausgehen, dass es nicht an Sinatra sondern an der jeweiligen
Implentierung liegt.</p>

<p>Im Rahmen unserer CI (Kontinuierlichen Integration) wird bereits ruby-head
(das kommende Ruby 2.0.0) und 1.9.4 mit eingebunden. Da noch alles im Fluss
ist, kann zur Zeit f&uuml;r nichts garantiert werden. Es kann aber erwartet werden,
dass Ruby 2.0.0p0 und 1.9.4p0 von Sinatra unterst&uuml;tzt werden wird.</p>

<p>Sinatra sollte auf jedem Betriebssystem laufen, dass den gew&auml;hlten Ruby-
Interpreter unterst&uuml;tzt.</p>

<p>Sinatra wird aktuell nicht unter Cardinal, SmallRuby, BleuRuby oder
irgendeiner  Version von Ruby vor 1.8.7 laufen.</p>

<a name='Der%20neuste%20Stand%20(The%20Bleeding%20Edge)'></a>
<h2>Der neuste Stand (The Bleeding Edge)</h2>

<p>Um auf dem neusten Stand zu bleiben, kann der Master-Branch verwendet werden.
Er sollte recht stabil sein. Ebenso gibt es von Zeit zu Zeit prerelease Gems,
die so installiert werden:</p>

<pre><code>gem install sinatra --pre
</code></pre>

<a name='Mit%20Bundler'></a>
<h3>Mit Bundler</h3>

<p>Wenn die Applikation mit der neuesten Version von Sinatra und
<a href="http://gembundler.com/">Bundler</a> genutzt werden soll, empfehlen wir den
nachfolgenden Weg.</p>

<p>Soweit Bundler noch nicht installiert ist:</p>

<pre><code>gem install bundler
</code></pre>

<p>Anschlie&szlig;end wird eine <code>Gemfile</code>-Datei im Projektverzeichnis mit folgendem
Inhalt erstellt:</p>

<pre><code class="ruby">source :rubygems
gem 'sinatra', :git =&gt; "git://github.com/sinatra/sinatra.git"

# evtl. andere Abh&auml;ngigkeiten
gem 'haml'                    # z.B. wenn du Haml verwendest...
gem 'activerecord', '~&gt; 3.0'  # ...oder ActiveRecord 3.x
</code></pre>

<p>Beachte: Hier sollten alle Abh&auml;ngigkeiten eingetragen werden. Sinatras eigene,
direkte Abh&auml;ngigkeiten (Tilt und Rack) werden von Bundler automatisch aus dem
Gemfile von Sinatra hinzugef&uuml;gt.</p>

<p>Jetzt kannst du deine Applikation starten:</p>

<pre><code>bundle exec ruby myapp.rb
</code></pre>

<a name='Eigenes%20Repository'></a>
<h3>Eigenes Repository</h3>

<p>Um auf dem neuesten Stand von Sinatras Code zu sein, kann eine lokale Kopie
angelegt werden. Gestartet wird in der Anwendung mit dem <code>sinatra/lib</code>- Ordner
im <code>LOAD_PATH</code>:</p>

<pre><code>cd myapp
git clone git://github.com/sinatra/sinatra.git
ruby -Isinatra/lib myapp.rb
</code></pre>

<p>Alternativ kann der <code>sinatra/lib</code>-Ordner zum <code>LOAD_PATH</code> in der Anwendung
hinzugef&uuml;gt werden:</p>

<pre><code class="ruby">$LOAD_PATH.unshift File.dirname(__FILE__) + '/sinatra/lib'
require 'rubygems'
require 'sinatra'

get '/ueber' do
  "Ich laufe auf Version " + Sinatra::VERSION
end
</code></pre>

<p>Um Sinatra-Code von Zeit zu Zeit zu aktualisieren:</p>

<pre><code>cd myproject/sinatra
git pull
</code></pre>

<a name='Gem%20erstellen'></a>
<h3>Gem erstellen</h3>

<p>Aus der eigenen lokalen Kopie kann nun auch ein globales Gem gebaut werden:</p>

<pre><code>git clone git://github.com/sinatra/sinatra.git
cd sinatra
rake sinatra.gemspec
rake install
</code></pre>

<p>Falls Gems als Root installiert werden sollen, sollte die letzte Zeile
folgenderma&szlig;en lauten:</p>

<pre><code>sudo rake install
</code></pre>

<a name='Versions-Verfahren'></a>
<h2>Versions-Verfahren</h2>

<p>Sinatra folgt dem sogenannten <a href="http://semver.org/">Semantic Versioning</a>, d.h.
SemVer und SemVerTag.</p>

<a name='Mehr'></a>
<h2>Mehr</h2>

<ul>
<li>  <a href="http://sinatra.github.com/">Projekt-Website</a> - Erg&auml;nzende Dokumentation,
News und Links zu anderen Ressourcen.</li>
<li>  <a href="http://sinatra.github.com/contributing.html">Mitmachen</a> - Einen Fehler
gefunden? Brauchst du Hilfe? Hast du einen Patch?</li>
<li>  <a href="http://github.com/sinatra/sinatra/issues">Issue-Tracker</a>
</li>
<li>  <a href="http://twitter.com/sinatra">Twitter</a>
</li>
<li>  <a href="http://groups.google.com/group/sinatrarb">Mailing-Liste</a>
</li>
<li>  <a href="irc://chat.freenode.net/#sinatra"> #sinatra</a> auf http://freenode.net</li>
<li>  <a href="http://sinatra-book.gittr.com">Sinatra Book</a> Kochbuch Tutorial</li>
<li>  <a href="http://recipes.sinatrarb.com/">Sinatra Recipes</a> Sinatra-Rezepte aus der
Community</li>
<li>  API Dokumentation f&uuml;r die <a href="http://rubydoc.info/gems/sinatra">aktuelle
Version</a> oder f&uuml;r
<a href="http://rubydoc.info/github/sinatra/sinatra">HEAD</a> auf http://rubydoc.info</li>
<li>  <a href="http://travis-ci.org/sinatra/sinatra">CI Server</a>
</li>
</ul>
</body></html>
