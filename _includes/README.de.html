<div class='toc'>
	<ol class='level-1'>
		<li><a href='#Routen'>Routen</a></li>
		<ol class='level-2'>
			<li><a href='#Bedingungen'>Bedingungen</a></li>
			<li><a href='#R%C3%BCckgabewerte'>Rückgabewerte</a></li>
			<li><a href='#Eigene%20Routen-Muster'>Eigene Routen-Muster</a></li>
		</ol>
		<li><a href='#Statische%20Dateien'>Statische Dateien</a></li>
		<li><a href='#Views/Templates'>Views/Templates</a></li>
		<ol class='level-2'>
			<li><a href='#Haml-Templates'>Haml-Templates</a></li>
			<li><a href='#Erb-Templates'>Erb-Templates</a></li>
			<li><a href='#Erubis'>Erubis</a></li>
			<li><a href='#Builder-Templates'>Builder-Templates</a></li>
			<li><a href='#Nokogiri-Templates'>Nokogiri-Templates</a></li>
			<li><a href='#Sass-Templates'>Sass-Templates</a></li>
			<li><a href='#SCSS-Templates'>SCSS-Templates</a></li>
			<li><a href='#Less-Templates'>Less-Templates</a></li>
			<li><a href='#Liquid-Templates'>Liquid-Templates</a></li>
			<li><a href='#Markdown-Templates'>Markdown-Templates</a></li>
			<li><a href='#Textile-Templates'>Textile-Templates</a></li>
			<li><a href='#RDoc-Templates'>RDoc-Templates</a></li>
			<li><a href='#Radius-Templates'>Radius-Templates</a></li>
			<li><a href='#Markaby-Templates'>Markaby-Templates</a></li>
			<li><a href='#Slim-Templates'>Slim-Templates</a></li>
			<li><a href='#CoffeeScript-Templates'>CoffeeScript-Templates</a></li>
			<li><a href='#Inline-Templates'>Inline-Templates</a></li>
			<li><a href='#Auf%20Variablen%20in%20Templates%20zugreifen'>Auf Variablen in Templates zugreifen</a></li>
			<li><a href='#Inline-Templates'>Inline-Templates</a></li>
			<li><a href='#Benannte%20Templates'>Benannte Templates</a></li>
			<li><a href='#Dateiendungen%20zuordnen'>Dateiendungen zuordnen</a></li>
			<li><a href='#Eine%20eigene%20Template-Engine%20hinzuf%C3%BCgen'>Eine eigene Template-Engine hinzufügen</a></li>
		</ol>
		<li><a href='#Filter'>Filter</a></li>
		<li><a href='#Helfer'>Helfer</a></li>
		<ol class='level-2'>
			<li><a href='#Sessions%20verwenden'>Sessions verwenden</a></li>
		</ol>
		<li><a href='#Anhalten'>Anhalten</a></li>
		<li><a href='#Weiterspringen'>Weiterspringen</a></li>
		<ol class='level-2'>
			<li><a href='#Eine%20andere%20Route%20ansteuern'>Eine andere Route ansteuern</a></li>
			<li><a href='#Body,%20Status-Code%20und%20Header%20setzen'>Body, Status-Code und Header setzen</a></li>
		</ol>
		<li><a href='#Mime-Types'>Mime-Types</a></li>
		<ol class='level-2'>
			<li><a href='#URLs%20generieren'>URLs generieren</a></li>
			<li><a href='#Browser-Umleitung'>Browser-Umleitung</a></li>
			<li><a href='#Dateien%20versenden'>Dateien versenden</a></li>
		</ol>
		<li><a href='#Das%20Request-Objekt'>Das Request-Objekt</a></li>
		<ol class='level-2'>
			<li><a href='#Anh%C3%A4nge'>Anhänge</a></li>
			<li><a href='#Nachschlagen%20von%20Template-Dateien'>Nachschlagen von Template-Dateien</a></li>
		</ol>
		<li><a href='#Konfiguration'>Konfiguration</a></li>
		<ol class='level-2'>
			<li><a href='#M%C3%B6gliche%20Einstellungen'>Mögliche Einstellungen</a></li>
		</ol>
		<li><a href='#Fehlerbehandlung'>Fehlerbehandlung</a></li>
		<ol class='level-2'>
			<li><a href='#Nicht%20gefunden'>Nicht gefunden</a></li>
			<li><a href='#Fehler'>Fehler</a></li>
		</ol>
		<li><a href='#Rack-Middleware'>Rack-Middleware</a></li>
		<li><a href='#Testen'>Testen</a></li>
		<li><a href='#Sinatra::Base%20-%20Middleware,%20Bibliotheken%20und%20modulare%20Anwendungen'>Sinatra::Base - Middleware, Bibliotheken und modulare Anwendungen</a></li>
		<ol class='level-2'>
			<li><a href='#Modularer%20vs.%20klassischer%20Stil'>Modularer vs. klassischer Stil</a></li>
			<li><a href='#Eine%20modulare%20Applikation%20bereitstellen'>Eine modulare Applikation bereitstellen</a></li>
			<li><a href='#Eine%20klassische%20Anwendung%20mit%20einer%20config.ru%20verwenden'>Eine klassische Anwendung mit einer config.ru verwenden</a></li>
			<li><a href='#Wann%20sollte%20eine%20config.ru-Datei%20verwendet%20werden?'>Wann sollte eine config.ru-Datei verwendet werden?</a></li>
			<li><a href='#Sinatra%20als%20Middleware%20nutzen'>Sinatra als Middleware nutzen</a></li>
		</ol>
		<li><a href='#Geltungsbereich%20und%20Bindung'>Geltungsbereich und Bindung</a></li>
		<ol class='level-2'>
			<li><a href='#Anwendungs-%20oder%20Klassen-Scope'>Anwendungs- oder Klassen-Scope</a></li>
			<li><a href='#Anfrage-%20oder%20Instanz-Scope'>Anfrage- oder Instanz-Scope</a></li>
			<li><a href='#Delegation-Scope'>Delegation-Scope</a></li>
		</ol>
		<li><a href='#Kommandozeile'>Kommandozeile</a></li>
		<li><a href='#Systemanforderungen'>Systemanforderungen</a></li>
		<li><a href='#Der%20neueste%20Stand%20(The%20Bleeding%20Edge)'>Der neueste Stand (The Bleeding Edge)</a></li>
		<ol class='level-2'>
			<li><a href='#Mit%20Bundler'>Mit Bundler</a></li>
			<li><a href='#Eigenes%20Repository'>Eigenes Repository</a></li>
			<li><a href='#Gem%20erstellen'>Gem erstellen</a></li>
		</ol>
		<li><a href='#Versions-Verfahren'>Versions-Verfahren</a></li>
		<li><a href='#Mehr'>Mehr</a></li>
	</ol>
</div>

<p>
<em>Wichtig: Dieses Dokument ist eine Übersetzung aus dem Englischen und
unter Umständen nicht auf dem aktuellen Stand.</em>
</p>
<p>
Sinatra ist eine DSL, die das schnelle Erstellen von Webanwendungen in Ruby
mit minimalem Aufwand ermöglicht:
</p>
<pre>
  # myapp.rb
  require 'sinatra'
  get '/' do
    'Hallo Welt!'
  end
</pre>
<p>
Einfach via <tt>rubygems</tt> installieren und starten:
</p>
<pre>
  gem install sinatra
  ruby -rubygems myapp.rb
</pre>
<p>
Die Seite kann nun unter <a href="http://localhost:4567">localhost:4567</a>
betrachtet werden.
</p>
<p>
Es wird empfohlen, den Thin-Server via <tt>gem install thin</tt> zu 
installieren, den Sinatra dann, soweit vorhanden, automatisch verwendet.
</p>
<a name='Routen'></a>
<h2>Routen</h2>
<p>
In Sinatra wird eine Route durch eine HTTP-Methode und ein URL-Muster
definiert. Jeder dieser Routen wird ein Ruby-Block zugeordnet:
</p>
<pre>
  get '/' do
    .. zeige etwas ..
  end

  post '/' do
    .. erstelle etwas ..
  end

  put '/' do
    .. update etwas ..
  end

  delete '/' do
    .. entferne etwas ..
  end
  
  options '/' do
    .. lege etwas fest ..
  end
</pre>
<p>
Die Routen werden in der Reihenfolge durchlaufen, in der sie definiert
wurden. Das erste Routen-Muster, das mit dem Request übereinstimmt, wird
ausgeführt.
</p>
<p>
Die Muster der Routen können benannte Parameter beinhalten, die über den
<tt>params</tt>-Hash zugänglich gemacht werden:
</p>
<pre>
  get '/hallo/:name' do
    # passt auf &quot;GET /hallo/foo&quot; und &quot;GET /hallo/bar&quot;
    # params[:name] ist 'foo' oder 'bar'
    &quot;Hallo #{params[:name]}!&quot;
  end
</pre>
<p>
Man kann auf diese auch mit Block-Parametern zugreifen:
</p>
<pre>
  get '/hallo/:name' do |n|
    &quot;Hallo #{n}!&quot;
  end
</pre>
<p>
Routen-Muster können auch mit Splat- oder Wildcard-Parametern über das
<tt>params[:splat]</tt>-Array angesprochen werden:
</p>
<pre>
  get '/sag/*/zu/*' do
    # passt auf /sag/hallo/zu/welt
    params[:splat] # =&gt; [&quot;hallo&quot;, &quot;welt&quot;]
  end

  get '/download/*.*' do
    # passt auf /download/pfad/zu/datei.xml
    params[:splat] # =&gt; [&quot;pfad/zu/datei&quot;, &quot;xml&quot;]
  end
</pre>
<p>
Routen mit regulären Ausdrücken sind auch möglich:
</p>
<pre>
  get %r{/hallo/([\w]+)} do
    &quot;Hallo, #{params[:captures].first}!&quot;
  end
</pre>
<p>
Und auch hier können Block-Parameter genutzt werden:
</p>
<pre>
  get %r{/hallo/([\w]+)} do |c|
    &quot;Hallo, #{c}!&quot;
  end
</pre>
<a name='Bedingungen'></a>
<h3>Bedingungen</h3>
<p>
An Routen können eine Vielzahl von Bedingungen angehängt werden, die
erfüllt sein müssen, damit der Block ausgeführt wird. Möglich wäre etwa
eine Einschränkung des User-Agents:
</p>
<pre>
  get '/foo', :agent =&gt; /Songbird (\d\.\d)[\d\/]*?/ do
    &quot;Du verwendest Songbird Version #{params[:agent][0]}&quot;
  end

  get '/foo' do
    # passt auf andere Browser
  end
</pre>
<p>
Andere mitgelieferte Bedingungen sind <tt>host_name</tt> und
<tt>provides</tt>:
</p>
<pre>
  get '/', :host_name =&gt; /^admin\./ do
    &quot;Adminbereich, Zugriff verweigert!&quot;
  end

  get '/', :provides =&gt; 'html' do
    haml :index
  end

  get '/', :provides =&gt; ['rss', 'atom', 'xml'] do
    builder :feed
  end
</pre>
<p>
Es können auch andere Bedingungen relativ einfach hinzugefügt werden:
</p>
<pre>
  set(:probability) { |value| condition { rand &lt;= value } }

  get '/auto_gewinnen', :probability =&gt; 0.1 do
    &quot;Du hast gewonnen!&quot;
  end

  get '/auto_gewinnen' do
    &quot;Tut mir leid, verloren.&quot;
  end
</pre>
<a name='R%C3%BCckgabewerte'></a>
<h3>Rückgabewerte</h3>
<p>
Durch den Rückgabewert eines Routen-Blocks wird mindestens der
Response-Body festgelegt, der an den HTTP-Client, bzw. die nächste
Rack-Middleware, weitergegeben wird. Im Normalfall handelt es sich hierbei,
wie in den  vorangehenden Beispielen zu sehen war, um einen String. Es
werden allerdings  auch andere Werte akzeptiert.
</p>
<p>
Es kann jedes gültige Objekt zurückgegeben werden, bei dem es sich entweder
um einen Rack-Rückgabewert, einen Rack-Body oder einen HTTP-Status-Code
handelt:
</p>
<ul>
<li><p>
Ein Array mit drei Elementen: <tt>[Status (Fixnum), Headers (Hash), 
Response-Body (antwortet auf #each)]</tt>.
</p>
</li>
<li><p>
Ein Array mit zwei Elementen: <tt>[Status (Fixnum), Response-Body
(antwortet auf #each)]</tt>.
</p>
</li>
<li><p>
Ein Objekt, das auf <tt>#each</tt> antwortet und den an diese Methode 
übergebenen Block nur mit Strings als Übergabewerte aufruft.
</p>
</li>
<li><p>
Ein Fixnum, das den Status-Code festlegt.
</p>
</li>
</ul>
<p>
Damit lässt sich relativ einfach Streaming implementieren:
</p>
<pre>
    class Stream
      def each
        100.times { |i| yield &quot;#{i}\n&quot; }
      end
    end

    get('/') { Stream.new }
</pre>
<a name='Eigene%20Routen-Muster'></a>
<h3>Eigene Routen-Muster </h3>
<p>
Wie oben schon beschrieben, ist Sinatra von Haus aus mit Unterstützung für 
String-Muster und Reguläre Ausdrücke zum Abgleichen von Routen
ausgestattet. Das muss aber noch nicht alles sein, es können ohne großen
Aufwand eigene Routen-Muster erstellt werden:
</p>
<pre>
  class AllButPattern
    Match = Struct.new(:captures)

    def initialize(except)
      @except   = except
      @captures = Match.new([])
    end

    def match(str)
      @captures unless @except === str
    end
  end

  def all_but(pattern)
    AllButPattern.new(pattern)
  end

  get all_but(&quot;/index&quot;) do
    # ...
  end
</pre>
<p>
Beachte, dass das obige Beispiel etwas übertrieben wirkt. Es geht auch 
einfacher:
</p>
<pre>
  get // do
    pass if request.path_info == &quot;/index&quot;
    # ...
  end
</pre>
<p>
Oder unter Verwendung eines negativen look ahead:
</p>
<pre>
  get %r{^(?!/index$)} do
    # ...
  end
</pre>
<a name='Statische%20Dateien'></a>
<h2>Statische Dateien</h2>
<p>
Statische Dateien werden aus dem <tt>./public</tt>-Ordner ausgeliefert. Es
ist möglich, einen anderen Ort zu definieren, indem man die
<tt>:public</tt>-Option setzt:
</p>
<pre>
  set :public, File.dirname(__FILE__) + '/static'
</pre>
<p>
Zu beachten ist, dass der Ordnername public nicht Teil der URL ist. Die
Datei <tt>./public/css/style.css</tt> ist unter <tt><a
href="http://example.com/css/style.css">example.com/css/style.css</a></tt>
zu finden.
</p>
<a name='Views/Templates'></a>
<h2>Views/Templates</h2>
<p>
Standardmäßig wird davon ausgegangen, dass sich Templates im
<tt>./views</tt>-Ordner befinden. Es kann jedoch ein anderer Ordner
festgelegt werden:
</p>
<pre>
  set :views, File.dirname(__FILE__) + '/templates'
</pre>
<p>
Eine wichtige Sache, die man sich hierbei merken sollte, ist, dass man
immer  mit Symbols auf Templates verweisen sollte, auch wenn sich ein
Template in  einem Unterordner befindet (in diesen Fall
<tt>:'subdir/template'</tt>). Rendering-Methoden rendern jeden String
direkt.
</p>
<a name='Haml-Templates'></a>
<h3>Haml-Templates</h3>
<p>
Das <tt>haml</tt>-Gem wird benötigt, um Haml-Templates rendern zu können:
</p>
<pre>
  # haml muss eingebunden werden
  require 'haml'

  get '/' do
    haml :index
  end
</pre>
<p>
Dieser Code rendert <tt>./views/index.haml</tt>.
</p>
<p>
<a
href="http://haml-lang.com/docs/yardoc/file.HAML_REFERENCE.html#options">Haml-Optionen</a>
können global durch die Sinatra-Konfiguration gesetzt werden, siehe <a
href="http://www.sinatrarb.com/configuration.html">Optionen und
Konfiguration</a>, und individuell überschrieben werden.
</p>
<pre>
  set :haml, :format =&gt; :html5 # Standard-Haml-Format ist :xhtml

  get '/' do
    haml :index, :format =&gt; :html4 # überschrieben
  end
</pre>
<a name='Erb-Templates'></a>
<h3>Erb-Templates</h3>
<pre>
  # erb muss eingebunden werden
  require 'erb'

  get '/' do
    erb :index
  end
</pre>
<p>
Dieser Code rendert <tt>./views/index.erb</tt>.
</p>
<a name='Erubis'></a>
<h3>Erubis</h3>
<p>
Das <tt>erubis</tt>-Gem wird benötigt, um Erubis-Templates rendern zu
können:
</p>
<pre>
  # erbubis muss eingebunden werden
  require 'erubis'

  get '/' do
    erubis :index
  end
</pre>
<p>
Dieser Code rendert <tt>./views/index.erubis</tt>.
</p>
<p>
Es ist auch möglich, Erb durch Erubis zu ersetzen:
</p>
<pre>
  require 'erubis'
  Tilt.register :erb, Tilt[:erubis]
  
  get '/' do
    erb :index
  end
</pre>
<p>
Dieser Code rendert ebenfalls <tt>./views/index.erb</tt>.
</p>
<a name='Builder-Templates'></a>
<h3>Builder-Templates</h3>
<p>
Das <tt>builder</tt>-Gem wird benötigt, um Builder-Templates rendern zu
können:
</p>
<pre>
  # builder muss eingebunden werden
  require 'builder'

  get '/' do
    builder :index
  end
</pre>
<p>
Dieser Code rendert <tt>./views/index.builder</tt>.
</p>
<a name='Nokogiri-Templates'></a>
<h3>Nokogiri-Templates</h3>
<p>
Das <tt>nokogiri</tt>-Gem wird benötigt, um Nokogiri-Templates rendern zu
können:
</p>
<pre>
  # nokogiri muss eingebunden werden
  require 'nokogiri'

  get '/' do
    nokogiri :index
  end
</pre>
<p>
Dieser Code rendert <tt>./views/index.nokogiri</tt>.
</p>
<a name='Sass-Templates'></a>
<h3>Sass-Templates</h3>
<p>
Das <tt>haml</tt>- oder <tt>sass</tt>-Gem wird benötigt, um Sass-Templates
rendern zu können:
</p>
<pre>
  # sass muss eingebunden werden
  require 'sass'

  get '/stylesheet.css' do
    sass :stylesheet
  end
</pre>
<p>
Dieser Code rendert <tt>./views/stylesheet.sass</tt>.
</p>
<p>
<a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Sass-Optionen</a>
können global durch die Sinatra-Konfiguration gesetzt werden, siehe  <a
href="http://www.sinatrarb.com/configuration.html">Optionen und
Konfiguration</a>, und individuell überschrieben werden.
</p>
<pre>
  set :sass, :style =&gt; :compact # Standard Sass-Style ist :nested

  get '/stylesheet.css' do
    sass :stylesheet, :style =&gt; :expanded # überschrieben
  end
</pre>
<a name='SCSS-Templates'></a>
<h3>SCSS-Templates</h3>
<p>
Das <tt>haml</tt>- oder <tt>sass</tt>-Gem wird benötigt, um SCSS-Templates
rendern zu können:
</p>
<pre>
  # sass muss eingebunden werden
  require 'sass'

  get '/stylesheet.css' do
    scss :stylesheet
  end
</pre>
<p>
Dieser Code rendert <tt>./views/stylesheet.scss</tt>.
</p>
<p>
<a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">SCSS-Optionen</a>
können global durch die Sinatra-Konfiguration gesetzt werden, siehe  <a
href="http://www.sinatrarb.com/configuration.html">Optionen und
Konfiguration</a>, und individuell überschrieben werden.
</p>
<pre>
  set :scss, :style =&gt; :compact # Standard-SCSS-Style ist :nested

  get '/stylesheet.css' do
    scss :stylesheet, :style =&gt; :expanded # überschrieben
  end
</pre>
<a name='Less-Templates'></a>
<h3>Less-Templates</h3>
<p>
Das <tt>less</tt>-Gem wird benötigt, um Less-Templates rendern zu können:
</p>
<pre>
  # less muss eingebunden werden
  require 'less'

  get '/stylesheet.css' do
    less :stylesheet
  end
</pre>
<p>
Dieser Code rendert <tt>./views/stylesheet.less</tt>.
</p>
<a name='Liquid-Templates'></a>
<h3>Liquid-Templates</h3>
<p>
Das <tt>liquid</tt>-Gem wird benötigt, um Liquid-Templates rendern zu
können:
</p>
<pre>
  # liquid muss eingebunden werden
  require 'liquid'

  get '/' do
    liquid :index
  end
</pre>
<p>
Dieser Code rendert <tt>./views/index.liquid</tt>.
</p>
<p>
Da aus Liquid-Templates heraus keine Methoden (abgesehen von
<tt>yield</tt>)  aufgerufen werden können, ist es möglich, <tt>locals</tt>
zu übergeben:
</p>
<pre>
  liquid :index, :locals =&gt; { :key =&gt; 'value' }
</pre>
<a name='Markdown-Templates'></a>
<h3>Markdown-Templates</h3>
<p>
Das <tt>rdiscount</tt>-Gem wird benötigt, um Markdown-Templates rendern zu
können:
</p>
<pre>
  # rdiscount muss eingebunden werden
  require &quot;rdiscount&quot;

  get '/' do
    markdown :index
  end
</pre>
<p>
Dieser Code rendert <tt>./views/index.markdown</tt> (<tt>md</tt> und
<tt>mkd</tt> sind ebenfalls zulässige Dateiendungen).
</p>
<p>
Da es weder möglich ist, Methoden aufzurufen, noch <tt>locals</tt> zu
übergeben, ist es am sinnvollsten, Markdown in Kombination mit einer
anderen Template-Engine zu nutzen:
</p>
<pre>
  erb :overview, :locals =&gt; { :text =&gt; markdown(:introduction) }
</pre>
<p>
Es ist auch möglich, die <tt>markdown</tt>-Methode aus anderen Templates
heraus aufzurufen:
</p>
<pre>
  %h1 Hallo von Haml!
  %p= markdown(:greetings)
</pre>
<p>
Da man Ruby aus Markdown heraus nicht aufrufen kann, ist es nicht möglich, 
Layouts zu verwenden, die in Markdown geschrieben sind. Es ist aber
möglich,  einen anderen Renderer für das Template zu verwenden als für das
Layout, indem man die <tt>:layout_engine</tt>-Option angibt:
</p>
<pre>
  get '/' do
    markdown :index, :layout_engine =&gt; :erb
  end
</pre>
<p>
Das wird <tt>./views/index.md</tt> mit <tt>./views/layout.erb</tt> als
Layout rendern.
</p>
<p>
Denk daran, dass solche Einstellungen auch global gesetzt werden können:
</p>
<pre>
  set :markdown, :layout_engine =&gt; :haml, :layout =&gt; :post

  get '/' do
    markdown :index
  end
</pre>
<p>
Das wird <tt>./views/index.md</tt> (und jedes andere Markdown-Template) mit
<tt>./views/post.haml</tt> als Layout rendern.
</p>
<p>
Ebenso ist es möglich, Markdown mit BlueCloth anstelle von RDiscount zu
parsen:
</p>
<pre>
  require 'bluecloth'
  
  Tilt.register 'markdown', BlueClothTemplate
  Tilt.register 'mkd',      BlueClothTemplate
  Tilt.register 'md',       BlueClothTemplate
  
  get '/' do
    markdown :index
  end
</pre>
<p>
Das sollte <tt>./views/index.md</tt> mit BlueCloth rendern.
</p>
<a name='Textile-Templates'></a>
<h3>Textile-Templates</h3>
<p>
Das <tt>redcloth</tt>-Gem wird benötigt, um Textile-Templates rendern zu
können:
</p>
<pre>
  # redcloth muss eingebunden werden
  require &quot;redcloth&quot;

  get '/' do
    textile :index
  end
</pre>
<p>
Dieser Code rendert <tt>./views/index.textile</tt>.
</p>
<p>
Da es weder möglich ist, Methoden aufzurufen, noch <tt>locals</tt> zu
übergeben, ist es sinnvoll, Textile in Kombination mit einer anderen
Template-Engine zu  nutzen:
</p>
<pre>
  erb :overview, :locals =&gt; { :text =&gt; textile(:introduction) }
</pre>
<p>
Es ist auch möglich, die <tt>textile</tt>-Methode aus anderen Templates
heraus aufzurufen:
</p>
<pre>
  %h1 Hallo von Haml!
  %p= textile(:greetings)
</pre>
<p>
Da man Ruby aus Textile heraus nicht aufrufen kann, ist es nicht möglich, 
Layouts zu verwenden, die in Textile geschrieben sind. Es ist aber möglich,
einen anderen Renderer für das Template zu verwenden als für das Layout,
indem man die <tt>:layout_engine</tt>-Option angibt:
</p>
<pre>
  get '/' do
    textile :index, :layout_engine =&gt; :erb
  end
</pre>
<p>
Das wird <tt>./views/index.textile</tt> mit <tt>./views/layout.erb</tt> als
Layout rendern.
</p>
<p>
Denk daran, dass solche Einstellungen auch global gesetzt werden können:
</p>
<pre>
  set :textile, :layout_engine =&gt; :haml, :layout =&gt; :post

  get '/' do
    textile :index
  end
</pre>
<p>
Das wird <tt>./views/index.textile</tt> (und jedes andere
Markdown-Template) mit <tt>./views/post.haml</tt> als Layout rendern.
</p>
<a name='RDoc-Templates'></a>
<h3>RDoc-Templates</h3>
<p>
Das <tt>rdoc</tt>-Gem wird benötigt, um RDoc-Templates rendern zu können:
</p>
<pre>
  # rdoc/markup/to_html muss eingebunden werden
  require &quot;rdoc/markup/to_html&quot;

  get '/' do
    rdoc :index
  end
</pre>
<p>
Dieser Code rendert <tt>./views/index.rdoc</tt>.
</p>
<p>
Da es weder möglich ist, Methoden aufzurufen, noch <tt>locals</tt> zu
übergeben, ist es sinnvoll, RDoc in Kombination mit einer anderen
Template-Engine zu nutzen:
</p>
<pre>
  erb :overview, :locals =&gt; { :text =&gt; rdoc(:introduction) }
</pre>
<p>
Es ist auch möglich, die <tt>rdoc</tt>-Methode aus anderen Templates heraus
aufzurufen:
</p>
<pre>
  %h1 Hallo von Haml!
  %p= rdoc(:greetings)
</pre>
<p>
Da man Ruby aus RDoc heraus nicht aufrufen kann, ist es nicht möglich,
Layouts zu verwenden, die in RDoc geschrieben sind. Es ist aber möglich,
einen anderen Renderer für das Template zu verwenden als für das Layout,
indem man die  <tt>:layout_engine</tt> option angibt:
</p>
<pre>
  get '/' do
    rdoc :index, :layout_engine =&gt; :erb
  end
</pre>
<p>
Das wird <tt>./views/index.rdoc</tt> mit <tt>./views/layout.erb</tt> als
Layout rendern.
</p>
<p>
Denk daran, dass solche Einstellungen auch global gesetzt werden können:
</p>
<pre>
  set :rdoc, :layout_engine =&gt; :haml, :layout =&gt; :post

  get '/' do
    rdoc :index
  end
</pre>
<p>
Das wird <tt>./views/index.rdoc</tt> (und jedes andere Markdown-Template)
mit <tt>./views/post.haml</tt> als Layout rendern.
</p>
<a name='Radius-Templates'></a>
<h3>Radius-Templates</h3>
<p>
Das <tt>radius</tt>-Gem wird benötigt, um Radius-Templates rendern zu
können:
</p>
<pre>
  # radius muss eingebunden werden
  require 'radius'

  get '/' do
    radius :index
  end
</pre>
<p>
Dieser Code rendert <tt>./views/index.radius</tt>.
</p>
<p>
Da aus Radius-Templates heraus keine Methoden (abgesehen von
<tt>yield</tt>)  aufgerufen werden können, es es möglich, <tt>locals</tt>
zu übergeben:
</p>
<pre>
  radius :index, :locals =&gt; { :key =&gt; 'value' }
</pre>
<a name='Markaby-Templates'></a>
<h3>Markaby-Templates</h3>
<p>
Das <tt>markaby</tt>-Gem wird benötigt, um Markaby-Templates rendern zu
können:
</p>
<pre>
  # markaby muss eingebunden werden
  require 'markaby'

  get '/' do
    markaby :index
  end
</pre>
<p>
Dieser Code rendert <tt>./views/index.mab</tt>.
</p>
<a name='Slim-Templates'></a>
<h3>Slim-Templates</h3>
<p>
Das <tt>slim</tt>-Gem wird benötigt, um Slim-Templates rendern zu können:
</p>
<pre>
  # slim muss eingebunden werden
  require 'slim'

  get '/' do
    slim :index
  end
</pre>
<p>
Dieser Code rendert <tt>./views/index.slim</tt>.
</p>
<a name='CoffeeScript-Templates'></a>
<h3>CoffeeScript-Templates</h3>
<p>
Das <tt>coffee-script</tt>-Gem und mindestens eine der folgenden Optionen 
werden benötigt, um JavaScript auf dem Server ausführen zu können:
</p>
<ul>
<li><p>
<tt>node</tt> (von Node.js) befindet sich im Pfad
</p>
</li>
<li><p>
du bist unter OS X
</p>
</li>
<li><p>
<tt>therubyracer</tt> gem/library
</p>
</li>
</ul>
<p>
Siehe auch <a
href="http://github.com/josh/ruby-coffee-script">github.com/josh/ruby-coffee-script</a>
für eine vollständige Liste aller Optionen.
</p>
<p>
Nun können CoffeeScript-Templates in der Applikation gerendert werden:
</p>
<pre>
  # coffee-script muss eingebunden werden
  require 'coffee-script'

  get '/application.js' do
    coffee :application
  end
</pre>
<p>
Dieser Code rendert <tt>./views/application.coffee</tt>.
</p>
<a name='Inline-Templates'></a>
<h3>Inline-Templates</h3>
<pre>
  get '/' do
    haml '%div.title Hallo Welt'
  end
</pre>
<p>
Rendert den Inline-Template-String.
</p>
<a name='Auf%20Variablen%20in%20Templates%20zugreifen'></a>
<h3>Auf Variablen in Templates zugreifen</h3>
<p>
Templates werden in demselben Kontext ausgeführt wie Routen.
Instanzvariablen  in Routen sind auch direkt im Template verfügbar:
</p>
<pre>
  get '/:id' do
    @foo = Foo.find(params[:id])
    haml '%h1= @foo.name'
  end
</pre>
<p>
Oder durch einen expliziten Hash von lokalen Variablen:
</p>
<pre>
  get '/:id' do
    foo = Foo.find(params[:id])
    haml '%h1= foo.name', :locals =&gt; { :foo =&gt; foo }
  end
</pre>
<p>
Dies wird typischerweise bei Verwendung von Subtemplates (partials) in
anderen Templates eingesetzt.
</p>
<a name='Inline-Templates'></a>
<h3>Inline-Templates</h3>
<p>
Templates können auch am Ende der Datei definiert werden:
</p>
<pre>
  require 'sinatra'

  get '/' do
    haml :index
  end

  __END__

  @@ layout
  %html
    = yield

  @@ index
  %div.title Hallo Welt!!!!!
</pre>
<p>
Anmerkung: Inline-Templates, die in der Datei definiert sind, die
<tt>require 'sinatra'</tt> aufruft, werden automatisch geladen. Um andere
Inline-Templates in anderen Dateien aufzurufen, muss explizit <tt>enable
:inline_templates</tt>  verwendet werden.
</p>
<a name='Benannte%20Templates'></a>
<h3>Benannte Templates</h3>
<p>
Templates können auch mit der Top-Level <tt>template</tt>-Methode definiert
werden:
</p>
<pre>
  template :layout do
    &quot;%html\n  =yield\n&quot;
  end

  template :index do
    '%div.title Hallo Welt!'
  end

  get '/' do
    haml :index
  end
</pre>
<p>
Wenn ein Template mit dem Namen &#8220;layout&#8221; existiert, wird es bei
jedem Aufruf verwendet. Durch <tt>:layout =&gt; false</tt> kann das
Ausführen verhindert  werden:
</p>
<pre>
  get '/' do
    haml :index, :layout =&gt; !request.xhr?
  end
</pre>
<a name='Dateiendungen%20zuordnen'></a>
<h3>Dateiendungen zuordnen</h3>
<p>
Um eine Dateiendung einer Template-Engine zuzuordnen, kann 
<tt>Tilt.register</tt> genutzt werden. Wenn etwa die Dateiendung
<tt>tt</tt> für  Textile-Templates genutzt werden soll, lässt sich dies wie
folgt  bewerkstelligen:
</p>
<pre>
  Tilt.register :tt, Tilt[:textile]
</pre>
<a name='Eine%20eigene%20Template-Engine%20hinzuf%C3%BCgen'></a>
<h3>Eine eigene Template-Engine hinzufügen</h3>
<p>
Zu allererst muss die Engine bei Tilt registriert und danach eine 
Rendering-Methode erstellt werden:
</p>
<pre>
  Tilt.register :mtt, MeineTolleTemplateEngine

  helpers do
    def mtt(*args) render(:mtt, *args) end
  end

  get '/' do
    mtt :index
  end
</pre>
<p>
Dieser Code rendert <tt>./views/application.mtt</tt>. Siehe <a
href="https://github.com/rtomayko/tilt">github.com/rtomayko/tilt</a>, um
mehr über Tilt  zu lernen.
</p>
<a name='Filter'></a>
<h2>Filter</h2>
<p>
Before-Filter werden vor jedem Request in demselben Kontext, wie danach die
Routen, ausgeführt. So können etwa Request und Antwort geändert werden.
Gesetzte Instanzvariablen in Filtern können in Routen und Templates
verwendet werden:
</p>
<pre>
  before do
    @note = 'Hi!'
    request.path_info = '/foo/bar/baz'
  end

  get '/foo/*' do
    @note #=&gt; 'Hi!'
    params[:splat] #=&gt; 'bar/baz'
  end
</pre>
<p>
After-Filter werden nach jedem Request in demselben Kontext ausgeführt und
können ebenfalls Request und Antwort ändern. In Before-Filtern gesetzte
Instanzvariablen können in After-Filtern verwendet werden:
</p>
<pre>
  after do
    puts response.status
  end
</pre>
<p>
Filter können optional auch mit einem Muster ausgestattet werden, welches
auf den Request-Pfad passen muss, damit der Filter ausgeführt wird:
</p>
<pre>
  before '/protected/*' do
    authenticate!
  end

  after '/create/:slug' do |slug|
    session[:last_slug] = slug
  end
</pre>
<p>
Ähnlich wie Routen können Filter auch mit weiteren Bedingungen
eingeschränkt werden:
</p>
<pre>
  before :agent =&gt; /Songbird/ do
    # ...
  end
  
  after '/blog/*', :host_name =&gt; 'example.com' do
    # ...
  end
</pre>
<a name='Helfer'></a>
<h2>Helfer</h2>
<p>
Durch die Top-Level <tt>helpers</tt>-Methode werden sogenannte
Helfer-Methoden definiert, die in Routen und Templates verwendet werden
können:
</p>
<pre>
  helpers do
    def bar(name)
      &quot;#{name}bar&quot;
    end
  end

  get '/:name' do
    bar(params[:name])
  end
</pre>
<a name='Sessions%20verwenden'></a>
<h3>Sessions verwenden</h3>
<p>
Sessions werden verwendet, um Zustände zwischen den Requests zu speichern.
Sind sie aktiviert, kann ein Session-Hash je Benutzer-Session verwendet
werden.
</p>
<pre>
  enable :sessions

  get '/' do
    &quot;value = &quot; &lt;&lt; session[:value].inspect
  end

  get '/:value' do
    session[:value] = params[:value]
  end
</pre>
<p>
Beachte, dass <tt>enable :sessions</tt> alle Daten in einem Cookie
speichert. Unter Umständen kann dies negative Effekte haben, z.B.
verursachen viele Daten höheren, teilweise überflüssigen Traffic. Um das zu
vermeiden, kann eine Rack- Session-Middleware verwendet werden. Dabei wird
auf <tt>enable :sessions</tt> verzichtet und die Middleware wie üblich im
Programm eingebunden:
</p>
<pre>
  use Rack::Session::Pool, :expire_after =&gt; 2592000

  get '/' do
    &quot;value = &quot; &lt;&lt; session[:value].inspect
  end

  get '/:value' do
    session[:value] = params[:value]
  end
</pre>
<p>
Um die Sicherheit zu erhöhen, werden Cookies, die Session-Daten führen, mit
einem sogenannten Session-Secret signiert. Da sich dieses Geheimwort bei
jedem Neustart der Applikation automatisch ändert, ist es sinnvoll, ein
eigenes zu wählen, damit sich alle Instanzen der Applikation dasselbe
Session-Secret teilen:
</p>
<pre>
  set :session_secret, 'super secret'
</pre>
<a name='Anhalten'></a>
<h2>Anhalten</h2>
<p>
Zum sofortigen Stoppen eines Request in einem Filter oder einer Route:
</p>
<pre>
  halt
</pre>
<p>
Der Status kann beim Stoppen auch angegeben werden:
</p>
<pre>
  halt 410
</pre>
<p>
Oder auch den Response-Body:
</p>
<pre>
  halt 'Hier steht der Body'
</pre>
<p>
Oder beides:
</p>
<pre>
  halt 401, 'verschwinde!'
</pre>
<p>
Sogar mit Headern:
</p>
<pre>
  halt 402, {'Content-Type' =&gt; 'text/plain'}, 'Rache'
</pre>
<p>
Natürlich ist es auch möglich, ein Template mit <tt>halt</tt> zu verwenden:
</p>
<pre>
  halt erb(:error)
</pre>
<a name='Weiterspringen'></a>
<h2>Weiterspringen</h2>
<p>
Eine Route kann mittels <tt>pass</tt> zu der nächsten passenden Route
springen:
</p>
<pre>
  get '/raten/:wer' do
    pass unless params[:wer] == 'Frank'
    'Du hast mich!'
  end

  get '/raten/*' do
    'Du hast mich nicht!'
  end
</pre>
<p>
Der Block wird sofort verlassen und es wird nach der nächsten treffenden
Route gesucht. Ein 404-Fehler wird zurückgegeben, wenn kein treffendes
Routen-Muster gefunden wird.
</p>
<a name='Eine%20andere%20Route%20ansteuern'></a>
<h3>Eine andere Route ansteuern</h3>
<p>
Manchmal entspricht <tt>pass</tt> nicht den Anforderungen, wenn das
Ergebnis einer anderen Route gefordert wird. Um das zu erreichen, lässt
sich <tt>call</tt> nutzen:
</p>
<pre>
  get '/foo' do
    status, headers, body = call env.merge(&quot;PATH_INFO&quot; =&gt; '/bar')
    [status, headers, body.map(&amp;:upcase)]
  end

  get '/bar' do
    &quot;bar&quot;
  end
</pre>
<p>
Beachte, dass in dem oben angegeben Beispiel die Performance erheblich
erhöht werden kann, wenn <tt>&quot;bar&quot;</tt> in eine Helfer-Methode
umgewandelt wird, auf  die <tt>/foo</tt> und <tt>/bar</tt> zugreifen
können.
</p>
<p>
Wenn der Request innerhalb derselben Applikations-Instanz aufgerufen und
keine Kopie der Instanz erzeugt werden soll, kann <tt>call!</tt> anstelle
von <tt>call</tt> verwendet werden.
</p>
<p>
Die Rack-Spezifikationen enthalten weitere Informationen zu <tt>call</tt>.
</p>
<a name='Body,%20Status-Code%20und%20Header%20setzen'></a>
<h3>Body, Status-Code und Header setzen</h3>
<p>
Es ist möglich und empfohlen, den Status-Code sowie den Response-Body mit
einem Returnwert in der Route zu setzen. In manchen Situationen kann es
jedoch sein, dass der Body an irgendeiner anderen Stelle während der
Ausführung gesetzt wird. Das lässt sich mit der Helfer-Methode
<tt>body</tt> bewerkstelligen. Wird <tt>body</tt> verwendet, lässt sich der
Body jederzeit über diese Methode aufrufen:
</p>
<pre>
  get '/foo' do
    body &quot;bar&quot;
  end
  
  after do
    puts body
  end
</pre>
<p>
Ebenso ist es möglich, einen Block an <tt>body</tt> weiterzureichen, der
dann vom Rack-Handler ausgeführt wird (lässt sich z.B. zur Umsetzung von
Streaming  einsetzen, siehe auch &#8220;Rückgabewerte&#8221;).
</p>
<p>
Vergleichbar mit <tt>body</tt> lassen sich auch Status-Code und Header
setzen:
</p>
<pre>
  get '/foo' do
    status 418
    headers \
      &quot;Allow&quot;   =&gt; &quot;BREW, POST, GET, PROPFIND, WHEN&quot;
      &quot;Refresh&quot; =&gt; &quot;Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt&quot;
    halt &quot;Ich bin ein Teekesselchen&quot;
  end
</pre>
<p>
Genau wie bei <tt>body</tt> liest ein Aufrufen von <tt>headers</tt> oder
<tt>status</tt> ohne Argumente den aktuellen Wert aus.
</p>
<a name='Mime-Types'></a>
<h2>Mime-Types</h2>
<p>
Wenn <tt>send_file</tt> oder statische Dateien verwendet werden, kann es
vorkommen, dass Sinatra den Mime-Typ nicht kennt. Registriert wird dieser
mit <tt>mime_type</tt> per Dateiendung:
</p>
<pre>
  mime_type :foo, 'text/foo'
</pre>
<p>
Es kann aber auch der <tt>content_type</tt>-Helfer verwendet werden:
</p>
<pre>
  get '/' do
    content_type :foo
    &quot;foo foo foo&quot;
  end
</pre>
<a name='URLs%20generieren'></a>
<h3>URLs generieren</h3>
<p>
Zum Generieren von URLs sollte die <tt>url</tt>-Helfer-Methode genutzen
werden, so  z.B. beim Einsatz von Haml:
</p>
<pre>
  %a{:href =&gt; url('/foo')} foo
</pre>
<p>
Soweit vorhanden, wird Rücksicht auf Proxys und Rack-Router genommen.
</p>
<p>
Diese Methode ist ebenso über das Alias <tt>to</tt> zu erreichen (siehe
Beispiel unten).
</p>
<a name='Browser-Umleitung'></a>
<h3>Browser-Umleitung</h3>
<p>
Eine Browser-Umleitung kann mithilfe der <tt>redirect</tt>-Helfer-Methode
erreicht werden:
</p>
<pre>
  get '/foo' do
    redirect to('/bar')
  end
</pre>
<p>
Weitere Parameter werden wie Argumente der <tt>halt</tt>-Methode behandelt:
</p>
<pre>
  redirect to('/bar'), 303
  redirect 'http://google.com', 'Hier bist du falsch'
</pre>
<p>
Ebenso leicht lässt sich ein Schritt zurück mit dem Alias  <tt>redirect
back</tt> erreichen:
</p>
<pre>
  get '/foo' do
    &quot;&lt;a href='/bar'&gt;mach was&lt;/a&gt;&quot;
  end

  get '/bar' do
    mach_was
    redirect back
  end
</pre>
<p>
Um Argumente an ein Redirect weiterzugeben, können sie entweder dem Query
übergeben:
</p>
<pre>
  redirect to('/bar?summe=42')
</pre>
<p>
oder eine Session verwendet werden:
</p>
<pre>
  enable :session
  
  get '/foo' do
    session[:secret] = 'foo'
    redirect to('/bar')
  end
  
  get '/bar' do
    session[:secret]
  end
</pre>
<a name='Dateien%20versenden'></a>
<h3>Dateien versenden</h3>
<p>
Zum Versenden von Dateien kann die <tt>send_file</tt>-Helfer-Methode
verwendet werden:
</p>
<pre>
  get '/' do
    send_file 'foo.png'
  end
</pre>
<p>
Für <tt>send_file</tt> stehen einige Hash-Optionen zur Verfügung:
</p>
<pre>
  send_file 'foo.png', :type =&gt; :jpg
</pre>
<dl>
<dt>filename</dt><dd><p>
Dateiname als Response. Standardwert ist der eigentliche Dateiname.
</p>
</dd>
<dt>last_modified</dt><dd><p>
Wert für den Last-Modified-Header, Standardwert ist <tt>mtime</tt> der
Datei.
</p>
</dd>
<dt>type</dt><dd><p>
Content-Type, der verwendet werden soll. Wird, wenn nicht angegeben, von
der Dateiendung abgeleitet.
</p>
</dd>
<dt>disposition</dt><dd><p>
Verwendet für Content-Disposition. Mögliche Werte sind: <tt>nil</tt>
(Standard), <tt>:attachment</tt> und <tt>:inline</tt>.
</p>
</dd>
<dt>length</dt><dd><p>
Content-Length-Header. Standardwert ist die Dateigröße.
</p>
</dd>
</dl>
<p>
Soweit vom Rack-Handler unterstützt, werden neben der Übertragung über den
Ruby-Prozess auch andere Möglichkeiten genutzt. Bei Verwendung der
<tt>send_file</tt>-Helfer-Methode kümmert sich Sinatra selbstständig um die
Range-Requests.
</p>
<a name='Das%20Request-Objekt'></a>
<h2>Das Request-Objekt</h2>
<p>
Auf das <tt>request</tt>-Objekt der eigehenden Anfrage kann vom
Anfrage-Scope aus zugegriffen werden:
</p>
<pre>
  # App läuft unter http://example.com/example
  get '/foo' do
    request.body              # Request-Body des Clients (siehe unten)
    request.scheme            # &quot;http&quot;
    request.script_name       # &quot;/example&quot;
    request.path_info         # &quot;/foo&quot;
    request.port              # 80
    request.request_method    # &quot;GET&quot;
    request.query_string      # &quot;&quot;
    request.content_length    # Länge von request.body
    request.media_type        # Media-Type von request.body
    request.host              # &quot;example.com&quot;
    request.get?              # true (ähnliche Methoden für andere Verben)
    request.form_data?        # false
    request[&quot;SOME_HEADER&quot;]    # Wert des SOME_HEADER-Headers
    request.referrer          # der Referrer des Clients oder '/'
    request.user_agent        # User-Agent (genutzt von :agent-Bedingung)
    request.cookies           # Hash der Cookies
    request.xhr?              # Ist dies eine Ajax-Anfrage?
    request.url               # &quot;http://example.com/example/foo&quot;
    request.path              # &quot;/example/foo&quot;
    request.ip                # Client-IP-Addresse
    request.secure?           # false (wäre true bei SSL)
    request.forwarded?        # true (wenn hinter Reverse-Proxy)
    requuest.env              # env-Hash, den Rack durchreicht
  end
</pre>
<p>
Manche Optionen, wie etwa <tt>script_name</tt> oder <tt>path_info</tt>,
sind auch schreibbar:
</p>
<pre>
  before { request.path_info = &quot;/&quot; }
  
  get &quot;/&quot; do
    &quot;Alle Anfragen kommen hier an!&quot;
  end
</pre>
<p>
Der <tt>request.body</tt> ist ein IO- oder StringIO-Objekt:
</p>
<pre>
  post &quot;/api&quot; do
    request.body.rewind # falls schon jemand davon gelesen hat
    daten = JSON.parse request.body.read
    &quot;Hallo #{daten['name']}!&quot;
  end
</pre>
<a name='Anh%C3%A4nge'></a>
<h3>Anhänge</h3>
<p>
Damit der Browser erkennt, dass ein Response gespeichert und nicht im
Browser angezeigt werden soll, kann der <tt>attachment</tt>-Helfer
verwendet werden:
</p>
<pre>
  get '/' do
    attachment
    &quot;Speichern!&quot;
  end
</pre>
<p>
Ebenso kann eine Dateiname als Parameter hinzugefügt werden:
</p>
<pre>
  get '/' do
    attachment &quot;info.txt&quot;
    &quot;Speichern!&quot;
  end
</pre>
<a name='Nachschlagen%20von%20Template-Dateien'></a>
<h3>Nachschlagen von Template-Dateien</h3>
<p>
Die <tt>find_template</tt>-Helfer-Methode wird genutzt, um Template-Dateien
zum Rendern aufzufinden:
</p>
<pre>
  find_template settings.views, 'foo', Tilt[:haml] do |file|
    puts &quot;könnte diese hier sein: #{file}&quot;
  end
</pre>
<p>
Das ist zwar nicht wirklich brauchbar, aber wenn man sie überschreibt, kann
sie nützlich werden, um eigene Nachschlage-Mechanismen einzubauen. Zum
Beispiel dann, wenn mehr als nur ein view-Verzeichnis verwendet werden
soll:
</p>
<pre>
  set :views, ['views', 'templates']

  helpers do
    def find_template(views, name, engine, &amp;block)
      Array(views).each { |v| super(v, name, engine, &amp;block) }
    end
  end
</pre>
<p>
Ein anderes Beispiel wäre, verschiedene Vereichnisse für verschiedene
Engines zu verwenden:
</p>
<pre>
  set :views, :sass =&gt; 'views/sass', :haml =&gt; 'templates', :default =&gt; 'views'

  helpers do
    def find_template(views, name, engine, &amp;block)
      _, folder = views.detect { |k,v| engine == Tilt[k] }
      folder ||= views[:default]
      super(folder, name, engine, &amp;block)
    end
  end
</pre>
<p>
Ebensogut könnte eine Extension aber auch geschrieben und mit anderen
geteilt werden!
</p>
<p>
Beachte, dass <tt>find_template</tt> nicht prüft, ob eine Datei tatsächlich
existiert. Es wird lediglich der angegebene Block aufgerufen und nach allen
möglichen Pfaden gesucht. Das ergibt kein Performance-Problem, da
<tt>render</tt> <tt>block</tt> verwendet, sobald eine Datei gefunden wurde.
Ebenso werden Template-Pfade samt Inhalt gecached, solange nicht im
Entwicklungsmodus gearbeitet wird. Das sollte im Hinterkopf behalten
werden, wenn irgendwelche verrückten Methoden zusammenbastelt werden.
</p>
<a name='Konfiguration'></a>
<h2>Konfiguration</h2>
<p>
Wird einmal beim Starten in jedweder Umgebung ausgeführt:
</p>
<pre>
  configure do
    # setze eine Option
    set :option, 'wert'
    
    # setze mehrere Optionen
    set :a =&gt; 1, :b =&gt; 2
    
    # das gleiche wie `set :option, true`
    enable :option
    
    # das gleiche wie `set :option, false`
    disable :option
    
    # dynamische Einstellungen mit Blöcken
    set(:css_dir) { File.join(views, 'css') }
  end
</pre>
<p>
Läuft nur, wenn die Umgebung (RACK_ENV-Umgebungsvariable) auf
<tt>:production</tt> gesetzt ist:
</p>
<pre>
  configure :production do
    ...
  end
</pre>
<p>
Läuft nur, wenn die Umgebung auf <tt>:production</tt> oder auf
<tt>:test</tt> gesetzt ist:
</p>
<pre>
  configure :production, :test do
    ...
  end
</pre>
<p>
Diese Einstellungen sind über <tt>settings</tt> erreichbar:
</p>
<pre>
  configure do
    set :foo, 'bar'
  end

  get '/' do
    settings.foo? # =&gt; true
    settings.foo  # =&gt; 'bar'
    ...
  end
</pre>
<a name='M%C3%B6gliche%20Einstellungen'></a>
<h3>Mögliche Einstellungen</h3>
<dl>
<dt>absolute_redirects</dt><dd><p>
Wenn ausgeschaltet, wird Sinatra relative Redirects zulassen. Jedoch ist
Sinatra dann nicht mehr mit RFC 2616 (HTTP 1.1) konform, das nur absolute
Redirects zulässt.
</p>
<p>
Sollte eingeschaltet werden, wenn die Applikation hinter einem
Reverse-Proxy liegt, der nicht ordentlich  eingerichtet ist. Beachte, dass
die <tt>url</tt>-Helfer-Methode nach wie vor absolute URLs erstellen wird,
es sei denn,  es wird als zweiter Parameter <tt>false</tt> angegeben.
</p>
<p>
Standardmäßig nicht aktiviert.
</p>
</dd>
<dt>add_charsets</dt><dd><p>
Mime-Types werden hier automatisch der Helfer-Methode <tt>content_type</tt>
zugeordnet.
</p>
<p>
Es empfielt sich, Werte hinzuzufügen statt sie zu überschreiben:
</p>
<pre>
  settings.add_charsets &lt;&lt; &quot;application/foobar&quot;
</pre>
</dd>
<dt>app_file</dt><dd><p>
Hauptdatei der Applikation. Wird verwendet, um das Wurzel-, Inline-, View-
und öffentliche Verzeichnis des Projekts festzustellen.
</p>
</dd>
<dt>bind</dt><dd><p>
IP-Address, an die gebunden wird (Standardwert: 0.0.0.0). Wird nur für den
eingebauten Server verwendet.
</p>
</dd>
<dt>default_encoding</dt><dd><p>
Das Encoding, falls keines angegeben wurde. Standardwert ist
<tt>&quot;utf-8&quot;</tt>.
</p>
</dd>
<dt>dump_errors</dt><dd><p>
Fehler im Log anzeigen.
</p>
</dd>
<dt>environment</dt><dd><p>
Momentane Umgebung. Standardmäßig auf <tt>content_type</tt> oder
<tt>&quot;development&quot;</tt> eingestellt, soweit ersteres nicht
vorhanden.
</p>
</dd>
<dt>logging</dt><dd><p>
Den Logger verwenden.
</p>
</dd>
<dt>lock</dt><dd><p>
Jeder Request wird gelocked. Es kann nur ein Request pro Ruby-Prozess
gleichzeitig verarbeitet werden.
</p>
<p>
Eingeschaltet, wenn die Applikation threadsicher ist. Standardmäßig nicht
aktiviert.
</p>
</dd>
<dt>method_override</dt><dd><p>
Verwende <tt>_method</tt>, um put/delete-Formulardaten in Browsern zu
verwenden, die dies normalerweise nicht unterstützen.
</p>
</dd>
<dt>port</dt><dd><p>
Port für die Applikation. Wird nur im internen Server verwendet.
</p>
</dd>
<dt>prefixed_redirects</dt><dd><p>
Entscheidet, ob <tt>request.script_name</tt> in Redirects eingefügt wird
oder nicht, wenn kein absoluter Pfad angegeben ist. Auf diese Weise verhält
sich <tt>redirect '/foo'</tt> so, als wäre es ein <tt>redirect
to('/foo')</tt>. Standardmäßig nicht aktiviert.
</p>
</dd>
<dt>public</dt><dd><p>
Das öffentliche Verzeichnis, aus dem Daten zur Verfügung gestellt werden
können.
</p>
</dd>
<dt>reload_templates</dt><dd><p>
Entscheidet, ob Templates zwischen Anfragen neu geladen werden sollen oder
nicht. Unter Ruby 1.8.6 ist es im Entwicklungsmodus eingeschaltet (um einen
Fehler in Ruby auszugleichen, der ein Speicherleck verursacht).
</p>
</dd>
<dt>root</dt><dd><p>
Wurzelverzeichnis des Projekts.
</p>
</dd>
<dt>raise_errors</dt><dd><p>
Einen Ausnahmezustand aufrufen. Beendet die Applikation.
</p>
</dd>
<dt>run</dt><dd><p>
Wenn aktiviert, wird Sinatra versuchen, den Webserver zu starten. Nicht
verwenden, wenn Rackup oder anderes verwendet werden soll.
</p>
</dd>
<dt>running</dt><dd><p>
Läuft der eingebaute Server? Diese Einstellung nicht ändern!
</p>
</dd>
<dt>server</dt><dd><p>
Server oder Liste von Servern, die als eingebaute Server zur Verfügung
stehen. Standardmäßig auf [&#8216;thin&#8217;, &#8216;mongrel&#8217;,
&#8216;webrick&#8217;] voreingestellt. Die Anordnung gibt die Priorität
vor.
</p>
</dd>
<dt>sessions</dt><dd><p>
Sessions auf Cookiebasis aktivieren.
</p>
</dd>
<dt>show_exceptions</dt><dd><p>
Stacktrace im Browser bei Fehlern anzeigen.
</p>
</dd>
<dt>static</dt><dd><p>
Entscheidet, ob Sinatra statische Dateien zur Verfügung stellen soll oder
nicht. Sollte nicht aktiviert werden, wenn ein Server verwendet wird, der
dies auch selbstständig erledigen kann. Deaktivieren wird die Performance
erhöhen. Standardmäßig aktiviert.
</p>
</dd>
<dt>views</dt><dd><p>
Verzeichnis der Views.
</p>
</dd>
</dl>
<a name='Fehlerbehandlung'></a>
<h2>Fehlerbehandlung</h2>
<p>
Error-Handler laufen in demselben Kontext wie Routen und Filter, was
bedeutet, dass alle Goodies wie <tt>haml</tt>, <tt>erb</tt>, <tt>halt</tt>,
etc. verwendet werden können.
</p>
<a name='Nicht%20gefunden'></a>
<h3>Nicht gefunden</h3>
<p>
Wenn eine <tt>Sinatra::NotFound</tt>-Exception geworfen wird oder der
Statuscode 404 ist, wird der <tt>not_found</tt>-Handler ausgeführt:
</p>
<pre>
  not_found do
    'Seite kann nirgendwo gefunden werden.'
  end
</pre>
<a name='Fehler'></a>
<h3>Fehler</h3>
<p>
Der <tt>error</tt>-Handler wird immer ausgeführt, wenn eine Exception in
einem Routen-Block oder in einem Filter geworfen wurde. Die Exception kann
über die <tt>sinatra.error</tt>-Rack-Variable angesprochen werden:
</p>
<pre>
  error do
    'Entschuldige, es gab einen hässlichen Fehler - ' + env['sinatra.error'].name
  end
</pre>
<p>
Benutzerdefinierte Fehler:
</p>
<pre>
  error MeinFehler do
    'Au weia, ' + env['sinatra.error'].message
  end
</pre>
<p>
Dann, wenn das passiert:
</p>
<pre>
  get '/' do
    raise MeinFehler, 'etwas Schlimmes ist passiert'
  end
</pre>
<p>
bekommt man dieses:
</p>
<pre>
  Au weia, etwas Schlimmes ist passiert
</pre>
<p>
Alternativ kann ein Error-Handler auch für einen Status-Code definiert
werden:
</p>
<pre>
  error 403 do
    'Zugriff verboten'
  end

  get '/geheim' do
    403
  end
</pre>
<p>
Oder ein Status-Code-Bereich:
</p>
<pre>
  error 400..510 do
    'Hallo?'
  end
</pre>
<p>
Sinatra setzt verschiedene <tt>not_found</tt>- und <tt>error</tt>-Handler
in der Development-Umgebung.
</p>
<a name='Rack-Middleware'></a>
<h2>Rack-Middleware</h2>
<p>
Sinatra baut auf <a href="http://rack.rubyforge.org/">Rack</a>, einem
minimalistischen Standard-Interface für Ruby-Webframeworks. Eines der
interessantesten Features für Entwickler ist der Support von Middlewares,
die zwischen den  Server und die Anwendung geschaltet werden und so
HTTP-Request und/oder Antwort überwachen und/oder manipulieren können.
</p>
<p>
Sinatra macht das Erstellen von Middleware-Verkettungen mit der 
Top-Level-Methode <tt>use</tt> zu einem Kinderspiel:
</p>
<pre>
  require 'sinatra'
  require 'meine_middleware'

  use Rack::Lint
  use MeineMiddleware

  get '/hallo' do
    'Hallo Welt'
  end
</pre>
<p>
Die Semantik von <tt>use</tt> entspricht der gleichnamigen Methode der <a
href="http://rack.rubyforge.org/doc/classes/Rack/Builder.html">Rack::Builder</a>
(meist verwendet in Rackup-Dateien). Ein Beispiel dafür ist, dass die
<tt>use</tt>-Methode mehrere/verschiedene Argumente und auch Blöcke
entgegennimmt:
</p>
<pre>
  use Rack::Auth::Basic do |username, password|
    username == 'admin' &amp;&amp; password == 'geheim'
  end
</pre>
<p>
Rack bietet eine Vielzahl von Standard-Middlewares für Logging, Debugging,
URL-Routing, Authentifizierung und Session-Verarbeitung. Sinatra verwendet 
viele von diesen Komponenten automatisch, abhängig von der Konfiguration.
So  muss <tt>use</tt> häufig nicht explizit verwendet werden.
</p>
<a name='Testen'></a>
<h2>Testen</h2>
<p>
Sinatra-Tests können mit jedem auf Rack aufbauendem Test-Framework
geschrieben werden. <a
href="http://gitrdoc.com/brynary/rack-test">Rack::Test</a> wird empfohlen:
</p>
<pre>
  require 'my_sinatra_app'
  require 'test/unit'
  require 'rack/test'

  class MyAppTest &lt; Test::Unit::TestCase
    include Rack::Test::Methods

    def app
      Sinatra::Application
    end

    def test_my_default
      get '/'
      assert_equal 'Hallo Welt!', last_response.body
    end

    def test_with_params
      get '/meet', :name =&gt; 'Frank'
      assert_equal 'Hallo Frank!', last_response.body
    end

    def test_with_rack_env
      get '/', {}, 'HTTP_USER_AGENT' =&gt; 'Songbird'
      assert_equal &quot;Du verwendest Songbird!&quot;, last_response.body
    end
  end
</pre>
<p>
Anmerkung: Das eingebaute Sinatra::Test-Modul und die 
Sinatra::TestHarness-Klasse werden seit Version 0.9.2 nicht mehr
unterstützt.
</p>
<a name='Sinatra::Base%20-%20Middleware,%20Bibliotheken%20und%20modulare%20Anwendungen'></a>
<h2>Sinatra::Base - Middleware, Bibliotheken und modulare Anwendungen</h2>
<p>
Das Definieren einer Top-Level-Anwendung funktioniert gut für 
Mikro-Anwendungen, hat aber Nachteile, wenn wiederverwendbare Komponenten
wie  Middleware, Rails Metal, einfache Bibliotheken mit Server-Komponenten
oder auch Sinatra-Erweiterungen geschrieben werden sollen.
</p>
<p>
Die Top-Level-DSL belastet den Objekt-Namespace und setzt einen
Mikro-Anwendungsstil voraus (eine einzelne Anwendungsdatei, ./public und 
./views Ordner, Logging, Exception-Detail-Seite, usw.). Genau hier kommt 
Sinatra::Base ins Spiel:
</p>
<pre>
  require 'sinatra/base'

  class MyApp &lt; Sinatra::Base
    set :sessions, true
    set :foo, 'bar'

    get '/' do
      'Hallo Welt!'
    end
  end
</pre>
<p>
Die MyApp-Klasse ist eine unabhängige Rack-Komponente, die als Middleware,
Endpunkt oder via Rails Metal verwendet werden kann. Verwendet wird sie
durch <tt>use</tt> oder <tt>run</tt> von einer
Rackup-<tt>config.ru</tt>-Datei oder als  Server-Komponente einer
Bibliothek:
</p>
<pre>
   MyApp.run! :host =&gt; 'localhost', :port =&gt; 9090
</pre>
<p>
Die Methoden der Sinatra::Base-Subklasse sind genau dieselben wie die der 
Top-Level-DSL. Die meisten Top-Level-Anwendungen können mit nur zwei 
Veränderungen zu Sinatra::Base-Komponenten konvertiert werden:
</p>
<ul>
<li><p>
Die Datei sollte <tt>require 'sinatra/base'</tt> anstelle von <tt>require
'sinatra/base'</tt> aufrufen, ansonsten werden alle von Sinatras
DSL-Methoden in den Top-Level-Namespace importiert.
</p>
</li>
<li><p>
Alle Routen, Error-Handler, Filter und Optionen der Applikation müssen in
einer Subklasse von Sinatra::Base definiert werden.
</p>
</li>
</ul>
<p>
<tt>Sinatra::Base</tt> ist ein unbeschriebenes Blatt. Die meisten Optionen
sind per Standard deaktiviert. Das betrifft auch den eingebauten Server.
Siehe <a href="http://sinatra.github.com/configuration.html">Optionen und
Konfiguration</a> für Details über mögliche Optionen.
</p>
<a name='Modularer%20vs.%20klassischer%20Stil'></a>
<h3>Modularer vs. klassischer Stil</h3>
<p>
Entgegen häufiger Meinungen gibt es nichts gegen den klassischen Stil
einzuwenden. Solange es die Applikation nicht beeinträchtigt, besteht kein
Grund, eine modulare Applikation zu erstellen.
</p>
<p>
Lediglich zwei Nachteile gegenüber dem modularen Stil sollten beachtet
werden:
</p>
<ul>
<li><p>
Es kann nur eine Sinatra Applikation pro Ruby-Prozess laufen. Sollten
mehrere zum Einsatz kommen, muss auf den modularen Stil umgestiegen werden.
</p>
</li>
<li><p>
Der klassische Stil füllt Object mit Delegations-Methoden. Sollte die
Applikation als Gem/Bibliothek zum Einsatz kommen, sollte auf den modularen
Stil umgestiegen werden.
</p>
</li>
</ul>
<p>
Es gibt keinen Grund, warum modulare und klassische Elemente nicht
vermischt werden sollten.
</p>
<p>
Will man jedoch von einem Stil auf den anderen umsteigen, sollten einige
Unterschiede beachtet werden:
</p>
<pre>
  Szenario            Classic                 Modular

  app_file            file loading sinatra    nil
  run                 $0 == app_file          false
  logging             true                    false
  method_override     true                    false
  inline_templates    true                    false
</pre>
<a name='Eine%20modulare%20Applikation%20bereitstellen'></a>
<h3>Eine modulare Applikation bereitstellen</h3>
<p>
Es gibt zwei übliche Wege, eine modulare Anwendung zu starten. Zum einen
über <tt>run!</tt>:
</p>
<pre>
  # mein_app.rb
  require 'sinatra/base'
  
  class MeinApp &lt; Sinatra::Base
    # ... Anwendungscode hierhin ...
    
    # starte den Server, wenn die Ruby-Datei direkt ausgeführt wird
    run! if app_file == $0
  end
</pre>
<p>
Starte mit:
</p>
<pre>
  ruby mein_app.rb
</pre>
<p>
Oder über eine <tt>config.ru</tt>-Datei, die es erlaubt, einen beliebigen
Rack-Handler zu verwenden:
</p>
<pre>
  # config.ru
  require 'mein_app'
  run MeineApp
</pre>
<p>
Starte:
</p>
<pre>
  rackup -p 4567
</pre>
<a name='Eine%20klassische%20Anwendung%20mit%20einer%20config.ru%20verwenden'></a>
<h3>Eine klassische Anwendung mit einer config.ru verwenden</h3>
<p>
Schreibe eine Anwendungsdatei:
</p>
<pre>
  # app.rb
  require 'sinatra'
  
  get '/' do
    'Hallo Welt!'
  end
</pre>
<p>
sowie eine dazugehörige <tt>config.ru</tt>-Datei:
</p>
<pre>
  require 'app'
  run Sinatra::Application
</pre>
<a name='Wann%20sollte%20eine%20config.ru-Datei%20verwendet%20werden?'></a>
<h3>Wann sollte eine config.ru-Datei verwendet werden?</h3>
<p>
Anzeichen dafür, dass eine <tt>config.ru</tt>-Datei gebraucht wird:
</p>
<ul>
<li><p>
Es soll ein anderer Rack-Handler verwendet werden (Passenger, Unicorn,
Heroku, &#8230;).
</p>
</li>
<li><p>
Es gibt mehr als nur eine Subklasse von <tt>Sinatra::Base</tt>.
</p>
</li>
<li><p>
Sinatra soll als Middleware verwendet werden, nicht als Endpunkt.
</p>
</li>
</ul>
<p>
<b>Es gibt keinen Grund, eine <tt>config.ru</tt>-Datei zu verwenden, nur
weil eine Anwendung im modularen Stil betrieben werden soll. Ebenso wird
keine  Anwendung mit modularem Stil benötigt, um eine
<tt>config.ru</tt>-Datei zu  verwenden.</b>
</p>
<a name='Sinatra%20als%20Middleware%20nutzen'></a>
<h3>Sinatra als Middleware nutzen</h3>
<p>
Es ist nicht nur möglich, andere Rack-Middleware mit Sinatra zu nutzen, es
kann außerdem jede Sinatra-Anwendung selbst als Middleware vor jeden
beliebigen  Rack-Endpunkt gehangen werden. Bei diesem Endpunkt muss es sich
nicht um eine  andere Sinatra-Anwendung handeln, es kann jede andere
Rack-Anwendung sein (Rails/Ramaze/Camping/&#8230;):
</p>
<pre>
  require 'sinatra/base'

  class LoginScreen &lt; Sinatra::Base
    enable :sessions
  
    get('/login') { haml :login }
  
    post('/login') do
      if params[:name] = 'admin' and params[:password] = 'admin'
        session['user_name'] = params[:name]
      else
        redirect '/login'
      end
    end
  end

  class MyApp &lt; Sinatra::Base
    # Middleware wird vor Filtern ausgeführt
    use LoginScreen
  
    before do
      unless session['user_name']
        halt &quot;Zugriff verweigert, bitte &lt;a href='/login'&gt;einloggen&lt;/a&gt;.&quot;
      end
    end
  
    get('/') { &quot;Hallo #{session['user_name']}.&quot; }
  end
</pre>
<a name='Geltungsbereich%20und%20Bindung'></a>
<h2>Geltungsbereich und Bindung</h2>
<p>
Der Geltungsbereich (Scope) legt fest, welche Methoden und Variablen zur
Verfügung stehen.
</p>
<a name='Anwendungs-%20oder%20Klassen-Scope'></a>
<h3>Anwendungs- oder Klassen-Scope</h3>
<p>
Jede Sinatra-Anwendung entspricht einer Sinatra::Base-Subklasse. Falls die
Top- Level-DSL verwendet wird (<tt>require 'sinatra'</tt>), handelt es sich
um  Sinatra::Application, andernfalls ist es jene Subklasse, die explizit
angelegt  wurde. Auf Klassenebene stehen Methoden wie <tt>get</tt> oder
<tt>before</tt> zur Verfügung, es gibt aber keinen Zugriff auf das
<tt>request</tt>-Object oder die <tt>session</tt>, da nur eine einzige
Klasse für alle eingehenden Anfragen genutzt wird.
</p>
<p>
Optionen, die via <tt>set</tt> gesetzt werden, sind Methoden auf
Klassenebene:
</p>
<pre>
  class MyApp &lt; Sinatra::Base
    # Hey, ich bin im Anwendungsscope!
    set :foo, 42
    foo # =&gt; 42
    
    get '/foo' do
      # Hey, ich bin nicht mehr im Anwendungs-Scope!
    end
  end
</pre>
<p>
Im Anwendungs-Scope befindet man sich:
</p>
<ul>
<li><p>
In der Anwendungs-Klasse.
</p>
</li>
<li><p>
In Methoden, die von Erweiterungen definiert werden.
</p>
</li>
<li><p>
Im Block, der an <tt>helpers</tt> übergeben wird.
</p>
</li>
<li><p>
In Procs und Blöcken, die an <tt>set</tt> übergeben werden.
</p>
</li>
</ul>
<p>
Auf das Scope-Objekt (die Klasse) kann wie folgt zugegriffen werden:
</p>
<ul>
<li><p>
Über das Objekt, das an den <tt>configure</tt>-Block übergeben wird
(<tt>configure { |c| ... }</tt>).
</p>
</li>
<li><p>
<tt>settings</tt> aus den anderen Scopes heraus.
</p>
</li>
</ul>
<a name='Anfrage-%20oder%20Instanz-Scope'></a>
<h3>Anfrage- oder Instanz-Scope</h3>
<p>
Für jede eingehende Anfrage wird eine neue Instanz der Anwendungs-Klasse
erstellt und alle Handler in diesem Scope ausgeführt. Aus diesem Scope
heraus kann auf <tt>request</tt> oder <tt>session</tt> zugegriffen und
Methoden wie <tt>erb</tt> oder <tt>haml</tt> aufgerufen werden. Außerdem
kann mit der <tt>settings</tt>-Method auf den Anwendungs-Scope zugegriffen
werden:
</p>
<pre>
  class MyApp &lt; Sinatra::Base
    # Hey, ich bin im Anwendungs-Scope!
    get '/neue_route/:name' do
      # Anfrage-Scope für '/neue_route/:name'
      @value = 42
      
      settings.get &quot;/#{params[:name]}&quot; do
        # Anfrage-Scope für &quot;/#{params[:name]}&quot;
        @value # =&gt; nil (nicht dieselbe Anfrage)
      end
      
      &quot;Route definiert!&quot;
    end
  end
</pre>
<p>
Im Anfrage-Scope befindet man sich:
</p>
<ul>
<li><p>
In get/head/post/put/delete-Blöcken
</p>
</li>
<li><p>
In before/after-Filtern
</p>
</li>
<li><p>
In Helfer-Methoden
</p>
</li>
<li><p>
In Templates
</p>
</li>
</ul>
<a name='Delegation-Scope'></a>
<h3>Delegation-Scope</h3>
<p>
Vom Delegation-Scope aus werden Methoden einfach an den Klassen-Scope
weitergeleitet. Dieser verhält sich jedoch nicht 100%ig wie der
Klassen-Scope, da man nicht die Bindung der Klasse besitzt: Nur Methoden,
die explizit als delegierbar markiert wurden, stehen hier zur Verfügung und
es kann nicht auf die Variablen des Klassenscopes zugegriffen werden (mit
anderen Worten: es gibt ein anderes <tt>self</tt>). Weitere Delegationen
können mit  <tt>Sinatra::Delegator.delegate :methoden_name</tt> hinzugefügt
werden.
</p>
<p>
Im Delegation-Scop befindet man sich:
</p>
<ul>
<li><p>
Im Top-Level, wenn <tt>require 'sinatra'</tt> aufgerufen wurde.
</p>
</li>
<li><p>
In einem Objekt, das mit dem <tt>Sinatra::Delegator</tt>-Mixin erweitert 
wurde.
</p>
</li>
</ul>
<p>
Schau am besten im Code nach: Hier ist <a
href="http://github.com/sinatra/sinatra/blob/master/lib/sinatra/base.rb#L1064">Sinatra::Delegator
mixin</a> definiert und wird in den <a
href="http://github.com/sinatra/sinatra/blob/master/lib/sinatra/main.rb#L25">globalen
Namespace eingebunden</a>.
</p>
<a name='Kommandozeile'></a>
<h2>Kommandozeile</h2>
<p>
Sinatra-Anwendungen können direkt von der Kommandozeile aus gestartet
werden:
</p>
<pre>
  ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-h HOST] [-s HANDLER]
</pre>
<p>
Die Optionen sind:
</p>
<pre>
  -h # Hilfe
  -p # Port setzen (Standard ist 4567)
  -h # Host setzen (Standard ist 0.0.0.0)
  -e # Umgebung setzen (Standard ist development)
  -s # Rack-Server/Handler setzen (Standard ist thin)
  -x # Mutex-Lock einschalten (Standard ist off)
</pre>
<a name='Systemanforderungen'></a>
<h2>Systemanforderungen</h2>
<p>
Es wird empfohlen, Sinatra unter Ruby 1.8.7, 1.9.2, JRuby oder Rubinius zu
installieren.
</p>
<p>
Die folgenden Versionen werden offiziell unterstützt:
</p>
<dl>
<dt> Ruby 1.8.6 </dt><dd><p>
Es wird nicht empfohlen, 1.8.6 für Sinatra einzusetzen. Trotzdem wird es
offiziell bis Sinatra 1.3.0 unterstützt werden. RDoc- und CoffeeScript- 
Templates werden in dieser Version nicht unterstützt. 1.8.6 hat ein
größeres Speicherleck in seiner Hash-Implementation, das von
Sinatra-Versionen vor  1.1.1 ausgelöst wird. Die aktuelle Version
verhindert das zwar explizit, aber  unter Einbußen in der Performance.
Ebenso muss Sinatra mit Rack 1.1.x laufen, da Rack >= 1.2 Ruby 1.8.6 nicht
mehr unterstützt.
</p>
</dd>
<dt> Ruby 1.8.7 </dt><dd><p>
1.8.7 wird vollständig unterstützt, aber solange nichts dagegen spricht, 
wird ein Update auf 1.9.2 oder ein Umstieg auf JRuby/Rubinius empfohlen.
</p>
</dd>
<dt> Ruby 1.9.2 </dt><dd><p>
1.9.2 wird unterstützt und empfohlen. Beachte, dass Markaby und Radius
momentan noch nicht kompatibel mit 1.9 sind. Version 1.9.0p0 sollte nicht
verwendet werden, da unter Sinatra immer wieder Segfaults auftreten.
</p>
</dd>
<dt> Rubinius </dt><dd><p>
Rubinius (rbx >= 1.2.3) wird offiziell unter Einbezug aller Templates 
unterstützt.
</p>
</dd>
<dt> JRuby </dt><dd><p>
JRuby wird offiziell unterstützt (JRuby >= 1.6.0). Probleme mit Template- 
Bibliotheken Dritter sind nicht bekannt. Falls JRuby zum Einsatz kommt, 
sollte aber darauf geachtet werden, dass ein JRuby-Rack-Handler zum Einsatz
kommt – der Thin-Web-Server wird bisher nicht unterstütz. JRubys 
Unterstützung für C-Erweiterungen sind zur Zeit noch experimenteller Natur,
betrifft im Moment aber nur RDiscount.
</p>
</dd>
</dl>
<p>
Weiterhin werden wir auf kommende Ruby-Versionen ein Auge haben.
</p>
<p>
Die nachfolgend aufgeführten Ruby-Implementationen werden offiziell nicht
von  Sinatra unterstützt, funktionieren aber normalerweise:
</p>
<ul>
<li><p>
Ältere Versionen von JRuby und Rubinius
</p>
</li>
<li><p>
MacRuby, Maglev, IronRuby
</p>
</li>
<li><p>
Ruby 1.9.0 und 1.9.1
</p>
</li>
</ul>
<p>
Nicht offiziell unterstützt bedeutet, dass wenn Sachen nicht funktionieren,
wir davon ausgehen, dass es nicht an Sinatra sondern an der jeweiligen 
Implentierung liegt.
</p>
<p>
Im Rahmen unserer CI (Kontinuierlichen Integration) wird bereits ruby-head
(das kommende Ruby 1.9.3) mit eingebunden. Da noch alles im Fluss ist, kann
zur Zeit für nichts garantiert werden. Es kann aber erwartet werden, dass
Ruby  1.9.3p0 von Sinatra unterstützt werden wird.
</p>
<p>
Sinatra sollte auf jedem Betriebssystem laufen, dass den gewählten Ruby-
Interpreter unterstützt.
</p>
<a name='Der%20neueste%20Stand%20(The%20Bleeding%20Edge)'></a>
<h2>Der neueste Stand (The Bleeding Edge)</h2>
<p>
Um auf dem neusten Stand zu bleiben, kann der Master-Branch verwendet
werden. Er sollte recht stabil sein. Ebenso gibt es von Zeit zu Zeit
prerelease Gems,  die so installiert werden:
</p>
<pre>
  
  gem install sinatra --pre
</pre>
<a name='Mit%20Bundler'></a>
<h3>Mit Bundler</h3>
<p>
Wenn die Applikation mit der neuesten Version von Sinatra und <a
href="http://gembundler.com/">Bundler</a> genutzt werden soll, empfehlen
wir den nachfolgenden Weg.
</p>
<p>
Soweit Bundler noch nicht installiert ist:
</p>
<pre>
  gem install bundler
</pre>
<p>
Anschließend wird eine <tt>Gemfile</tt>-Datei im Projektverzeichnis mit
folgendem Inhalt erstellt:
</p>
<pre>
  source :rubygems
  gem 'sinatra', :git =&gt; &quot;git://github.com/sinatra/sinatra.git&quot;
  
  # evtl. andere Abhängigkeiten
  gem 'haml'                    # z.B. wenn du Haml verwendest...
  gem 'activerecord', '~&gt; 3.0'  # ...oder ActiveRecord 3.x
</pre>
<p>
Beachte: Hier sollten alle Abhängigkeiten eingetragen werden. Sinatras
eigene, direkte Abhängigkeiten (Tilt und Rack) werden von Bundler
automatisch aus dem Gemfile von Sinatra hinzugefügt.
</p>
<p>
Jetzt kannst du deine Applikation starten:
</p>
<pre>
  bundle exec ruby myapp.rb

  
</pre>
<a name='Eigenes%20Repository'></a>
<h3>Eigenes Repository</h3>
<p>
Um auf dem neuesten Stand von Sinatras Code zu sein, kann eine lokale Kopie
angelegt werden. Gestartet wird in der Anwendung mit dem
<tt>sinatra/lib</tt>- Ordner im <tt>LOAD_PATH</tt>:
</p>
<pre>
  cd myapp
  git clone git://github.com/sinatra/sinatra.git
  ruby -Isinatra/lib myapp.rb
</pre>
<p>
Alternativ kann der <tt>sinatra/lib</tt>-Ordner zum <tt>LOAD_PATH</tt> in
der Anwendung hinzugefügt werden:
</p>
<pre>
  $LOAD_PATH.unshift File.dirname(__FILE__) + '/sinatra/lib'
  require 'rubygems'
  require 'sinatra'

  get '/ueber' do
    &quot;Ich laufe auf Version &quot; + Sinatra::VERSION
  end
</pre>
<p>
Um Sinatra-Code von Zeit zu Zeit zu aktualisieren:
</p>
<pre>
  cd myproject/sinatra
  git pull
</pre>
<a name='Gem%20erstellen'></a>
<h3>Gem erstellen</h3>
<p>
Aus der eigenen lokalen Kopie kann nun auch ein globales Gem gebaut werden:
</p>
<pre>
  git clone git://github.com/sinatra/sinatra.git
  cd sinatra
  rake sinatra.gemspec
  rake install
</pre>
<p>
Falls Gems als Root installiert werden sollen, sollte die letzte Zeile 
folgendermaßen lauten:
</p>
<pre>
  sudo rake install
</pre>
<a name='Versions-Verfahren'></a>
<h2>Versions-Verfahren</h2>
<p>
Sinatra folgt dem sogenannten <a href="http://semver.org/">Semantic
Versioning</a>, d.h.  SemVer und SemVerTag.
</p>
<a name='Mehr'></a>
<h2>Mehr</h2>
<ul>
<li><p>
<a href="http://sinatra.github.com/">Projekt-Website</a> - Ergänzende
Dokumentation, News und Links zu anderen Ressourcen.
</p>
</li>
<li><p>
<a href="http://sinatra.github.com/contributing.html">Hilfe beisteuern</a>
- Einen Fehler gefunden? Brauchst du Hilfe? Hast du einen Patch?
</p>
</li>
<li><p>
<a href="http://github.com/sinatra/sinatra/issues">Issue-Tracker</a>
</p>
</li>
<li><p>
<a href="http://twitter.com/sinatra">Twitter</a>
</p>
</li>
<li><p>
<a href="http://groups.google.com/group/sinatrarb">Mailing-Liste</a>
</p>
</li>
<li><p>
<a href="irc://chat.freenode.net/#sinatra">IRC: #sinatra</a> auf <a
href="http://freenode.net">freenode.net</a>
</p>
</li>
<li><p>
API Dokumentation für die <a
href="http://rubydoc.info/gems/sinatra">aktuelle Version</a>	 oder für <a
href="http://rubydoc.info/github/sinatra/sinatra">HEAD</a> auf  <a
href="http://rubydoc.info">rubydoc.info</a>
</p>
</li>
</ul>
