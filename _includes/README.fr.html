<div class='toc'>
	<ol class='level-1'>
		<li><a href='#Routes'>Routes</a></li>
		<ol class='level-2'>
			<li><a href='#Conditions'>Conditions</a></li>
			<li><a href='#Valeurs%20de%20retour'>Valeurs de retour</a></li>
			<li><a href='#Masques%20de%20route%20sp%C3%A9cifiques'>Masques de route spécifiques</a></li>
		</ol>
		<li><a href='#Fichiers%20statiques'>Fichiers statiques</a></li>
		<li><a href='#Vues%20/%20Templates'>Vues / Templates</a></li>
		<ol class='level-2'>
			<li><a href='#Templates%20Haml'>Templates Haml</a></li>
			<li><a href='#Templates%20Erb'>Templates Erb</a></li>
			<li><a href='#Templates%20Erubis'>Templates Erubis</a></li>
			<li><a href='#Templates%20Builder'>Templates Builder</a></li>
			<li><a href='#Templates%20Nokogiri'>Templates Nokogiri</a></li>
			<li><a href='#Templates%20Sass'>Templates Sass</a></li>
			<li><a href='#Templates%20Scss'>Scss Templates</a></li>
			<li><a href='#Templates%20Less'>Templates Less</a></li>
			<li><a href='#Templates%20Liquid'>Templates Liquid</a></li>
			<li><a href='#Templates%20Markdown'>Templates Markdown</a></li>
			<li><a href='#Templates%20Textile'>Templates Textile</a></li>
			<li><a href='#Templates%20RDoc'>Templates RDoc</a></li>
			<li><a href='#Templates%20Radius'>Templates Radius</a></li>
			<li><a href='#Templates%20Markaby'>Templates Markaby</a></li>
			<li><a href='#Templates%20Slim'>Templates Slim</a></li>
			<li><a href='#Templates%20CoffeeScript'>Templates CoffeeScript</a></li>
			<li><a href='#Templates%20embarqu%C3%A9s'>Templates embarqués</a></li>
			<li><a href='#Acc%C3%A9der%20aux%20variables%20dans%20un%20Template'>Accéder aux variables dans un Template</a></li>
			<li><a href='#Templates%20dans%20le%20fichier%20source'>Templates dans le fichier source</a></li>
			<li><a href='#Templates%20nomm%C3%A9s'>Templates nommés</a></li>
			<li><a href='#Associer%20des%20extensions%20de%20fichier'>Associer des extensions de fichier</a></li>
			<li><a href='#Ajouter%20son%20propre%20moteur%20de%20rendu'>Ajouter son propre moteur de rendu</a></li>
		</ol>
		<li><a href='#Filtres'>Filtres</a></li>
		<li><a href='#Helpers'>Helpers</a></li>
		<ol class='level-2'>
			<li><a href='#Utiliser%20les%20sessions'>Utiliser les sessions</a></li>
		</ol>
		<li><a href='#Halt'>Halt</a></li>
		<li><a href='#Passer'>Passer</a></li>
		<ol class='level-2'>
			<li><a href='#D%C3%A9clencher%20une%20autre%20route'>Déclencher une autre route</a></li>
			<li><a href='#D%C3%A9finir%20le%20corps,%20le%20code%20retour%20et%20les%20ent%C3%AAtes'>Définir le corps, le code retour et les entêtes</a></li>
			<li><a href='#Types%20Mime'>Types Mime</a></li>
			<li><a href='#Former%20des%20URLs'>Former des URLs</a></li>
			<li><a href='#Redirection%20du%20navigateur'>Redirection du navigateur</a></li>
			<li><a href='#Contr%C3%B4le%20du%20cache'>Contrôle du cache</a></li>
			<li><a href='#Envoyer%20des%20fichiers'>Envoyer des fichiers</a></li>
		</ol>
		<li><a href='#Acc%C3%A9der%20%C3%A0%20l&%238217;objet%20requ%C3%AAte'>Accéder à l&#8217;objet requête</a></li>
		<ol class='level-2'>
			<li><a href='#Fichiers%20joints'>Fichiers joints</a></li>
			<li><a href='#Chercher%20les%20fichiers%20de%20templates'>Chercher les fichiers de templates</a></li>
		</ol>
		<li><a href='#Configuration'>Configuration</a></li>
		<ol class='level-2'>
			<li><a href='#Param%C3%A8tres%20disponibles'>Paramètres disponibles</a></li>
		</ol>
		<li><a href='#G%C3%A9rer%20les%20erreurs'>Gérer les erreurs</a></li>
		<ol class='level-2'>
			<li><a href='#Pas%20Trouv%C3%A9'>Pas Trouvé</a></li>
			<li><a href='#Erreur'>Erreur</a></li>
		</ol>
		<li><a href='#Les%20Middlewares%20Rack'>Les Middlewares Rack</a></li>
		<li><a href='#Tester'>Tester</a></li>
		<li><a href='#Sinatra::Base%20-%20Les%20Middlewares,%20les%20Biblioth%C3%A8ques,%20et%20les%20Applications%20Modulaires'>Sinatra::Base - Les Middlewares, les Bibliothèques, et les Applications Modulaires</a></li>
		<ol class='level-2'>
			<li><a href='#Style%20modulaire%20vs.%20style%20classique'>Style modulaire vs. style classique</a></li>
			<li><a href='#Servir%20une%20application%20modulaire'>Servir une application modulaire</a></li>
			<li><a href='#Utiliser%20une%20application%20de%20style%20classique%20avec%20un%20fichier%20config.ru'>Utiliser une application de style classique avec un fichier config.ru</a></li>
			<li><a href='#Quand%20utiliser%20un%20fichier%20config.ru%20?'>Quand utiliser un fichier config.ru ?</a></li>
			<li><a href='#Utiliser%20Sinatra%20comme%20Middleware'>Utiliser Sinatra comme Middleware</a></li>
		</ol>
		<li><a href='#Contextes%20et%20Binding'>Contextes et Binding</a></li>
		<ol class='level-2'>
			<li><a href='#Contexte%20de%20l&%238217;application/classe'>Contexte de l&#8217;application/classe</a></li>
			<li><a href='#Contexte%20de%20la%20requ%C3%AAte/instance'>Contexte de la requête/instance</a></li>
			<li><a href='#Le%20contexte%20de%20d%C3%A9l%C3%A9gation'>Le contexte de délégation</a></li>
		</ol>
		<li><a href='#Ligne%20de%20commande'>Ligne de commande</a></li>
		<li><a href='#Configuration%20n%C3%A9cessaire'>Configuration nécessaire</a></li>
		<li><a href='#Essuyer%20les%20pl%C3%A2tres'>Essuyer les plâtres</a></li>
		<ol class='level-2'>
			<li><a href='#Avec%20Bundler'>Avec Bundler</a></li>
			<li><a href='#Faites%20le%20vous-m%C3%AAme'>Faites le vous-même</a></li>
			<li><a href='#Installez%20globalement'>Installez globalement</a></li>
		</ol>
		<li><a href='#Versions'>Versions</a></li>
		<li><a href='#Mais%20encore'>Mais encore</a></li>
	</ol>
</div>

<p>
<em>Attention: Ce document correspond à la traduction de la version
anglaise et il n&#8217;est peut être plus à jour.</em>
</p>
<p>
Sinatra est un DSL pour créer rapidement des applications web en Ruby et
sans effort:
</p>
<pre>
  # mon_application.rb
  require 'sinatra'
  get '/' do
    'Bonjour Monde!'
  end
</pre>
<p>
Installez le gem et lancez avec:
</p>
<pre>
  gem install sinatra
  ruby -rubygems mon_application.rb
</pre>
<p>
Le résultat est visible sur: <a
href="http://localhost:4567">localhost:4567</a>
</p>
<p>
Il est également recommandé d&#8217;exécuter <tt>gem install thin</tt>, que
Sinatra utilisera si disponible.
</p>
<a name='Routes'></a>
<h2>Routes</h2>
<p>
Dans Sinatra, une route est une méthode HTTP couplée à un masque (pattern)
URL. Chaque route est associée à un bloc:
</p>
<pre>
  get '/' do
    .. montrer quelque chose ..
  end

  post '/' do
    .. créer quelque chose ..
  end

  put '/' do
    .. changer quelque chose ..
  end

  delete '/' do
    .. effacer quelque chose ..
  end

  options '/' do
    .. apaiser quelquechose ..
  end
</pre>
<p>
Les routes sont comparées dans l&#8217;ordre où elles ont été définies. La
première route qui correspond à la requête est invoquée.
</p>
<p>
Les masques peuvent inclure des paramètres nommés, accessibles par
l&#8217;intermédiaire du hash <tt>params</tt>:
</p>
<pre>
  get '/bonjour/:nom' do
    # répond aux requêtes &quot;GET /bonjour/foo&quot; et &quot;GET /bonjour/bar&quot;
    # params[:nom] est 'foo' ou 'bar'
    &quot;Bonjour #{params[:nom]}!&quot;
  end
</pre>
<p>
Vous pouvez aussi les nommer directement dans les paramètres du bloc comme
ceci:
</p>
<pre>
  get '/bonjour/:nom' do |n|
    &quot;Bonjour #{n}!&quot;
  end
</pre>
<p>
Une route peut contenir un splat (caractère joker), accessible par
l&#8217;intermédiaire de la liste <tt>params[:splat]</tt>:
</p>
<pre>
  get '/dire/*/a/*' do
    # répondrait à /dire/bonjour/a/monde
    params[:splat] # =&gt; [&quot;bonjour&quot;, &quot;monde&quot;]
  end

  get '/telecharger/*.*' do
    # répondrait à /telecharger/chemin/vers/fichier.xml
    params[:splat] # =&gt; [&quot;chemin/vers/fichier&quot;, &quot;xml&quot;]
  end
</pre>
<p>
Une route peut s&#8217;exprimer avec une Expression Régulière:
</p>
<pre>
  get %r{/bonjour/([\w]+)} do
    &quot;Bonjour, #{params[:captures].first}!&quot;
  end
</pre>
<p>
Là aussi on peut utiliser les paramètres de bloc:
</p>
<pre>
  get %r{/bonjour/([\w]+)} do |c|
    &quot;Bonjour, #{c}!&quot;
  end
</pre>
<a name='Conditions'></a>
<h3>Conditions</h3>
<p>
Les routes peuvent définir toutes sortes de conditions, comme par exemple
le &#8220;user agent&#8221;:
</p>
<pre>
  get '/foo', :agent =&gt; /Songbird (\d\.\d)[\d\/]*?/ do
    &quot;Vous utilisez Songbird version #{params[:agent][0]}&quot;
  end

  get '/foo' do
    # Correspond à tous les autres navigateurs
  end
</pre>
<p>
Les autres conditions disponibles sont <tt>host_name</tt> et
<tt>provides</tt>:
</p>
<pre>
  get '/', :host_name =&gt; /^admin\./ do
    &quot;Zone Administrateur, Accès refusé!&quot;
  end

  get '/', :provides =&gt; 'html' do
    haml :index
  end

  get '/', :provides =&gt; ['rss', 'atom', 'xml'] do
    builder :feed
  end
</pre>
<p>
Vous pouvez facilement définir vos propres conditions:
</p>
<pre>
  set(:probability) { |value| condition { rand &lt;= value } }

  get '/gagner_une_voiture', :probability =&gt; 0.1 do
    &quot;Vous avez gagné!&quot;
  end

  get '/gagner_une_voiture' do
    &quot;Désolé, vous avez perdu.&quot;
  end
</pre>
<a name='Valeurs%20de%20retour'></a>
<h3>Valeurs de retour</h3>
<p>
La valeur de retour d&#8217;un bloc définissant une route détermine le
corps de la réponse qui sera transmise au client HTTP ou du moins au
prochain middleware dans la pile Rack. Le plus généralement, il
s&#8217;agit d&#8217;une chaîne de caractères, comme dans les exemples
précédents. Cependant, d&#8217;autres valeurs sont acceptées.
</p>
<p>
Vous pouvez renvoyer n&#8217;importe quel objet qui soit une réponse Rack
valide, un corps de réponse Rack ou un code retour HTTP:
</p>
<ul>
<li><p>
Un tableau de 3 éléments: <tt>[code retour (Fixnum), entêtes (Hash), corps
de réponse (répondant à #each)]</tt>
</p>
</li>
<li><p>
Un tableau de 2 élements: <tt>[code retour (Fixnum), corps de réponse
(répondant à #each)]</tt>
</p>
</li>
<li><p>
Un objet qui répond à <tt>#each</tt> et qui ne transmet que des chaînes de
caractères au bloc fourni
</p>
</li>
<li><p>
Un Fixnum représentant le code retour
</p>
</li>
</ul>
<p>
Ainsi, on peut facilement implémenter un streaming par exemple :
</p>
<pre>
    class Stream
      def each
        100.times { |i| yield &quot;#{i}\n&quot; }
      end
    end

    get('/') { Stream.new }
</pre>
<a name='Masques%20de%20route%20sp%C3%A9cifiques'></a>
<h3>Masques de route spécifiques</h3>
<p>
Comme montré plus haut, Sinatra embarque le support pour
l&#8217;utilisation de masques utilisant des chaînes de caractères ou des
expressions régulières pour définir les routes. Toutefois, cela ne
s&#8217;arrête pas là. Vous pouvez facilement définir vos propres masques :
</p>
<pre>
  class MasqueToutSauf
    Masque = Struct.new(:captures)

    def initialize(except)
      @except   = except
      @captures = Masque.new([])
    end

    def match(str)
      @caputres unless @except === str
    end
  end

  def tout_sauf(masque)
    MasqueToutSauf.new(masque)
  end

  get tout_sauf(&quot;/index&quot;) do
    # ...
  end
</pre>
<p>
Notez que l&#8217;exemple ci-dessus est bien trop compliqué et le même
résultat peut être obtenu avec :
</p>
<pre>
  get // do
    pass if request.path_info == &quot;/index&quot;
    # ...
  end
</pre>
<p>
Ou bien en utilisant la forme négative :
</p>
<pre>
  get %r{^(?!/index$)} do
    # ...
  end
</pre>
<a name='Fichiers%20statiques'></a>
<h2>Fichiers statiques</h2>
<p>
Par défaut, le dossier <tt>./public</tt> est utilisé pour servir les
fichiers statiques. Vous pouvez changer ce dossier pour un autre nom grâce
au paramètre <tt>:public</tt>:
</p>
<pre>
  set :public, File.dirname(__FILE__) + '/statique'
</pre>
<p>
Notez que le nom du dossier public n&#8217;est pas inclus dans l&#8217;URL.
Un fichier sous <tt>./public/css/style.css</tt> est appelé avec l&#8217;URL
: <tt><a
href="http://exemple.com/css/style.css">exemple.com/css/style.css</a></tt>.
</p>
<a name='Vues%20/%20Templates'></a>
<h2>Vues / Templates</h2>
<p>
Par défaut, les templates sont cherchés dans le dossier <tt>./views</tt>.
Pour utiliser un autre dossier, il faut le déclarer:
</p>
<pre>
  set :views, File.dirname(__FILE__) + '/templates'
</pre>
<p>
Il est important de noter que les templates sont toujours référencés sous
forme de symboles, même s&#8217;il s&#8217;agit d&#8217;un sous-répertoire
(dans ce cas, utilisez <tt>:'sous_repertoire/template'</tt>). Vous devez
utiliser un symbole car les méthodes de rendu évalueront le contenu des
chaînes de caractères au lieu de les considérer comme un chemin vers un
fichier.
</p>
<a name='Templates%20Haml'></a>
<h3>Templates Haml</h3>
<p>
Le gem <tt>haml</tt> est nécessaire pour utiliser la fonction de rendu
Haml:
</p>
<pre>
  # Chargez la bibliothèque haml dans votre application
  require 'haml'

  get '/' do
    haml :index
  end
</pre>
<p>
Utilisera le template: <tt>./views/index.haml</tt>.
</p>
<p>
<a
href="http://haml-lang.com/docs/yardoc/file.HAML_REFERENCE.html#options">Les
options de Haml</a> peuvent se manipuler directement avec la configuration
de Sinatra, voir <a
href="http://www.sinatrarb.com/configuration.html">Options et
Configuration</a>, et supportent aussi la réécriture (surcharge) comme dans
cet exemple.
</p>
<pre>
  set :haml, :format =&gt; :html5 # le format par défaut dans Haml est :xhtml

  get '/' do
    haml :index, :format =&gt; :html4 # surcharge
  end
</pre>
<a name='Templates%20Erb'></a>
<h3>Templates Erb</h3>
<pre>
  # Chargez la bibliothèque erb dans votre application
  require 'erb'

  get '/' do
    erb :index
  end
</pre>
<p>
Utilisera le template: <tt>./views/index.erb</tt>.
</p>
<a name='Templates%20Erubis'></a>
<h3>Templates Erubis</h3>
<p>
Le gem <tt>erubis</tt> est nécessaire pour utiliser la fonction de rendu
erubis:
</p>
<pre>
  # Chargez la bibliothèque erubis dans votre application
  require 'erubis'

  get '/' do
    erubis :index
  end
</pre>
<p>
Utilisera le template: <tt>./views/index.erubis</tt>
</p>
<p>
Il est également possible de remplacer Erb par Erubis:
</p>
<pre>
  require 'erubis'
  Tilt.register :erb, Tilt[:erubis]

  get '/' do
    erb :index
  end
</pre>
<p>
Utilisera le template <tt>./views/index.erb</tt> avec Erubis.
</p>
<a name='Templates%20Builder'></a>
<h3>Templates Builder</h3>
<p>
Le gem <tt>builder</tt> est nécessaire pour utiliser la fonction de rendu
builder:
</p>
<pre>
  # Chargez la bibliothèque builder dans votre application
  require 'builder'

  get '/' do
    builder :index
  end
</pre>
<p>
Utilisera le template: <tt>./views/index.builder</tt>.
</p>
<a name='Templates%20Nokogiri'></a>
<h3>Templates Nokogiri</h3>
<p>
Le gem <tt>nokogiri</tt> est nécessaire pour utiliser la fonction de rendu
nokogiri:
</p>
<pre>
  # Chargez la bibliothèque nokogiri dans votre application
  require 'nokogiri'

  get '/' do
    nokogiri :index
  end
</pre>
<p>
Utilisera le template: <tt>./views/index.nokogiri</tt>.
</p>
<a name='Templates%20Sass'></a>
<h3>Templates Sass</h3>
<p>
Le gem <tt>haml</tt> ou <tt>sass</tt> est nécessaire pour utiliser la
fonction de rendu Sass:
</p>
<pre>
  # Chargez la bibliothèque haml ou sass dans votre application
  require 'sass'

  get '/stylesheet.css' do
    sass :stylesheet
  end
</pre>
<p>
Utilisera le template: <tt>./views/stylesheet.sass</tt>.
</p>
<p>
<a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Les
options de Sass</a> peuvent se manipuler directement avec la configuration
de Sinatra, voir <a
href="http://www.sinatrarb.com/configuration.html">Options et
Configuration</a>, et supportent aussi la réécriture (surcharge) comme dans
cet exemple.
</p>
<pre>
  set :sass, :style =&gt; :compact # le style par défaut dans Sass est :nested

  get '/stylesheet.css' do
    sass :stylesheet, :style =&gt; :expanded # surcharge
  end
</pre>
<a name='Templates%20Scss'></a>
<h3>Templates Scss</h3>
<p>
Le gem <tt>haml</tt> ou <tt>sass</tt> est nécessaire pour utiliser la
fonction de rendu Scss:
</p>
<pre>
  # Chargez la bibliothèque haml ou sass dans votre application
  require 'sass'

  get '/stylesheet.css' do
    scss :stylesheet
  end
</pre>
<p>
Utilisera le template <tt>./views/stylesheet.scss</tt>.
</p>
<p>
<a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Les
options de Scss</a> peuvent se manipuler directement avec la configuration
de Sinatra, voir <a
href="http://www.sinatrarb.com/configuration.html">Options et
Configuration</a>, et supportent aussi la réécriture (surcharge) comme dans
cet exemple.
</p>
<pre>
  set :scss, :style =&gt; :compact # le style par défaut de Scss est :nested

  get '/stylesheet.css' do
    scss :stylesheet, :style =&gt; :expanded # surcharge
  end
</pre>
<a name='Templates%20Less'></a>
<h3>Templates Less</h3>
<p>
Le gem <tt>less</tt> est nécessaire pour utiliser la fonction de rendu
Less:
</p>
<pre>
  # Chargez la bibliothèque less dans votre application
  require 'less'

  get '/stylesheet.css' do
    less :stylesheet
  end
</pre>
<p>
Utilisera le template: <tt>./views/stylesheet.less</tt>.
</p>
<a name='Templates%20Liquid'></a>
<h3>Templates Liquid</h3>
<p>
Le gem <tt>liquid</tt> est nécessaire pour utiliser la fonction de rendu
Liquid:
</p>
<pre>
  # Chargez la bibliothèque liquid dans votre application
  require 'liquid'

  get '/' do
    liquid :index
  end
</pre>
<p>
Utilisera <tt>./views/index.liquid</tt>.
</p>
<p>
Comme vous ne pouvez pas appeler des méthodes Ruby (excepté <tt>yield</tt>)
dans un template Liquid, il sera toujours nécessaire de lui passer des
variables locales:
</p>
<pre>
  liquid :index, :locals =&gt; { :key =&gt; 'value' }
</pre>
<a name='Templates%20Markdown'></a>
<h3>Templates Markdown</h3>
<p>
Le gem <tt>rdiscount</tt> est nécessaire pour utiliser la fonction de rendu
Markdown:
</p>
<pre>
  # Chargez la bibliothèque rdiscount dans votre application
  require &quot;rdiscount&quot;

  get '/' do
    markdown :index
  end
</pre>
<p>
Utilisera <tt>./views/index.markdown</tt> (les extensions de fichier
<tt>md</tt> et <tt>mkd</tt> sont également acceptées).
</p>
<p>
Il n&#8217;est pas possible d&#8217;appeler des méthodes depuis markdown,
ni même de lui passer des variables locales. Par conséquent, il sera le
plus souvent utilisé en combinaison avec un autre moteur de rendu:
</p>
<pre>
  erb :vuedensemble, :locals =&gt; { :texte =&gt; markdown(:introduction) }
</pre>
<p>
Notez que vous pouvez également appeler la méthode <tt>markdown</tt> au
sein d&#8217;autres templates:
</p>
<pre>
  %h1 Bonjour Depuis Haml!
  %p= markdown(:salutations)
</pre>
<p>
Comme vous ne pouvez pas faire d&#8217;appels Ruby au sein de Markdown,
vous ne pouvez pas utiliser des layouts écrits en Markdown. Il est
toutefois possible d&#8217;utiliser un autre moteur de rendu pour le layout
en passant l&#8217;option <tt>:layout_engine</tt> :
</p>
<pre>
  get '/' do
    markdown :index, :layout_engine =&gt; :erb
  end
</pre>
<p>
Ceci utilisera <tt>./views/index.md</tt> avec <tt>./views/layout.erb</tt>
pour layout.
</p>
<p>
Souvenez vous que vous pouvez spécifier de telles options de rendu
globalement :
</p>
<pre>
  set :markdown, :layout_engine =&gt; :haml, :layout =&gt; :post

  get '/' do
    markdown :index
  end
</pre>
<p>
Ceci utilisera <tt>./views/index.md</tt> (et tout autre template Markdown)
avec <tt>./views/post.haml</tt> pour layout.
</p>
<p>
Il est également possible de traduire le Markdown avec BlueCloth plutôt que
RDiscount :
</p>
<pre>
  require 'bluecloth'

  Tilt.register 'markdown', BlueClothTemplate
  Tilt.register 'mkd',      BlueClothTemplate
  Tilt.register 'md',       BlueClothTemplate

  get '/' do
    markdown :index
  end
</pre>
<p>
Utilisera <tt>./views/index.md</tt> avec BlueCloth.
</p>
<a name='Templates%20Textile'></a>
<h3>Templates Textile</h3>
<p>
Le gem <tt>RedCloth</tt> est nécessaire pour utiliser la fonction de rendu
Textile:
</p>
<pre>
  # Chargez la bibliothèqye redcloth dans votre application
  require &quot;redcloth&quot;

  get '/' do
    textile :index
  end
</pre>
<p>
Utilisera <tt>./views/index.textile</tt>.
</p>
<p>
Il n&#8217;est pas possible d&#8217;appeler des méthodes depuis textile, ni
même de lui passer des variables locales. Par conséquent, il sera le plus
souvent utilisé en combinaison avec un autre moteur de rendu:
</p>
<pre>
  erb :vuedensemble, :locals =&gt; { :texte =&gt; textile(:introduction) }
</pre>
<p>
Notez que vous pouvez également appeler la méthode <tt>textile</tt> au sein
d&#8217;autres templates:
</p>
<pre>
  %h1 Bonjour Depuis Haml!
  %p= textile(:salutations)
</pre>
<p>
Comme vous ne pouvez pas faire d&#8217;appels Ruby au sein de Textile, vous
ne pouvez pas utiliser des layouts écrits en Textile. Il est toutefois
possible d&#8217;utiliser un autre moteur de rendu pour le layout en
passant l&#8217;option <tt>:layout_engine</tt> :
</p>
<pre>
  get '/' do
    textile :index, :layout_engine =&gt; :erb
  end
</pre>
<p>
Ceci utilisera <tt>./views/index.textile</tt> avec
<tt>./views/layout.erb</tt> pour layout.
</p>
<p>
Souvenez vous que vous pouvez spécifier de telles options de rendu
globalement :
</p>
<pre>
  set :textile, :layout_engine =&gt; :haml, :layout =&gt; :post

  get '/' do
    textile :index
  end
</pre>
<p>
Ceci utilisera <tt>./views/index.textile</tt> (et tout autre template
Textile) avec <tt>./views/post.haml</tt> pour layout.
</p>
<a name='Templates%20RDoc'></a>
<h3>Templates RDoc</h3>
<p>
Le gem <tt>rdoc</tt> est nécessaire pour utiliser la fonction de rendu
RDoc:
</p>
<pre>
  # Chargez la bibliothèque rdoc/markup/to_html dans votre application
  require &quot;rdoc/markup/to_html&quot;

  get '/' do
    rdoc :index
  end
</pre>
<p>
Utilisera <tt>./views/index.rdoc</tt>.
</p>
<p>
Il n&#8217;est pas possible d&#8217;appeler des méthodes depuis rdoc, ni
même de lui passer des variables locales. Par conséquent, il sera le plus
souvent utilisé en combinaison avec un autre moteur de rendu:
</p>
<pre>
  erb :vuedensemble, :locals =&gt; { :texte =&gt; rdoc(:introduction) }
</pre>
<p>
Notez que vous pouvez également appeler la méthode <tt>rdoc</tt> au sein
d&#8217;autres templates:
</p>
<pre>
  %h1 Bonjour Depuis Haml!
  %p= rdoc(:salutations)
</pre>
<p>
Comme vous ne pouvez pas faire d&#8217;appels Ruby au sein de RDoc, vous ne
pouvez pas utiliser des layouts écrits en RDoc. Il est toutefois possible
d&#8217;utiliser un autre moteur de rendu pour le layout en passant
l&#8217;option <tt>:layout_engine</tt> :
</p>
<pre>
  get '/' do
    rdoc :index, :layout_engine =&gt; :erb
  end
</pre>
<p>
Ceci utilisera <tt>./views/index.rdoc</tt> avec <tt>./views/layout.erb</tt>
pour layout.
</p>
<p>
Souvenez vous que vous pouvez spécifier de telles options de rendu
globalement :
</p>
<pre>
  set :rdoc, :layout_engine =&gt; :haml, :layout =&gt; :post

  get '/' do
    rdoc :index
  end
</pre>
<p>
Ceci utilisera <tt>./views/index.rdoc</tt> (et tout autre template RDoc)
avec <tt>./views/post.haml</tt> pour layout.
</p>
<a name='Templates%20Radius'></a>
<h3>Templates Radius</h3>
<p>
Le gem radius est nécessaire pour utiliser la fonction de rendu Radius:
</p>
<pre>
  # Chargez la bibliothèque radius dans votre application
  require 'radius'

  get '/' do
    radius :index
  end
</pre>
<p>
Utilisera <tt>./views/index.radius</tt>.
</p>
<p>
Comme vous ne pouvez pas appeler des méthodes Ruby (excepté <tt>yield</tt>)
dans un template Radius, il sera toujours nécessaire de lui passer des
variables locales:
</p>
<pre>
  radius :index, :locals =&gt; { :key =&gt; 'value' }
</pre>
<a name='Templates%20Markaby'></a>
<h3>Templates Markaby</h3>
<p>
Le gem markaby est nécessaire pour utiliser la fonction de rendu Markaby:
</p>
<pre>
  # Chargez la bibliothèque markaby dans votre application
  require 'markaby'

  get '/' do
    markaby :index
  end
</pre>
<p>
Utilisera <tt>./views/index.mab</tt>.
</p>
<p>
Vous pouvez également utiliser Markaby en ligne :
</p>
<pre>
  get '/' do
    markaby { h1 &quot;Salut !&quot; }
  end
</pre>
<a name='Templates%20Slim'></a>
<h3>Templates Slim</h3>
<p>
Le gem slim est nécessaire pour utiliser la fonction de rendu Slim:
</p>
<pre>
  # Chargez la bibliothèque slim dans votre application
  require 'slim'

  get '/' do
    slim :index
  end
</pre>
<p>
Utilisera <tt>./views/index.slim</tt>.
</p>
<a name='Templates%20CoffeeScript'></a>
<h3>Templates CoffeeScript</h3>
<p>
Le gem <tt>coffee-script</tt> est nécessaire ainsi que l&#8217;<b>une</b>
des options suivantes permettant l&#8217;exécution de Java script :
</p>
<ul>
<li><p>
<tt>node</tt> (de Node.js) dans votre path
</p>
</li>
<li><p>
vous êtes sous OSX
</p>
</li>
<li><p>
le gem <tt>therubyracer</tt>
</p>
</li>
</ul>
<p>
Voir <a
href="http://github.com/josh/ruby-coffee-script">github.com/josh/ruby-coffee-script</a>
pour une liste à jour d&#8217;options possibles.
</p>
<p>
Maintenant vous pouvez générer des templates CoffeeScript :
</p>
<pre>
  # Chargez la bibliothèque coffee-script dans votre application
  require 'coffee-script'

  get '/application.js' do
    coffee :application
  end
</pre>
<p>
Utilisera <tt>./views/application.coffee</tt>.
</p>
<a name='Templates%20embarqu%C3%A9s'></a>
<h3>Templates embarqués</h3>
<pre>
  get '/' do
    haml '%div.title Bonjour Monde'
  end
</pre>
<p>
Générera le template embarqué spécifié dans la chaîne de caractères.
</p>
<a name='Acc%C3%A9der%20aux%20variables%20dans%20un%20Template'></a>
<h3>Accéder aux variables dans un Template</h3>
<p>
Un template est évalué dans le même contexte que l&#8217;endroit d&#8217;où
il a été appelé (gestionnaire de route). Les variables d&#8217;instance
déclarées dans le gestionnaire de route sont directement accessibles dans
le template:
</p>
<pre>
  get '/:id' do
    @foo = Foo.find(params[:id])
    haml '%h1= @foo.nom'
  end
</pre>
<p>
Alternativement, on peut passer un hash contenant des variables locales:
</p>
<pre>
  get '/:id' do
    foo = Foo.find(params[:id])
    haml '%h1= foo.nom', :locals =&gt; { :foo =&gt; foo }
  end
</pre>
<p>
Ceci est généralement utilisé lorsque l&#8217;on veut utiliser un template
comme partiel (depuis un autre template) et qu&#8217;il est donc nécessaire
d&#8217;adapter les noms de variables.
</p>
<a name='Templates%20dans%20le%20fichier%20source'></a>
<h3>Templates dans le fichier source</h3>
<p>
Des templates peuvent être définis dans le fichier source comme ceci:
</p>
<pre>
  require 'sinatra'

  get '/' do
    haml :index
  end

  __END__

  @@ layout
  %html
    = yield

  @@ index
  %div.title Bonjour Monde!!!!!
</pre>
<p>
NOTE: Les templates du fichier source qui contient <tt>require
'sinatra'</tt> sont automatiquement chargés. Si vous avez des templates
dans d&#8217;autres fichiers source, il faut explicitement les déclarer
via: <tt>enable :inline_templates</tt>.
</p>
<a name='Templates%20nomm%C3%A9s'></a>
<h3>Templates nommés</h3>
<p>
Les templates peuvent aussi être définis grâce à la méthode de haut niveau
<tt>template</tt>:
</p>
<pre>
  template :layout do
    &quot;%html\n  =yield\n&quot;
  end

  template :index do
    '%div.title Bonjour Monde!'
  end

  get '/' do
    haml :index
  end
</pre>
<p>
Si un template nommé &#8220;layout&#8221; existe, il sera utilisé à chaque
fois qu&#8217;un template sera affiché. Vous pouvez désactivez les layouts
au cas par cas en passant <tt>:layout =&gt; false</tt> ou bien les
désactiver par défaut au moyen de <tt>set :haml, :layout =&gt; false</tt>:
</p>
<pre>
  get '/' do
    haml :index, :layout =&gt; !request.xhr?
  end
</pre>
<a name='Associer%20des%20extensions%20de%20fichier'></a>
<h3>Associer des extensions de fichier</h3>
<p>
Pour associer une extension de fichier avec un moteur de rendu, utilisez
<tt>Tilt.register</tt>. Par exemple, si vous désirez utiliser
l&#8217;extension de fichier <tt>tt</tt> pour les templates Textile, vous
pouvez faire comme suit :
</p>
<pre>
  Tilt.register :tt, Tilt[:textile]
</pre>
<a name='Ajouter%20son%20propre%20moteur%20de%20rendu'></a>
<h3>Ajouter son propre moteur de rendu</h3>
<p>
En premier lieu, déclarez votre moteur de rendu avec Tilt, ensuite créez
votre méthode de rendu :
</p>
<pre>
  Tilt.register :monmoteur, MonMerveilleurMoteurDeRendu

  helpers do
    def monmoteur(*args) render(:monmoteur, *args) end
  end

  get '/' do
    monmoteur :index
  end
</pre>
<p>
Utilisera <tt>./views/index.monmoteur</tt>. Voir <a
href="https://github.com/rtomayko/tilt">github.com/rtomayko/tilt</a> pour
en savoir plus sur Tilt.
</p>
<a name='Filtres'></a>
<h2>Filtres</h2>
<p>
Un filtre <tt>before</tt> est évalué avant n&#8217;importe quelle requête,
dans le contexte de celle-ci, et peut modifier la requête ou la réponse.
Les variables d&#8217;instance déclarées dans le filtre sont accessibles au
gestionnaire de route et au template:
</p>
<pre>
  before do
    @note = 'Coucou!'
    request.path_info = '/foo/bar/baz'
  end

  get '/foo/*' do
    @note #=&gt; 'Coucou!'
    params[:splat] #=&gt; 'bar/baz'
  end
</pre>
<p>
Un filtre <tt>after</tt> est évalué après chaque requête, dans le contexte
de celle-ci et peut également modifier la requête et/ou la réponse. Toutes
les variables d&#8217;instance déclarées dans un filtre <tt>before</tt> et
dans le gestionnaire de route sont accessibles dans le filtre
<tt>after</tt>:
</p>
<pre>
  after do
    puts response.status
  end
</pre>
<p>
Note : Sauf si vous utilisez la méthode <tt>body</tt> au lieu de renvoyer
une chaîne de caractères dans vos gestionnaires de routes, le corps de la
réponse ne sera pas disponible dans le filtre <tt>after</tt>, étant donné
qu&#8217;il est généré plus tard.
</p>
<p>
En option, on peut passer un masque au filtre, ce qui le rend actif
uniquement si la requête correspond au masque en question:
</p>
<pre>
  before '/secret/*' do
    authentification!
  end

  after '/faire/:travail' do |travail|
    session[:dernier_travail] = travail
  end
</pre>
<p>
Tout comme les routes, les filtres acceptent également les conditions :
</p>
<pre>
  before :agent =&gt; /Songbird/ do
    # ...
  end

  after '/blog/*', :host_name =&gt; 'example.com' do
    # ...
  end
</pre>
<a name='Helpers'></a>
<h2>Helpers</h2>
<p>
Utilisez la méthode de haut niveau <tt>helpers</tt> pour définir des
routines qui seront accessibles dans vos gestionnaires de route et dans vos
templates :
</p>
<pre>
  helpers do
    def bar(nom)
      &quot;#{nom}bar&quot;
    end
  end

  get '/:nom' do
    bar(params[:nom])
  end
</pre>
<a name='Utiliser%20les%20sessions'></a>
<h3>Utiliser les sessions</h3>
<p>
Une session est utilisé pour conserver un état entre les requêtes. Une fois
activées, vous avez un <tt>hash</tt> de session par session utilisateur :
</p>
<pre>
  enable :sessions

  get '/' do
    &quot;valeur = &quot; &lt;&lt; session[:valeur].inspect
  end

  get '/:value' do
    session[:valeur] = params[:valeur]
  end
</pre>
<p>
Notez que <tt>enable :sessions</tt> enregistre en fait toutes les données
dans un <tt>cookie</tt>. Ce n&#8217;est pas toujours ce que vous voulez
(enregistrer beaucoup de données va augmenter le traffic par exemple). Vous
pouvez utiliser n&#8217;importe quel <tt>middleware</tt> Rack de session
afin d&#8217;éviter cela. N&#8217;utiliser <b>pas</b> <tt>enable
:sessions</tt> dans ce cas mais charger le <tt>middleware</tt> de votre
choix comme vous le feriez pour n&#8217;importe quel autre
<tt>middleware</tt> :
</p>
<pre>
  use Rack::Session::Pool, :expire_after =&gt; 2592000

  get '/' do
    &quot;valeur = &quot; &lt;&lt; session[:valeur].inspect
  end

  get '/:value' do
    session[:valeur] = params[:valeur]
  end
</pre>
<a name='Halt'></a>
<h2>Halt</h2>
<p>
Pour arrêter immédiatement la requête dans un filtre ou un gestionnaire de
route:
</p>
<pre>
  halt
</pre>
<p>
Vous pouvez aussi passer le code retour &#8230;
</p>
<pre>
  halt 410
</pre>
<p>
Ou le texte &#8230;
</p>
<pre>
  halt 'Ceci est le texte'
</pre>
<p>
Ou les deux &#8230;
</p>
<pre>
  halt 401, 'Partez!'
</pre>
<p>
Ainsi que les entêtes &#8230;
</p>
<pre>
  halt 402, {'Content-Type' =&gt; 'text/plain'}, 'revanche'
</pre>
<p>
Bien sûr il est possible de cominer un template avec <tt>halt</tt>:
</p>
<pre>
  halt erb(:erreur)
</pre>
<a name='Passer'></a>
<h2>Passer</h2>
<p>
Une route peut passer le relais aux autres routes qui correspondent
également avec <tt>pass</tt>:
</p>
<pre>
  get '/devine/:qui' do
    pass unless params[:qui] == 'Frank'
    &quot;Tu m'as eu!&quot;
  end

  get '/devine/*' do
    'Manqué!'
  end
</pre>
<p>
On sort donc immédiatement de ce gestionnaire et on continue à chercher,
dans les masques suivants, le prochain qui correspond à la requête. Si
aucun des masques suivants ne correspond, un code 404 est retourné.
</p>
<a name='D%C3%A9clencher%20une%20autre%20route'></a>
<h3>Déclencher une autre route</h3>
<p>
Parfois, <tt>pass</tt> n&#8217;est pas ce que vous recherchez, au lieu de
cela vous souhaitez obtenir le résultat d&#8217;une autre route. Pour cela,
utilisez simplement <tt>call</tt> :
</p>
<pre>
  get '/foo' do
    status, headers, body = call env.merge(&quot;PATH_INFO&quot; =&gt; '/bar')
    [status, headers, body.map(&amp;:upcase)]
  end

  get '/bar' do
    &quot;bar&quot;
  end
</pre>
<p>
Notez que dans l&#8217;exemple ci-dessus, vous faciliterez les tests et
améliorerez la performance en déplaçant simplement <tt>&quot;bar&quot;</tt>
dans un <tt>helper</tt> utilisé à la fois par <tt>/foo</tt> et
<tt>/bar</tt>.
</p>
<p>
Si vous souhiatez que la requête soit envoyée à la même instance de
l&#8217;application plutôt qu&#8217;à une copie, utilisez <tt>call!</tt> au
lieu de <tt>call</tt>.
</p>
<p>
Lisez la spécification Rack si vous souhaitez en savoir plus sur
<tt>call</tt>.
</p>
<a name='D%C3%A9finir%20le%20corps,%20le%20code%20retour%20et%20les%20ent%C3%AAtes'></a>
<h3>Définir le corps, le code retour et les entêtes</h3>
<p>
Il est possible et recommandé de définir le code retour et le corps de la
réponse au moyen de la valeur de retour d&#8217;un bloc définissant une
route. Quoiqu&#8217;il en soit, dans certains cas vous pourriez avoir
besoin de définir le coprs de la réponse à un moment arbitraire de
l&#8217;exécution. Vous pouvez le faire au moyen de la méthode
<tt>body</tt>. Si vous faites ainsi, vous pouvez alors utiliser cette même
méthode pour accéder au corps de la réponse :
</p>
<pre>
  get '/foo' do
    body &quot;bar&quot;
  end

  after do
    puts body
  end
</pre>
<p>
Il est également possible de passer un bloc à <tt>body</tt>, qui sera
exécuté par le gestionnaire Rack (ceci peut être utilisé pour implémenter
un <tt>streaming</tt>, voir &#8220;Valeurs de retour&#8221;).
</p>
<p>
Pareillement au corps de la réponse, vous pouvez également définir le code
retour et les entêtes :
</p>
<pre>
  get '/foo' do
    status 418
    headers \
      &quot;Allow&quot;   =&gt; &quot;BREW, POST, GET, PROPFIND, WHEN&quot;
      &quot;Refresh&quot; =&gt; &quot;Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt&quot;
    body &quot;I'm a tea pot!&quot;
  end
</pre>
<p>
Comme <tt>body</tt>, <tt>headers</tt> et <tt>status</tt> peuvent être
utilisés sans arguments pour accéder à leurs valeurs.
</p>
<a name='Types%20Mime'></a>
<h3>Types Mime</h3>
<p>
Quand vous utilisez <tt>send_file</tt> ou des fichiers statiques, vous
pouvez rencontrer des types mime que Sinatra ne connaît pas. Utilisez
<tt>mime_type</tt> pour les déclarer par extension de fichier :
</p>
<pre>
  mime_type :foo, 'text/foo'
</pre>
<p>
Vous pouvez également les utiliser avec la méthode <tt>content_type</tt> :
</p>
<pre>
  get '/' do
    content_type :foo
    &quot;foo foo foo&quot;
  end
</pre>
<a name='Former%20des%20URLs'></a>
<h3>Former des URLs</h3>
<p>
Pour former des URLs, vous devriez utiliser la méthode <tt>url</tt>, par
exemple en Haml :
</p>
<pre>
  %a{:href =&gt; url('/foo')} foo
</pre>
<p>
Cela prend en compte les proxy inverse et les routeurs Rack, s&#8217;ils
existent.
</p>
<p>
Cette méthode est également disponible sous l&#8217;alias <tt>to</tt> (voir
ci-dessous pour un exemple).
</p>
<a name='Redirection%20du%20navigateur'></a>
<h3>Redirection du navigateur</h3>
<p>
Vous pouvez déclencher une redirection du navigateur avec la méthode
<tt>redirect</tt> :
</p>
<pre>
  get '/foo' do
    redirect to('/bar')
  end
</pre>
<p>
Tout paramètre additionnel est géré comme des arguments pour la méthode
<tt>halt</tt> :
</p>
<pre>
  redirect to('/bar'), 303
  redirect 'http://google.com', 'mauvais endroit mon pote'
</pre>
<p>
Vous pouvez aussi rediriger vers la page dont l&#8217;utilisateur venait au
moyen de <tt>redirect back</tt>:
</p>
<pre>
  get '/foo' do
    &quot;&lt;a href='/bar'&gt;faire quelque chose&lt;/a&gt;&quot;
  end

  get '/bar' do
    faire_quelque_chose
    redirect back
  end
</pre>
<p>
Pour passer des arguments à une redirection, ajoutez-les soit à la requête
:
</p>
<pre>
  redirect to('/bar?sum=42')
</pre>
<p>
Ou bien utilisez une session :
</p>
<pre>
  enable :session

  get '/foo' do
    session[:secret] = 'foo'
    redirect to('/bar')
  end

  get '/bar' do
    session[:secret]
  end
</pre>
<a name='Contr%C3%B4le%20du%20cache'></a>
<h3>Contrôle du cache</h3>
<p>
Définir correctement vos entêtes à la base pour un bon cahce HTTP.
</p>
<p>
Vous pouvez facilement définir l&#8217;entête Cache-Control de la manière
suivante :
</p>
<pre>
  get '/' do
    cache_control :public
    &quot;met le en cache !&quot;
  end
</pre>
<p>
Conseil de pro : définir le cache dans un filtre <tt>before</tt>:
</p>
<pre>
  before do
    cache_control :public, :must_revalidate, :max_age =&gt; 60
  end
</pre>
<p>
Si vous utilisez la méthode <tt>expires</tt> pour définir l&#8217;entête
correspondant, <tt>Cache-Control</tt> sera alors défini automatiquement :
</p>
<pre>
  before do
    expires 500, :public, :must_revalidate
  end
</pre>
<p>
Pour utiliser correctement les caches, vous devriez utiliser <tt>etag</tt>
et <tt>last_modified</tt>. Il est recommandé d&#8217;utiliser ces méthodes
<b>avant</b> de faire d&#8217;important modifications, car elles vont
immédiatement déclencher la réponse si le client a déjà la version courante
dans son cache:
</p>
<pre>
  get '/article/:id' do
    @article = Article.find params[:id]
    last_modified @article.updated_at
    etag @article.sha1
    erb :article
  end
</pre>
<p>
Il est également possible d&#8217;utiliser un <a
href="http://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation">weak
ETag</a>:
</p>
<pre>
  etag @article.sha1, :weak
</pre>
<p>
Ces méthodes ne sont pas chargées de mettre des données en cache, mais
elles fournissent les informations nécessaires pour votre cache. Si vous
êtes à la recherche de solutions rapides de cache, essayez <a
href="http://rtomayko.github.com/rack-cache/">rack-cache</a>:
</p>
<pre>
  require &quot;rack/cache&quot;
  require &quot;sinatra&quot;

  use Rack::Cache

  get '/' do
    cache_control :public, :max_age =&gt; 36000
    sleep 5
    &quot;hello&quot;
  end
</pre>
<a name='Envoyer%20des%20fichiers'></a>
<h3>Envoyer des fichiers</h3>
<p>
Pour envoyer des fichiers, vous pouvez utiliser la méthode
<tt>send_file</tt> :
</p>
<pre>
  get '/' do
    send_file 'foo.png'
  end
</pre>
<p>
Quelques options sont également acceptées :
</p>
<pre>
  send_file 'foo.png', :type =&gt; :jpg
</pre>
<p>
Les options sont :
</p>
<dl>
<dt>filename</dt><dd><p>
le nom du fichier dans la réponse, par défaut le nom du fichier envoyé.
</p>
</dd>
<dt>last_modified</dt><dd><p>
valeur pour l&#8217;entête Last-Modified, par défaut la date de
modification du fichier
</p>
</dd>
<dt>type</dt><dd><p>
type de contenu à utiliser, deviné à partir de l&#8217;extension de fichier
si absent
</p>
</dd>
<dt>disposition</dt><dd><p>
utilisé pour Content-Disposition, les valuers possibles étant :
<tt>nil</tt> (par défaut), <tt>:attachment</tt> et <tt>:inline</tt>
</p>
</dd>
<dt>length</dt><dd><p>
entête Content-Length, par défaut la taille du fichier
</p>
</dd>
</dl>
<p>
Si le gestionnaire Rack le supporte, d&#8217;autres moyens que le
<tt>streaming</tt> via le processus Ruby seront utilisés. Si vous utilisez
cette méthode, Sinatra gérera automatiquement les requêtes de type
<tt>range</tt>.
</p>
<a name='Acc%C3%A9der%20%C3%A0%20l&%238217;objet%20requ%C3%AAte'></a>
<h2>Accéder à l&#8217;objet requête</h2>
<p>
L&#8217;objet correspondant à la requête envoyée peut être récupéré dans le
contexte de la requête (filtres, routes, gestionnaires d&#8217;erreur) au
moyen de la méthode `request`:
</p>
<pre>
  # application tournant à l'adresse http://exemple.com/exemple
  get '/foo' do
    request.body              # corps de la requête envoyée par le client
                              # (voir ci-dessous)
    request.scheme            # &quot;http&quot;
    request.script_name       # &quot;/exemple&quot;
    request.path_info         # &quot;/foo&quot;
    request.port              # 80
    request.request_method    # &quot;GET&quot;
    request.query_string      # &quot;&quot;
    request.content_length    # taille de request.body
    request.media_type        # type de média pour request.body
    request.host              # &quot;exemple.com&quot;
    request.get?              # true (méthodes similaires pour les autres
                              # verbes HTTP)
    request.form_data?        # false
    request[&quot;UN_ENTETE&quot;]      # valeur de l'entête UN_ENTETE
    request.referer           # référant du client ou '/'
    request.user_agent        # user agent (utilisé par la condition :agent)
    request.cookies           # tableau contenant les cookies du navigateur
    request.xhr?              # requête AJAX ?
    request.url               # &quot;http://exemple.com/exemple/foo&quot;
    request.path              # &quot;/exemple/foo&quot;
    request.ip                # adresse IP du client
    request.secure?           # false
    request.forwarded?        # vrai (si on est derrière un proxy inverse)
    request.env               # tableau brut de l'environnement fourni par
                              # Rack
  end
</pre>
<p>
Certaines options, telles que <tt>script_name</tt> ou <tt>path_info</tt>
peuvent également être modifiées:
</p>
<pre>
  before { request.path_info = &quot;/&quot; }

  get &quot;/&quot; do
    &quot;toutes les requêtes arrivent ici&quot;
  end
</pre>
<p>
<tt>request.body</tt> est un objet IO ou StringIO:
</p>
<pre>
  post &quot;/api&quot; do
    request.body.rewind  # au cas où il a déjà été lu
    donnees = JSON.parse request.body.read
    &quot;Bonjour #{donnees['nom']}!&quot;
  end
</pre>
<a name='Fichiers%20joints'></a>
<h3>Fichiers joints</h3>
<p>
Vous pouvez utiliser la méthode <tt>attachment</tt> pour indiquer au
navigateur que la réponse devrait être stockée sur le disque plutôt
qu&#8217;affichée:
</p>
<pre>
  get '/' do
    attachment
    &quot;enregistre-le !&quot;
  end
</pre>
<p>
Vous pouvez également lui passer un nom de fichier :
</p>
<pre>
  get '/' do
    attachment &quot;info.txt&quot;
    &quot;enregistre-le !&quot;
  end
</pre>
<a name='Chercher%20les%20fichiers%20de%20templates'></a>
<h3>Chercher les fichiers de templates</h3>
<p>
La méthode <tt>find_template</tt> est utilisée pour trouver les fichiers de
templates à générer :
</p>
<pre>
  find_template settings.views, 'foo', Tilt[:haml] do |file|
    puts &quot;pourrait être #{file}&quot;
  end
</pre>
<p>
Ce n&#8217;est pas très utilise. En revanche, il est utile de pouvoir
surcharger cette méthode afin de définir son propre mécanisme de recherche.
Par exemple, vous pouvez utiliser plus d&#8217;un répertoire de vues :
</p>
<pre>
  set :views, ['views', 'templates']

  helpers do
    def find_template(views, name, engine, &amp;block)
      Array(views).each { |v| super(v, name, engine, &amp;block) }
    end
  end
</pre>
<p>
Un autre exemple est d&#8217;utiliser des répertoires différents pour des
moteurs de rendu différents :
</p>
<pre>
  set :views, :sass =&gt; 'views/sass', :haml =&gt; 'templates', :default =&gt; 'views'

  helpers do
    def find_template(views, name, engine, &amp;block)
      _, folder = views.detect { |k,v| engine == Tilt[k] }
      folder ||= views[:default]
      super(folder, name, engine, &amp;block)
    end
  end
</pre>
<p>
Vous pouvez également écrire cela dans une extension et la partager avec
d&#8217;autres !
</p>
<p>
Notez que <tt>find_template</tt> ne vérifie pas que le fichier existe mais
va plutôt exécuter le bloc pour tous les chemins possibles. Cela
n&#8217;induit pas un problème de performance dans le sens où
<tt>render</tt> va utiliser <tt>break</tt> dès qu&#8217;un fichier est
trouvé. De plus, l&#8217;emplacement des templates (et leur contenu) est
mis en cache si vous n&#8217;êtes pas en mode développement. Vous devriez
garder cela en tête si vous écrivez une méthode vraiment dingue.
</p>
<a name='Configuration'></a>
<h2>Configuration</h2>
<p>
Lancé une seule fois au démarrage de tous les environnements:
</p>
<pre>
  configure do
    # définir un paramètre
    set :option, 'value'

    # définir plusieurs paramètre
    set :a =&gt; 1, :b =&gt; 2

    # identique à `set :option, true`
    enable :option

    # identique à `set :option, false`
    disable :option

    # vous pouvez également avoir des paramètres dynamiques avec des blocs
    set(:css_dir) { File.join(views, 'css') }
  end
</pre>
<p>
Lancé si l&#8217;environnement (variable d&#8217;environnement RACK_ENV)
est défini comme <tt>:production</tt>:
</p>
<pre>
  configure :production do
    ...
  end
</pre>
<p>
Lancé si l&#8217;environnement est <tt>:production</tt> ou <tt>:test</tt>:
</p>
<pre>
  configure :production, :test do
    ...
  end
</pre>
<p>
Vous pouvez accéder à ces paramètres via <tt>settings</tt> :
</p>
<pre>
  configure do
    set :foo, 'bar'
  end

  get '/' do
    settings.foo? # =&gt; true
    settings.foo  # =&gt; 'bar'
    ...
  end
</pre>
<a name='Param%C3%A8tres%20disponibles'></a>
<h3>Paramètres disponibles</h3>
<dl>
<dt>absolute_redirects</dt><dd><p>
Si désactivé, Sinatra permettra les redirections relatives. Toutefois,
Sinatra ne sera plus conforme à la RFC 2616 (HTTP 1.1), qui
n&#8217;autorise que les redirections absolues.
</p>
<p>
Activez si votre application tourne derrière un proxy inverse qui n&#8217;a
pas été correctement configuré. Notez que la méthode <tt>url</tt>
continuera de produire des URLs absolues, sauf si vous lui passez
<tt>false</tt> comme second argument.
</p>
<p>
Désactivé par défaut.
</p>
</dd>
<dt>add_charsets</dt><dd><p>
types mime pour lesquels la méthode <tt>content_type</tt> va
automatiquement ajouter l&#8217;information du <tt>charset</tt>.
</p>
<p>
Vous devriez lui ajouter des valeurs plutôt que de l&#8217;écraser :
</p>
<pre>
  settings.add_charsets &lt;&lt; &quot;application/foobar&quot;
</pre>
</dd>
<dt>app_file</dt><dd><p>
fichier de l&#8217;application principale, utilisé pour détecterla racine
du projet, le dossier public et le dossier de vues ainsi que pour les
templates en ligne.
</p>
</dd>
<dt>bind</dt><dd><p>
adresse IP sur laquelle se brancher (par défaut: 0.0.0.0). Utiliser
seulement pour le serveur intégré.
</p>
</dd>
<dt>default_encoding</dt><dd><p>
encodage à utiliser si inconnu (par défaut <tt>&quot;utf-8&quot;</tt>).
</p>
</dd>
<dt>dump_errors</dt><dd><p>
afficher les erreurs dans le <tt>log</tt>.
</p>
</dd>
<dt>environment</dt><dd><p>
environnement courant, par défaut <tt>ENV['RACK_ENV']</tt>, ou
<tt>&quot;development&quot;</tt> si absent.
</p>
</dd>
<dt>logging</dt><dd><p>
utiliser le <tt>logger</tt>.
</p>
</dd>
<dt>lock</dt><dd><p>
Place un <tt>lock</tt> autour de chaque requête, n&#8217;exécutant donc
qu&#8217;une seule requête par processus Ruby.
</p>
<p>
Activé si votre application n&#8217;est pas <tt>thread-safe</tt>. Désactivé
par défaut.
</p>
</dd>
<dt>method_override</dt><dd><p>
utilise la magie de <tt>_method</tt> afin de permettre des formulaires
put/delete dans des navigateurs qui ne le permettent pas.
</p>
</dd>
<dt>port</dt><dd><p>
port à écouter. Utiliser seulement pour le serveur intégré.
</p>
</dd>
<dt>prefixed_redirects</dt><dd><p>
si oui ou non <tt>request.script_name</tt> doit être inséré dans les
redirections si un chemin non absolu est utilisé. Ainsi, <tt>redirect
'/foo'</tt> se comportera comme <tt>redirect to('/foo')</tt>. Désactivé par
défaut.
</p>
</dd>
<dt>public</dt><dd><p>
dossier duquel les fichiers publics sont servis
</p>
</dd>
<dt>reload_templates</dt><dd><p>
si oui ou non les templates doivent être rechargés entre les requêtes.
Activé en mode développement et sur Ruby 1.8.6 (pour compenser un bug Ruby
occasionnant une fuite de mémoire).
</p>
</dd>
<dt>root</dt><dd><p>
dossier racine du projet.
</p>
</dd>
<dt>raise_errors</dt><dd><p>
soulever les erreurs (ce qui arrêtera l&#8217;application).
</p>
</dd>
<dt>run</dt><dd><p>
si activé, Sinatra s&#8217;occupera de démarrer le serveur, ne pas activer
si vous utiliser rackup ou autres.
</p>
</dd>
<dt>running</dt><dd><p>
est-ce que le serveur intégré est en marche ? ne changez pas ce paramètre !
</p>
</dd>
<dt>server</dt><dd><p>
serveur ou liste de serveurs à utiliser pour le serveur intégré. Par défaut
[&#8216;thin&#8217;, &#8216;mongrel&#8217;, &#8216;webrick&#8217;],
l&#8217;ordre indiquant la priorité.
</p>
</dd>
<dt>sessions</dt><dd><p>
active l&#8217;enregistrement des sessions en utilisant les cookies.
</p>
</dd>
<dt>show_exceptions</dt><dd><p>
affiche la trace de l&#8217;erreur dans le navigateur.
</p>
</dd>
<dt>static</dt><dd><p>
Si oui ou non Sinatra doit s&#8217;occuper de servir les fichiers
statiques. Désactivez si vous utilisez un serveur capable de le gérer lui
même. Le désactiver augmentera la performance. Activé par défaut.
</p>
</dd>
<dt>views</dt><dd><p>
dossier des vues.
</p>
</dd>
</dl>
<a name='G%C3%A9rer%20les%20erreurs'></a>
<h2>Gérer les erreurs</h2>
<p>
Les gestionnaires d&#8217;erreur s&#8217;exécutent dans le même contexte
que les routes ou les filtres, ce qui veut dire que vous avez accès (entre
autres) aux bons vieux <tt>haml</tt>, <tt>erb</tt>, <tt>halt</tt>, etc.
</p>
<a name='Pas%20Trouv%C3%A9'></a>
<h3>Pas Trouvé</h3>
<p>
Quand une exception <tt>Sinatra::NotFound</tt> est soulevée, ou que le code
retour est 404, le gestionnaire <tt>not_found</tt> est invoqué:
</p>
<pre>
  not_found do
    'Pas moyen de trouver ce que vous cherchez'
  end
</pre>
<a name='Erreur'></a>
<h3>Erreur</h3>
<p>
Le gestionnaire <tt>error</tt> est invoqué à chaque fois qu&#8217;une
exception est soulevée dans une route ou un filtre. L&#8217;objet exception
est accessible via la variable Rack <tt>sinatra.error</tt>:
</p>
<pre>
  error do
    'Désolé mais une méchante erreur est survenue - ' + env['sinatra.error'].name
  end
</pre>
<p>
Erreur sur mesure:
</p>
<pre>
  error MonErreurSurMesure do
    'Donc il est arrivé ceci...' + env['sinatra.error'].message
  end
</pre>
<p>
Donc si ceci arrive:
</p>
<pre>
  get '/' do
    raise MonErreurSurMesure, 'quelque chose de mal'
  end
</pre>
<p>
Vous obtenez ça:
</p>
<pre>
  Donc il est arrivé ceci... quelque chose de mal
</pre>
<p>
Alternativement, vous pouvez avoir un gestionnaire d&#8217;erreur associé à
un code particulier:
</p>
<pre>
  error 403 do
    'Accès interdit'
  end

  get '/secret' do
    403
  end
</pre>
<p>
Ou un intervalle:
</p>
<pre>
  error 400..510 do
    'Boom'
  end
</pre>
<p>
Sinatra installe pour vous quelques gestionnaires <tt>not_found</tt> et
<tt>error</tt> génériques lorsque vous êtes en environnement
<tt>development</tt>.
</p>
<a name='Les%20Middlewares%20Rack'></a>
<h2>Les Middlewares Rack</h2>
<p>
Sinatra tourne avec <a href="http://rack.rubyforge.org/">Rack</a>, une
interface standard et minimale pour les web frameworks Ruby. Un des points
forts de Rack est le support de ce que l&#8217;on appelle des
&#8220;middlewares&#8221; &#8212; composant qui vient se situer entre le
serveur et votre application, et dont le but est de visualiser/manipuler la
requête/réponse HTTP, et d&#8217;offrir diverses fonctionnalités
classiques.
</p>
<p>
Sinatra permet de construire facilement des middlewares Rack via la méthode
de haut niveau <tt>use</tt>:
</p>
<pre>
  require 'sinatra'
  require 'mon_middleware_perso'

  use Rack::Lint
  use MonMiddlewarePerso

  get '/bonjour' do
    'Bonjour Monde'
  end
</pre>
<p>
La sémantique de <tt>use</tt> est identique à celle définie dans le DSL de
<a
href="http://rack.rubyforge.org/doc/classes/Rack/Builder.html">Rack::Builder</a>
(le plus souvent utilisé dans un fichier rackup). Par exemple, la méthode
<tt>use</tt> accepte divers arguments ainsi que des blocs:
</p>
<pre>
  use Rack::Auth::Basic do |login, password|
    login == 'admin' &amp;&amp; password == 'secret'
  end
</pre>
<p>
Rack est distribué avec une bonne variété de middlewares standards pour les
logs, débuguer, faire du routage URL, de l&#8217;authentification, gérer
des sessions. Sinatra utilise beaucoup de ces composants automatiquement
via la configuration, donc pour ceux-ci vous n&#8217;aurez pas à utiliser
la méthode <tt>use</tt>.
</p>
<a name='Tester'></a>
<h2>Tester</h2>
<p>
Les tests pour Sinatra peuvent être écrit avec n&#8217;importe quelle
bibliothèque basée sur Rack. <a
href="http://gitrdoc.com/brynary/rack-test">Rack::Test</a> est recommandé:
</p>
<pre>
  require 'mon_application_sinatra'
  require 'test/unit'
  require 'rack/test'

  class MonTest &lt; Test::Unit::TestCase
    include Rack::Test::Methods

    def app
      Sinatra::Application
    end

    def test_ma_racine
      get '/'
      assert_equal 'Bonjour Monde!', last_response.body
    end

    def test_avec_des_parametres
      get '/rencontrer', :name =&gt; 'Frank'
      assert_equal 'Salut Frank!', last_response.body
    end

    def test_avec_rack_env
      get '/', {}, 'HTTP_USER_AGENT' =&gt; 'Songbird'
      assert_equal &quot;Vous utilisez Songbird!&quot;, last_response.body
    end
  end
</pre>
<p>
NOTE: Le module intégré Sinatra::Test et la classe Sinatra::TestHarness
sont désapprouvés depuis la version 0.9.2 .
</p>
<a name='Sinatra::Base%20-%20Les%20Middlewares,%20les%20Biblioth%C3%A8ques,%20et%20les%20Applications%20Modulaires'></a>
<h2>Sinatra::Base - Les Middlewares, les Bibliothèques, et les Applications Modulaires</h2>
<p>
Définir votre application au niveau supérieur fonctionne bien pour les
micro-applications, mais peut s&#8217;avérer moins pratique lorsqu&#8217;il
s&#8217;agit de créer des composants réutilisables comme des middlewares
Rack, faire du Rails metal, ou de simples bibliothèques avec un composant
serveur, ou même une extension pour Sinatra. Le DSL de haut niveau pollue
l&#8217;espace de noms et est une configuration adaptée à une
micro-application (un fichier unique pour l&#8217;application, les dossiers
./public et ./views, les logs, pages d&#8217;erreur, etc.). C&#8217;est là
que Sinatra::Base entre en jeu:
</p>
<pre>
  require 'sinatra/base'

  class MonApplication &lt; Sinatra::Base
    set :sessions, true
    set :foo, 'bar'

    get '/' do
      'Bonjour Monde!'
    end
  end
</pre>
<p>
Les méthodes disponibles dans Sinatra::Base sont exactement identiques à
celles disponibles dans le DSL de haut niveau. La plupart des applications
de haut niveau peuvent être converties en composant Sinatra::Base avec deux
modifications:
</p>
<ul>
<li><p>
Votre fichier doit charger <tt>sinatra/base</tt> au lieu de
<tt>sinatra</tt>; autrement, toutes les méthodes de la DSL seront chargées
dans l&#8217;espace
</p>
</li>
</ul>
<p>
	de noms.
</p>
<ul>
<li><p>
Mettre vos gestionnaires de route, vos gestionnaires d&#8217;erreur, vos
filtres
</p>
</li>
</ul>
<p>
	et options dans une sous-classe de Sinatra::Base.
</p>
<p>
<tt>Sinatra::Base</tt> est plutôt épuré. La plupart des options sont
désactivées par défaut, ceci inclus le serveur. Voir <a
href="http://sinatra.github.com/configuration.html">Options et
Configuration</a> pour plus de détails sur les options et leur
comportement.
</p>
<a name='Style%20modulaire%20vs.%20style%20classique'></a>
<h3>Style modulaire vs. style classique</h3>
<p>
Contrairement aux croyanaces, le style classique n&#8217;a rien de mauvais.
Si cela convient à votre application, vous n&#8217;avez pas à changer pour
une application modulaire.
</p>
<p>
Il n&#8217;y a que deux inconvénient au style classique comparé au style
modulaire :
</p>
<ul>
<li><p>
Vous ne pouvez avoir qu&#8217;une seule application Sinatra par processus
Ruby. Si vous envisagez d&#8217;en utiliser plus, passez au style modulaire
</p>
</li>
<li><p>
Le style classique pollue  la classe Object avec des méthodes déléguantes.
Si vous prévoyez de diffuser votre application dans une bibliothèque/gem,
passez au style modulaire.
</p>
</li>
</ul>
<p>
Il n&#8217;y pas d&#8217;empêchement à mélanger style classic et style
modulaire.
</p>
<p>
Si vous passez d&#8217;un style à l&#8217;autre, vous devriez être vigilant
à quelques légères différences dans les paramètres :
</p>
<pre>
  Paramètre           Classique                     Modulaire

  app_file            fichier chargeant sinatra     nil
  run                 $0 == app_file                false
  logging             true                          false
  method_override     true                          false
  inline_templates    true                          false
</pre>
<a name='Servir%20une%20application%20modulaire'></a>
<h3>Servir une application modulaire</h3>
<p>
Il y a deux façons de faire pour démarrer une application modulaire,
démarrez avec <tt>run!</tt> :
</p>
<pre>
  # my_app.rb
  require 'sinatra/base'

  class MyApp &lt; Sinatra::Base
    # ... code de l'application ici ...

    # démarre le serveur si ce fichier est directement exécuté
    run! if app_file == $0
  end
</pre>
<p>
Démarrez ensuite avec :
</p>
<pre>
  ruby my_app.rb
</pre>
<p>
Ou alors avec un fichier <tt>config.ru</tt>, qui permet d&#8217;utiliser
n&#8217;importe quel gestionnaire Rack :
</p>
<pre>
  # config.ru
  require 'my_app'
  run MyApp
</pre>
<p>
Exécutez :
</p>
<pre>
  rackup -p 4567
</pre>
<a name='Utiliser%20une%20application%20de%20style%20classique%20avec%20un%20fichier%20config.ru'></a>
<h3>Utiliser une application de style classique avec un fichier config.ru</h3>
<p>
Ecrivez votre application :
</p>
<pre>
  # app.rb
  require 'sinatra'

  get '/' do
    'Hello world!'
  end
</pre>
<p>
Et un fichier <tt>config.ru</tt> correspondant :
</p>
<pre>
  require 'app'
  run Sinatra::Application
</pre>
<a name='Quand%20utiliser%20un%20fichier%20config.ru%20?'></a>
<h3>Quand utiliser un fichier config.ru ?</h3>
<p>
Quelques cas où vous devriez utiliser un fichier <tt>config.ru</tt> :
</p>
<ul>
<li><p>
Vous souhaitez déployer avec un autre gestionnaire Rack (Passenger,
Unicorn, Heroku, &#8230;).
</p>
</li>
<li><p>
Vous souhaitez utiliser plus d&#8217;une sous-classe de
<tt>Sinatra::Base</tt>.
</p>
</li>
<li><p>
Vous voulez utiliser Sinatra comme un <tt>middleware</tt>, non en tant que
<tt>endpoint</tt>.
</p>
</li>
</ul>
<p>
<b>Il n&#8217;est pas nécessaire de passer par un fichier
<tt>config.ru</tt> pour la seule raison que vous êtes passé au style
modulaire, et vous n&#8217;avez pas besoin de passer au style modulaire
pour utiliser un fichier <tt>config.ru</tt>.</b>
</p>
<a name='Utiliser%20Sinatra%20comme%20Middleware'></a>
<h3>Utiliser Sinatra comme Middleware</h3>
<p>
Non seulement Sinatra peut utiliser d&#8217;autres middlewares Rack, il
peut également être à son tour utilisé au-dessus de n&#8217;importe quel
<tt>endpoint</tt> Rack en tant que middleware. Ce <tt>endpoint</tt> peut
très bien être une autre application Sinatra, ou n&#8217;importe quelle
application basée sur Rack (Rails/Ramaze/Camping/&#8230;):
</p>
<pre>
  require 'sinatra/base'

  class EcranDeConnexion &lt; Sinatra::Base
    enable :sessions

    get('/connexion') { haml :connexion }

    post('/connexion') do
      if params[:nom] = 'admin' and params[:motdepasse] = 'admin'
        session['nom_utilisateur'] = params[:nom]
      else
        redirect '/connexion'
      end
    end
  end

  class MonApp &lt; Sinatra::Base
    # le middleware sera appelé avant les filtres
    use EcranDeConnexion

    before do
      unless session['nom_utilisateur']
        halt &quot;Accès refusé, merci de vous &lt;a href='/connexion'&gt;connecter&lt;/a&gt;.&quot;
      end
    end

    get('/') { &quot;Bonjour #{session['nom_utilisateur']}.&quot; }
  end
</pre>
<a name='Contextes%20et%20Binding'></a>
<h2>Contextes et Binding</h2>
<p>
Le contexte dans lequel vous êtes détermine les méthodes et variables
disponibles.
</p>
<a name='Contexte%20de%20l&%238217;application/classe'></a>
<h3>Contexte de l&#8217;application/classe</h3>
<p>
Toute application Sinatra correspond à une sous-classe de Sinatra::Base. Si
vous utilisez le DSL haut niveau (<tt>require 'sinatra'</tt>), alors cette
classe est Sinatra::Application, sinon il s&#8217;agit de la sous-classe
que vous avez définie. Dans le contexte de la classe, vous avez accès aux
méthodes telles que `get` ou `before`, mais vous n&#8217;avez pas accès aux
objets `request` ou `session` car c&#8217;est la même classe
d&#8217;application qui traitera toutes les requêtes.
</p>
<p>
Les options définies au moyen de `set` deviennent des méthodes de classe:
</p>
<pre>
    class MonApp &lt; Sinatra::Base
      # Eh, je suis dans le contexte de l'application!
      set :foo, 42
      foo # =&gt; 42

      get '/foo' do
        # Eh, je ne suis plus dans le contexte de l'application!
      end
    end
</pre>
<p>
Vous avez le binding du contexte de l&#8217;application dans:
</p>
<ul>
<li><p>
Le corps de la classe d&#8217;application
</p>
</li>
<li><p>
Les méthodes définies par les extensions
</p>
</li>
<li><p>
Le bloc passé à `helpers`
</p>
</li>
<li><p>
Les procs/blocs utilisés comme argument pour `set`
</p>
</li>
</ul>
<p>
Vous pouvez atteindre ce contexte (donc la classe) de la façon suivante:
</p>
<ul>
<li><p>
Via l&#8217;objet passé dans les blocs `configure` (<tt>configure { |c| ...
}</tt>)
</p>
</li>
<li><p>
En utilisant `settings` dans le contexte de la requête
</p>
</li>
</ul>
<a name='Contexte%20de%20la%20requ%C3%AAte/instance'></a>
<h3>Contexte de la requête/instance</h3>
<p>
Pour tout traitement d&#8217;une requête, une nouvelle instance de votre
classe d&#8217;application est créée et tous vos gestionnaires sont
exécutés dans ce contexte. Dans ce dernier, vous pouvez accéder aux objets
`request` et `session` et faire appel aux fonctions de rendu telles que
`erb` ou `haml`. Vous pouvez accéder au contexte de l&#8217;application
depuis le contexte de la requête au moyen de `settings`:
</p>
<pre>
  class MonApp &lt; Sinatra::Base
    # Eh, je suis dans le contexte de l'application!
    get '/ajouter_route/:nom' do
      # Contexte de la requête pour '/ajouter_route/:nom'
      @value = 42

      settings.get(&quot;/#{params[:nom]}&quot;) do
        # Contexte de la requête pour &quot;/#{params[:nom]}&quot;
        @value # =&gt; nil (on est pas au sein de la même requête)
      end

      &quot;Route ajoutée!&quot;
    end
  end
</pre>
<p>
Vous avez le binding du contexte de la requête dans:
</p>
<ul>
<li><p>
les blocs get/head/post/put/delete/options
</p>
</li>
<li><p>
les filtres before/after
</p>
</li>
<li><p>
les méthodes utilitaires (définies au moyen de `helpers`)
</p>
</li>
<li><p>
les vues/templates
</p>
</li>
</ul>
<a name='Le%20contexte%20de%20d%C3%A9l%C3%A9gation'></a>
<h3>Le contexte de délégation</h3>
<p>
Le contexte de délégation se contente de transmettre les appels de méthodes
au contexte de classe. Toutefois, il ne se comporte pas à 100% comme le
contexte de classe car vous n&#8217;avez pas le binding de la classe:
seules les méthodes spécifiquement déclarées pour délégation sont
disponibles et il n&#8217;est pas possible de partager des variables/états
avec le contexte de classe (comprenez: `self` n&#8217;est pas le même).
Vous pouvez ajouter des délégation de méthodes en appelant
<tt>Sinatra::Delegator.delegate :method_name</tt>.
</p>
<p>
Vous avez le binding du contexte de délégation dans:
</p>
<ul>
<li><p>
Le binding de haut niveau, si vous avez utilisé <tt>require
&quot;sinatra&quot;</tt>
</p>
</li>
<li><p>
Un objet qui inclut le module `Sinatra::Delegator`
</p>
</li>
</ul>
<p>
Jetez un oeil pour vous faire une idée: voici le mixin <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/base.rb#L1128">Sinatra::Delegator</a>
qui est <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/main.rb#L28">inclus
dans l'espace de noms principal</a>
</p>
<a name='Ligne%20de%20commande'></a>
<h2>Ligne de commande</h2>
<p>
Les applications en Sinatra peuvent être lancées directement:
</p>
<pre>
  ruby mon_application.rb [-h] [-x] [-e ENVIRONNEMENT] [-p PORT] [-o HOTE] [-s SERVEUR]
</pre>
<p>
Les options sont:
</p>
<pre>
  -h # aide
  -p # déclare le port (4567 par défaut)
  -o # déclare l'hôte (0.0.0.0 par défaut)
  -e # déclare l'environnement (+development+ par défaut)
  -s # déclare le serveur/gestionnaire à utiliser (thin par défaut)
  -x # active le mutex lock (off par défaut)
</pre>
<a name='Configuration%20n%C3%A9cessaire'></a>
<h2>Configuration nécessaire</h2>
<p>
Il est recommandé d&#8217;installer Sinatra sur Ruby 1.8.7, 1.9.2, JRuby ou
Rubinius.
</p>
<p>
Les versions suivantes de Ruby sont officiellement supportées :
</p>
<dl>
<dt> Ruby 1.8.6 </dt><dd><p>
Il n&#8217;est pas recommandé d&#8217;utiliser 1.8.6 pour Sinatra.
Toutefois, ce sera officiellement supporté jusqu&#8217;à l&#8217;arrivée
Sinatra 1.3.0. Les templates RDoc et CoffeeScript ne sont pas supportés par
cette version de Ruby. 1.8.6 contient un défaut majeur de fuite de mémoire
dans l&#8217;implémentation de Hash, qui est déclenché par les versions de
Sinatra antérieure à 1.1.1. La version actuelle prévient explicitement ce
risque au prix de la performance. Vous devrez utiliser Rack 1.1.x dans la
mesure où Rack >= 1.2 ne supporte plus 1.8.6.
</p>
</dd>
<dt> Ruby 1.8.7 </dt><dd><p>
1.8.7 est complètement supporté, toutefois si rien ne vous y retient, nous
vous recommandons de passer à 1.9.2 ou bien de passer à JRuby ou Rubinius.
</p>
</dd>
<dt> Ruby 1.9.2 </dt><dd><p>
1.9.2 est supporté et recommandé. Notez que Radius et Markaby ne sont
actuellement pas compatible avec 1.9. N&#8217;utilisez pas 1.9.2p0 qui est
réputé causer des erreurs de segmentation lorque Sinatra est utilisé.
</p>
</dd>
<dt> Rubinius </dt><dd><p>
Rubinius est officiellement supporté (Rubinius >= 1.2.2), à
l&#8217;exception des templates Textile.
</p>
</dd>
<dt> JRuby </dt><dd><p>
JRuby est officiellement supporté (JRuby >= 1.5.6). Aucune anomalie avec
des bibliothèques de templates tierces ne sont connues. Toutefois, si vous
choisissez JRuby, alors tournez vous vers des gestionnaires Rack JRuby car
le serveur Thin n&#8217;est pas (encore) supporté par JRuby.
</p>
</dd>
</dl>
<p>
Nous gardons également un oeil sur les versions Ruby à venir.
</p>
<p>
Les implémentations Ruby suivantes ne sont pas officiellement supportées
mais sont toujours connues comme permettant à Sinatra de fonctionner :
</p>
<ul>
<li><p>
Plus anciennes versions de JRuby et Rubinius
</p>
</li>
<li><p>
MacRuby
</p>
</li>
<li><p>
Maglev
</p>
</li>
<li><p>
IronRuby
</p>
</li>
<li><p>
Ruby 1.9.0 et 1.9.1
</p>
</li>
</ul>
<p>
Ne pas être officiellement supporté signifie que si les choses se passent
mal sur ces plateformes et non sur celles supportées, nous considérons que
l&#8217;anomalie est de le ressort, pas du nôtre.
</p>
<p>
Sinatra devrait fonctionner sur n&#8217;importe quel système
d&#8217;exploitation supportant l&#8217;implémentation Ruby choisie.
</p>
<a name='Essuyer%20les%20pl%C3%A2tres'></a>
<h2>Essuyer les plâtres</h2>
<p>
Si vous voulez utiliser la toute dernière version de Sinatra, n&#8217;ayez
pas peur de faire tourner votre application sur la branche master, cela
devrait être stable.
</p>
<p>
Nous publions également une gem de <tt>prerelease</tt> de temps en temps
donc vous pouvez faire la chose suivante :
</p>
<pre>
  gem install sinatra --pre
</pre>
<p>
afin d&#8217;avoir certaines des toutes dernières fonctionnalités.
</p>
<a name='Avec%20Bundler'></a>
<h3>Avec Bundler</h3>
<p>
Si vous voulez faire tourner votre application avec le tout dernier
Sinatra, <a href="http://gembundler.com/">Bundler</a> est recommandé.
</p>
<p>
Tout d&#8217;abord, installer bundler si vous ne l&#8217;avez pas :
</p>
<pre>
  gem install bundler
</pre>
<p>
Ensuite, dans le dossier de votre projet, créez un fichier <tt>Gemfile</tt>
:
</p>
<pre>
  source :rubygems
  gem 'sinatra', :git =&gt; &quot;git://github.com/sinatra/sinatra.git&quot;

  # autres dépendances
  gem 'haml'                    # par exemple, si vous utilisez haml
  gem 'activerecord', '~&gt; 3.0'  # peut-être que vous avez également besoin
                                # de ActiveRecord 3.x
</pre>
<p>
Notez que vous aurez à lister toutes les dépendances de votre application
dans ce fichier. Les dépendances directes de Sinatra (Rack et Tilt) seront
automatiquement téléchargées et ajoutées par Bundler.
</p>
<p>
Maintenant, vous pouvez faire tourner votre application de la façon
suivante :
</p>
<pre>
  bundle exec ruby myapp.rb
</pre>
<a name='Faites%20le%20vous-m%C3%AAme'></a>
<h3>Faites le vous-même</h3>
<p>
Créez un clone local et démarrez votre application avec le dossier
<tt>sinatra/lib</tt> dans le <tt>$LOAD_PATH</tt> :
</p>
<pre>
  cd myapp
  git clone git://github.com/sinatra/sinatra.git
  ruby -Isinatra/lib myapp.rb
</pre>
<p>
A l&#8217;avenir, pour mettre à jour le code source de Sinatra :
</p>
<pre>
  cd myapp/sinatra
  git pull
</pre>
<a name='Installez%20globalement'></a>
<h3>Installez globalement</h3>
<p>
Vous pouvez construire la gem vous-même :
</p>
<pre>
  git clone git://github.com/sinatra/sinatra.git
  cd sinatra
  rake sinatra.gemspec
  rake install
</pre>
<p>
Si vous installez les gems en tant que <tt>root</tt>, la dernière étape
sera :
</p>
<pre>
  sudo rake install
</pre>
<a name='Versions'></a>
<h2>Versions</h2>
<p>
Sinatra se conforme aux <a href="http://semver.org/">versions
sémantiques</a>, aussi bien SemVer que SemVerTag.
</p>
<a name='Mais%20encore'></a>
<h2>Mais encore</h2>
<ul>
<li><p>
<a href="http://www.sinatrarb.com/">Site internet</a> - Plus de
documentation, de news, et des liens vers d&#8217;autres ressources.
</p>
</li>
<li><p>
<a href="http://www.sinatrarb.com/contributing">Contribuer</a> - Vous avez
trouvé un bug? Besoin d&#8217;aide? Vous avez un patch?
</p>
</li>
<li><p>
<a href="http://github.com/sinatra/sinatra/issues">Suivi des problèmes</a>
</p>
</li>
<li><p>
<a href="http://twitter.com/sinatra">Twitter</a>
</p>
</li>
<li><p>
<a href="http://groups.google.com/group/sinatrarb/topics">Mailing List</a>
</p>
</li>
<li><p>
<a href="irc://chat.freenode.net/#sinatra">IRC: #sinatra</a> sur <a
href="http://freenode.net">freenode.net</a>
</p>
</li>
</ul>
