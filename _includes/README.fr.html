<div class='toc'>
	<ol class='level-1'>
		<li><a href='#Routes'>Routes</a></li>
		<ol class='level-2'>
			<li><a href='#Conditions'>Conditions</a></li>
			<li><a href='#Valeurs%20de%20retour'>Valeurs de retour</a></li>
			<li><a href='#Masques%20de%20route%20sp&eacute;cifiques'>Masques de route sp&eacute;cifiques</a></li>
		</ol>
		<li><a href='#Fichiers%20statiques'>Fichiers statiques</a></li>
		<li><a href='#Vues%20/%20Templates'>Vues / Templates</a></li>
		<ol class='level-2'>
			<li><a href='#Langages%20de%20template%20disponibles'>Langages de template disponibles</a></li>
			<li><a href='#Templates%20Haml'>Templates Haml</a></li>
			<li><a href='#Templates%20Erb'>Templates Erb</a></li>
			<li><a href='#Templates%20Builder'>Templates Builder</a></li>
			<li><a href='#Templates%20Nokogiri'>Templates Nokogiri</a></li>
			<li><a href='#Templates%20Sass'>Templates Sass</a></li>
			<li><a href='#Templates%20SCSS'>Templates SCSS</a></li>
			<li><a href='#Templates%20Less'>Templates Less</a></li>
			<li><a href='#Templates%20Liquid'>Templates Liquid</a></li>
			<li><a href='#Templates%20Markdown'>Templates Markdown</a></li>
			<li><a href='#Templates%20Textile'>Templates Textile</a></li>
			<li><a href='#Templates%20RDoc'>Templates RDoc</a></li>
			<li><a href='#Templates%20Radius'>Templates Radius</a></li>
			<li><a href='#Templates%20Markaby'>Templates Markaby</a></li>
			<li><a href='#Templates%20RABL'>Templates RABL</a></li>
			<li><a href='#Templates%20Slim'>Templates Slim</a></li>
			<li><a href='#Templates%20Creole'>Templates Creole</a></li>
			<li><a href='#Templates%20CoffeeScript'>Templates CoffeeScript</a></li>
			<li><a href='#Templates%20Yajl'>Templates Yajl</a></li>
			<li><a href='#Templates%20WLang'>Templates WLang</a></li>
			<li><a href='#Templates%20embarqu&eacute;s'>Templates embarqu&eacute;s</a></li>
			<li><a href='#Acc&eacute;der%20aux%20variables%20dans%20un%20Template'>Acc&eacute;der aux variables dans un Template</a></li>
			<li><a href='#Templates%20dans%20le%20fichier%20source'>Templates dans le fichier source</a></li>
			<li><a href='#Templates%20nomm&eacute;s'>Templates nomm&eacute;s</a></li>
			<li><a href='#Associer%20des%20extensions%20de%20fichier'>Associer des extensions de fichier</a></li>
			<li><a href='#Ajouter%20son%20propre%20moteur%20de%20rendu'>Ajouter son propre moteur de rendu</a></li>
		</ol>
		<li><a href='#Filtres'>Filtres</a></li>
		<li><a href='#Helpers'>Helpers</a></li>
		<ol class='level-2'>
			<li><a href='#Utiliser%20les%20sessions'>Utiliser les sessions</a></li>
			<li><a href='#Halt'>Halt</a></li>
			<li><a href='#Passer'>Passer</a></li>
			<li><a href='#D&eacute;clencher%20une%20autre%20route'>D&eacute;clencher une autre route</a></li>
			<li><a href='#D&eacute;finir%20le%20corps,%20le%20code%20retour%20et%20les%20ent&ecirc;tes'>D&eacute;finir le corps, le code retour et les ent&ecirc;tes</a></li>
			<li><a href='#Faire%20du%20streaming'>Faire du streaming</a></li>
			<li><a href='#Journalisation%20(Logging)'>Journalisation (Logging)</a></li>
			<li><a href='#Types%20Mime'>Types Mime</a></li>
			<li><a href='#Former%20des%20URLs'>Former des URLs</a></li>
			<li><a href='#Redirection%20du%20navigateur'>Redirection du navigateur</a></li>
			<li><a href='#Contr&ocirc;le%20du%20cache'>Contr&ocirc;le du cache</a></li>
			<li><a href='#Envoyer%20des%20fichiers'>Envoyer des fichiers</a></li>
			<li><a href='#Acc&eacute;der%20&agrave;%20l'objet%20requ&ecirc;te'>Acc&eacute;der &agrave; l'objet requ&ecirc;te</a></li>
			<li><a href='#Fichiers%20joints'>Fichiers joints</a></li>
			<li><a href='#G&eacute;rer%20Date%20et%20Time'>G&eacute;rer Date et Time</a></li>
			<li><a href='#Chercher%20les%20fichiers%20de%20templates'>Chercher les fichiers de templates</a></li>
		</ol>
		<li><a href='#Configuration'>Configuration</a></li>
		<ol class='level-2'>
			<li><a href='#Se%20prot&eacute;ger%20des%20attaques'>Se prot&eacute;ger des attaques</a></li>
			<li><a href='#Param&egrave;tres%20disponibles'>Param&egrave;tres disponibles</a></li>
		</ol>
		<li><a href='#Environements'>Environements</a></li>
		<li><a href='#G&eacute;rer%20les%20erreurs'>G&eacute;rer les erreurs</a></li>
		<ol class='level-2'>
			<li><a href='#NotFound'>NotFound</a></li>
			<li><a href='#Error'>Error</a></li>
		</ol>
		<li><a href='#Les%20Middlewares%20Rack'>Les Middlewares Rack</a></li>
		<li><a href='#Tester'>Tester</a></li>
		<li><a href='#Sinatra::Base%20-%20Les%20Middlewares,%20Biblioth&egrave;ques,%20et%20Applications%20Modulaires'>Sinatra::Base - Les Middlewares, Biblioth&egrave;ques, et Applications Modulaires</a></li>
		<ol class='level-2'>
			<li><a href='#Style%20modulaire%20vs.%20style%20classique'>Style modulaire vs. style classique</a></li>
			<li><a href='#Servir%20une%20application%20modulaire'>Servir une application modulaire</a></li>
			<li><a href='#Utiliser%20une%20application%20de%20style%20classique%20avec%20un%20fichier%20config.ru'>Utiliser une application de style classique avec un fichier config.ru</a></li>
			<li><a href='#Quand%20utiliser%20un%20fichier%20config.ru%20?'>Quand utiliser un fichier config.ru ?</a></li>
			<li><a href='#Utiliser%20Sinatra%20comme%20Middleware'>Utiliser Sinatra comme Middleware</a></li>
			<li><a href='#Cr&eacute;ation%20dynamique%20d'applications'>Cr&eacute;ation dynamique d'applications</a></li>
		</ol>
		<li><a href='#Contextes%20et%20Binding'>Contextes et Binding</a></li>
		<ol class='level-2'>
			<li><a href='#Contexte%20de%20l'application/classe'>Contexte de l'application/classe</a></li>
			<li><a href='#Contexte%20de%20la%20requ&ecirc;te/instance'>Contexte de la requ&ecirc;te/instance</a></li>
			<li><a href='#Le%20contexte%20de%20d&eacute;l&eacute;gation'>Le contexte de d&eacute;l&eacute;gation</a></li>
		</ol>
		<li><a href='#Ligne%20de%20commande'>Ligne de commande</a></li>
		<li><a href='#Configuration%20n&eacute;cessaire'>Configuration n&eacute;cessaire</a></li>
		<li><a href='#Essuyer%20les%20pl&acirc;tres'>Essuyer les pl&acirc;tres</a></li>
		<ol class='level-2'>
			<li><a href='#Avec%20Bundler'>Avec Bundler</a></li>
			<li><a href='#Faites%20le%20vous-m&ecirc;me'>Faites le vous-m&ecirc;me</a></li>
			<li><a href='#Installez%20globalement'>Installez globalement</a></li>
		</ol>
		<li><a href='#Versions'>Versions</a></li>
		<li><a href='#Mais%20encore'>Mais encore</a></li>
	</ol>
</div>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>

<p><em>Attention : Ce document correspond &agrave; la traduction de la version anglaise et
il n'est peut &ecirc;tre plus &agrave; jour.</em></p>

<p>Sinatra est un <a href="http://fr.wikipedia.org/wiki/Langage_d%C3%A9di%C3%A9">DSL</a> pour
cr&eacute;er rapidement et facilement des applications web en Ruby :</p>

<pre><code class="ruby"># mon_application.rb
require 'sinatra'

get '/' do
  'Bonjour le monde !'
end
</code></pre>

<p>Installez la gem et lancez avec :</p>

<pre><code class="bash">$ gem install sinatra
$ ruby mon_application.rb
</code></pre>

<p>Le r&eacute;sultat est visible sur : http://localhost:4567</p>

<p>Il est recommand&eacute; d'ex&eacute;cuter &eacute;galement <code>gem install thin</code>, pour que
Sinatra utilise le server Thin quand il est disponible.</p>

<a name='Routes'></a>
<h2>Routes</h2>

<p>Dans Sinatra, une route est une m&eacute;thode HTTP coupl&eacute;e &agrave; un masque (pattern)
URL. Chaque route est associ&eacute;e &agrave; un bloc :</p>

<pre><code class="ruby">get '/' do
  .. montrer quelque chose ..
end

post '/' do
  .. cr&eacute;er quelque chose ..
end

put '/' do
  .. remplacer quelque chose ..
end

patch '/' do
  .. changer quelque chose ..
end

delete '/' do
  .. effacer quelque chose ..
end

options '/' do
  .. apaiser quelquechose ..
end
</code></pre>

<p>Les routes sont &eacute;valu&eacute;es  dans l'ordre o&ugrave; elles ont &eacute;t&eacute; d&eacute;finies. La premi&egrave;re
route qui correspond &agrave; la requ&ecirc;te est appel&eacute;e.</p>

<p>Les masques peuvent inclure des param&egrave;tres nomm&eacute;s, accessibles par
l'interm&eacute;diaire du hash <code>params</code> :</p>

<pre><code class="ruby">get '/bonjour/:nom' do
  # r&eacute;pond aux requ&ecirc;tes "GET /bonjour/foo" et "GET /bonjour/bar"
  # params[:nom] est 'foo' ou 'bar'
  "Bonjour #{params[:nom]} !"
end
</code></pre>

<p>Vous pouvez aussi acc&eacute;der aux param&egrave;tres nomm&eacute;s directement gr&acirc;ce aux
param&egrave;tres du bloc comme ceci :</p>

<pre><code class="ruby">get '/bonjour/:nom' do |n|
  "Bonjour #{n} !"
end
</code></pre>

<p>Une route peut contenir un splat (caract&egrave;re joker), accessible par
l'interm&eacute;diaire du tableau <code>params[:splat]</code> :</p>

<pre><code class="ruby">get '/dire/*/a/*' do
  # r&eacute;pond &agrave; /dire/bonjour/a/monde
  params[:splat] # =&gt; ["bonjour", "monde"]
end

get '/telecharger/*.*' do
  # r&eacute;pond &agrave; /telecharger/chemin/vers/fichier.xml
  params[:splat] # =&gt; ["chemin/vers/fichier", "xml"]
end
</code></pre>

<p>Ou par l'interm&eacute;diaire des param&egrave;tres du bloc :</p>

<pre><code class="ruby">get '/telecharger/*.*' do |chemin, ext|
  [chemin, ext] # =&gt; ["path/to/file", "xml"]
end
</code></pre>

<p>Une route peut aussi &ecirc;tre d&eacute;finie par une expression r&eacute;guli&egrave;re :</p>

<pre><code class="ruby">get %r{/bonjour/([\w]+)} do
  "Bonjour, #{params[:captures].first} !"
end
</code></pre>

<p>L&agrave; encore on peut utiliser les param&egrave;tres de bloc :</p>

<pre><code class="ruby">get %r{/bonjour/([\w]+)} do |c|
  "Bonjour, #{c} !"
end
</code></pre>

<p>Les routes peuvent aussi comporter des param&egrave;tres optionnels :</p>

<pre><code class="ruby">get '/posts.?:format?' do
  # r&eacute;pond &agrave; "GET /posts" et aussi &agrave; "GET /posts.json", "GET /posts.xml" etc...
end
</code></pre>

<p>A ce propos, &agrave; moins d'avoir d&eacute;sactiv&eacute; la protection contre les attaques par
"path transversal" (voir plus loin), l'URL demand&eacute;e peut avoir &eacute;t&eacute; modifi&eacute;e
avant d'&ecirc;tre compar&eacute;e &agrave; vos routes.</p>

<a name='Conditions'></a>
<h3>Conditions</h3>

<p>Les routes peuvent d&eacute;finir toutes sortes de conditions, comme par exemple le
"user agent" :</p>

<pre><code class="ruby">get '/foo', :agent =&gt; /Songbird (\d\.\d)[\d\/]*?/ do
  "Vous utilisez Songbird version #{params[:agent][0]}"
end

get '/foo' do
  # Correspond &agrave; tous les autres navigateurs
end
</code></pre>

<p>Les autres conditions disponibles sont <code>host_name</code> et <code>provides</code> :</p>

<pre><code class="ruby">get '/', :host_name =&gt; /^admin\./ do
  "Zone Administrateur, Acc&egrave;s refus&eacute; !"
end

get '/', :provides =&gt; 'html' do
  haml :index
end

get '/', :provides =&gt; ['rss', 'atom', 'xml'] do
  builder :feed
end
</code></pre>

<p>Vous pouvez facilement d&eacute;finir vos propres conditions :</p>

<pre><code class="ruby">set(:probability) { |value| condition { rand &lt;= value } }

get '/gagner_une_voiture', :probability =&gt; 0.1 do
  "Vous avez gagn&eacute; !"
end

get '/gagner_une_voiture' do
  "D&eacute;sol&eacute;, vous avez perdu."
end
</code></pre>

<p>Utilisez un splat (caract&egrave;re joker) dans le cas d'une condition qui prend
plusieurs valeurs :</p>

<pre><code class="ruby">set(:auth) do |*roles|   # &lt;- ici on utilise un splat
  condition do
    unless logged_in? &amp;&amp; roles.any? {|role| current_user.in_role? role }
      redirect "/login/", 303
    end
  end
end

get "/mon/compte/", :auth =&gt; [:user, :admin] do
  "Informations sur votre compte"
end

get "/reserve/aux/admins/", :auth =&gt; :admin do
  "Seuls les administrateurs sont accept&eacute;s ici !"
end
</code></pre>

<a name='Valeurs%20de%20retour'></a>
<h3>Valeurs de retour</h3>

<p>La valeur renvoy&eacute;e par le bloc correspondant &agrave; une route constitue le corps de
la r&eacute;ponse qui sera transmise au client HTTP ou du moins au prochain middleware
dans la pile Rack. Le plus souvent, il s'agit d'une cha&icirc;ne de caract&egrave;res,
comme dans les exemples pr&eacute;c&eacute;dents. Cependant, d'autres valeurs sont
accept&eacute;es.</p>

<p>Vous pouvez renvoyer n'importe quel objet qu'il s'agisse d'une r&eacute;ponse Rack
valide, d'un corps de r&eacute;ponse Rack ou d'un code statut HTTP :</p>

<p>Avec cela, on peut facilement impl&eacute;menter un streaming par exemple :</p>

<pre><code class="ruby">class Stream
  def each
    100.times { |i| yield "#{i}\n" }
  end
end

get('/') { Stream.new }
</code></pre>

<p>Vous pouvez aussi utiliser le helper <code>stream</code> (pr&eacute;sent&eacute; un peu plus loin) pour
&eacute;viter la surcharge et int&eacute;grer le traitement relatif au streaming dans le bloc
de code de la route.</p>

<a name='Masques%20de%20route%20sp&eacute;cifiques'></a>
<h3>Masques de route sp&eacute;cifiques</h3>

<p>Comme cela a &eacute;t&eacute; vu auparavant, Sinatra offre la possibilit&eacute; d'utiliser des
masques sous forme de chaines de caract&egrave;res ou des expressions r&eacute;guli&egrave;res
pour d&eacute;finir les routes. Mais il est possible de faire bien plus. Vous pouvez
facilement d&eacute;finir vos propres masques :</p>

<pre><code class="ruby">class MasqueToutSauf
  Masque = Struct.new(:captures)

  def initialize(except)
    @except   = except
    @captures = Masque.new([])
  end

  def match(str)
    @caputres unless @except === str
  end
end

def tout_sauf(masque)
  MasqueToutSauf.new(masque)
end

get tout_sauf("/index") do
  # ...
end
</code></pre>

<p>Notez que l'exemple ci-dessus est bien trop compliqu&eacute; et que le m&ecirc;me r&eacute;sultat
peut &ecirc;tre obtenu avec :</p>

<pre><code class="ruby">get // do
  pass if request.path_info == "/index"
  # ...
end
</code></pre>

<p>Ou bien en utilisant la forme n&eacute;gative :</p>

<pre><code class="ruby">get %r{^(?!/index$)} do
  # ...
end
</code></pre>

<a name='Fichiers%20statiques'></a>
<h2>Fichiers statiques</h2>

<p>Les fichiers du dossier <code>./public</code> sont servis de fa&ccedil;on statique. Vous
avez la possibilit&eacute; d'utiliser un autre r&eacute;pertoire en d&eacute;finissant le param&egrave;tre
<code>:public_folder</code> :</p>

<pre><code class="ruby">set :public_folder, File.dirname(__FILE__) + '/statique'
</code></pre>

<p>Notez que le nom du dossier public n'apparait pas dans l'URL. Le fichier
<code>./public/css/style.css</code> sera appel&eacute; via l'URL :
<code>http://exemple.com/css/style.css</code>.</p>

<p>Utilisez le param&egrave;tre <code>:static_cache_control</code> pour ajouter l'information
d'en-t&ecirc;te <tt>Cache-Control</tt> (voir plus loin).</p>

<a name='Vues%20/%20Templates'></a>
<h2>Vues / Templates</h2>

<p>Chaqie langage de template est disponible via sa propre m&eacute;thode de rendu,
lesquelles renvoient tout simplement une cha&icirc;ne de caract&egrave;res.</p>

<pre><code class="ruby">get '/' do
  erb :index
end
</code></pre>

<p>Ceci effectue le rendu de la vue <code>views/index.erb</code>.</p>

<p>Plut&ocirc;t que d'utiliser le nom d'un template, vous pouvez directement passer
le contenu du template :</p>

<pre><code class="ruby">get '/' do
  code = "&lt;%= Time.now %&gt;"
  erb code
end
</code></pre>

<p>Les m&eacute;thodes de templates acceptent un second param&egrave;tre, un hash d'options :</p>

<pre><code class="ruby">get '/' do
  erb :index, :layout =&gt; :post
end
</code></pre>

<p>Ceci effectuera le rendu de la vue <code>views/index.erb</code> en l'int&eacute;grant
au <em>layout</em> <code>views/post.erb</code> (les vues Erb sont int&eacute;gr&eacute;es par d&eacute;faut
au <em>layout</em> <code>views/layout.erb</code> quand ce fichier existe).</p>

<p>Toute option que Sinatra ne comprend pas sera pass&eacute;e au moteur de rendu :</p>

<pre><code class="ruby">get '/' do
  haml :index, :format =&gt; :html5
end
</code></pre>

<p>Vous pouvez &eacute;galement d&eacute;finir des options par langage de template de fa&ccedil;on
g&eacute;n&eacute;rale :</p>

<pre><code class="ruby">set :haml, :format =&gt; html5

get '/' do
  haml :index
end
</code></pre>

<p>Les options pass&eacute;es &agrave; la m&eacute;thode de rendu prennent le pas sur les options
d&eacute;finies au moyen de <code>set</code>.</p>

<p>Options disponibles :</p>

<p><strong>locals</strong>
  Liste de variables locales pass&eacute;es au document. Pratique pour les vues
  partielles.
  Exemple : <code>erb "&lt;%= foo %&gt;", :locals =&gt; {:foo =&gt; "bar"}</code>.</p>

<p><strong>default_encoding</strong>
  Encodage de caract&egrave;res &agrave; utiliser en cas d'incertitude. Par d&eacute;faut, c'est
  <code>settings.default_encoding</code>.</p>

<p><strong>views</strong>
  Dossier de vues dans lequel chercher les templates. Par d&eacute;faut
  <code>settings.views</code>.</p>

<p><strong>layout</strong>
  S'il faut ou non utiliser un +layout+ (+true+ or +false+). Indique le
  template &agrave; utiliser lorsque c'est un symbole. Exemple : <code>erb :index,
  :layout =&gt; !request.xhr?</code>.</p>

<p><strong>content_type</strong>
  Content-Type que le template produit, d&eacute;pend par d&eacute;faut du langage de
  template.</p>

<p><strong>scope</strong>
  Contexte sous lequel effectuer le rendu du template. Par d&eacute;faut il s'agit
  de l'instance de l'application. Si vous changez cela, les variables
  d'instance et les m&eacute;thodes utilitaires ne seront pas disponibles.</p>

<p><strong>layout_engine</strong>
  Moteur de rendu &agrave; utiliser pour le +layout+. Utile pour les langages ne
  supportant pas les +layouts+. Il s'agit par d&eacute;faut du moteur utilis&eacute; pour
  le rendu du template. Exemple : <code>set :rdoc, :layout_engine =&gt; :erb</code></p>

<p>Les templates sont suppos&eacute;s se trouver directement dans le dossier
<code>./views</code>. Pour utiliser un dossier de vues diff&eacute;rent :</p>

<pre><code class="ruby">set :views, settings.root + '/templates'
</code></pre>

<p>Il est important de se souvenir que les templates sont toujours r&eacute;f&eacute;renc&eacute;s
sous forme de symboles, m&ecirc;me lorsqu'ils sont dans un sous-r&eacute;pertoire (dans
ce cas, utilisez <code>:'sous_repertoire/template'</code>). Il faut utiliser
un symbole car les m&eacute;thodes de rendu &eacute;valuent le contenu des cha&icirc;nes de
caract&egrave;res au lieu de les consid&eacute;rer comme un chemin vers un fichier.</p>

<a name='Langages%20de%20template%20disponibles'></a>
<h3>Langages de template disponibles</h3>

<p>Certains langages ont plusieurs impl&eacute;mentations. Pour pr&eacute;ciser l'impl&eacute;mentation
&agrave; utiliser (et garantir l'aspect thread-safe), vous devez simplement l'avoir
charg&eacute;e au pr&eacute;alable :</p>

<pre><code class="ruby">require 'rdiscount' # ou require 'bluecloth'
get('/') { markdown :index }
</code></pre>

<a name='Templates%20Haml'></a>
<h3>Templates Haml</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="http://haml.info/">haml</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.haml</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>haml :index, :format =&gt; :html5</tt></td>
  </tr>
</table>
<a name='Templates%20Erb'></a>
<h3>Templates Erb</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td>
<a href="http://www.kuwata-lab.com/erubis/">erubis</a> ou erb (inclus avec Ruby)</td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td>
<tt>.erb</tt>, <tt>.rhtml</tt> ou <tt>.erubis</tt> (Erubis seulement)</td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>
<a name='Templates%20Builder'></a>
<h3>Templates Builder</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="http://builder.rubyforge.org/">builder</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.builder</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>builder { |xml| xml.em "salut" }</tt></td>
  </tr>
</table>
<p>Ce moteur accepte &eacute;galement un bloc pour des templates en ligne (voir
exemple).</p>

<a name='Templates%20Nokogiri'></a>
<h3>Templates Nokogiri</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="http://nokogiri.org/">nokogiri</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>nokogiri { |xml| xml.em "salut" }
    </tt></td>
  </tr>
</table>
<p>Ce moteur accepte &eacute;galement un bloc pour des templates en ligne (voir
exemple).</p>

<a name='Templates%20Sass'></a>
<h3>Templates Sass</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="http://sass-lang.com/">sass</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.sass</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>sass :stylesheet, :style =&gt; :expanded</tt></td>
  </tr>
</table>
<a name='Templates%20SCSS'></a>
<h3>Templates SCSS</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="http://sass-lang.com/">sass</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.scss</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td>
<tt>scss :stylesheet, :style =&gt; :expanded</tt>
    </td>
  </tr>
</table>
<a name='Templates%20Less'></a>
<h3>Templates Less</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="http://www.lesscss.org/">less</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.less</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td>
<tt>less :stylesheet</tt>
    </td>
  </tr>
</table>
<a name='Templates%20Liquid'></a>
<h3>Templates Liquid</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="http://www.liquidmarkup.org/">liquid</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.liquid</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>liquid :index, :locals =&gt; { :key =&gt; 'value' }</tt></td>
  </tr>
</table>
<p>Comme vous ne pouvez appeler de m&eacute;thodes Ruby (autres que <code>yield</code>)
dans un template Liquid, vous aurez s&ucirc;rement &agrave; lui passer des variables
locales.</p>

<a name='Templates%20Markdown'></a>
<h3>Templates Markdown</h3>

<table>
<tr>
<td><p>D&eacute;pendances</p></td>
    <td>
<a href="https://github.com/rtomayko/rdiscount">rdiscount</a>, <a href="https://github.com/vmg/redcarpet">redcarpet</a>, <a href="http://deveiate.org/projects/BlueCloth">bluecloth</a>, <a href="http://kramdown.rubyforge.org/">kramdown</a> *ou* <a href="http://maruku.rubyforge.org/">maruku</a>
</td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td>
<tt>.markdown</tt>, <tt>.mkd</tt> et <tt>.md</tt>
</td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>markdown :index, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>
<p>Il n&rsquo;est pas possible d&rsquo;appeler des m&eacute;thodes depuis markdown, ni de
lui passer des variables locales. Par cons&eacute;quent, il sera souvent utilis&eacute;
en combinaison avec un autre moteur de rendu :</p>

<pre><code class="ruby">erb :overview, :locals =&gt; { :text =&gt; markdown(:introduction) }
</code></pre>

<p>Notez que vous pouvez &eacute;galement appeler la m&eacute;thode <code>markdown</code> au
sein d&rsquo;autres templates :</p>

<pre><code class="ruby">%h1 Hello From Haml !
%p= markdown(:greetings)
</code></pre>

<p>Comme vous ne pouvez pas appeler de Ruby au sein de Markdown, vous ne
pouvez pas utiliser de layouts &eacute;crits en Markdown. Toutefois, il
est possible d&rsquo;utiliser un moteur de rendu diff&eacute;rent pour le template et
pour le layout en utilisant l&rsquo;option <code>:layout_engine</code>.</p>

<a name='Templates%20Textile'></a>
<h3>Templates Textile</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="http://redcloth.org/">RedCloth</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.textile</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>textile :index, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>
<p>Il n&rsquo;est pas possible d&rsquo;appeler des m&eacute;thodes depuis textile, ni de lui
passer des variables locales. Par cons&eacute;quent, il sera souvent utilis&eacute; en
combinaison avec un autre moteur de rendu :</p>

<pre><code class="ruby">erb :overview, :locals =&gt; { :text =&gt; textile(:introduction) }
</code></pre>

<p>Notez que vous pouvez &eacute;galement appeler la m&eacute;thode <code>textile</code> au
sein d&rsquo;autres templates :</p>

<pre><code class="ruby">%h1 Hello From Haml !
%p= textile(:greetings)
</code></pre>

<p>Comme vous ne pouvez pas appeler de Ruby au sein de Textile, vous ne pouvez
pas utiliser de layouts &eacute;crits en Textile. Toutefois, il est
possible d&rsquo;utiliser un moteur de rendu diff&eacute;rent pour le template et
pour le layout en utilisant l&rsquo;option <code>:layout_engine</code>.</p>

<a name='Templates%20RDoc'></a>
<h3>Templates RDoc</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="http://rdoc.rubyforge.org/">rdoc</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.rdoc</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>rdoc :README, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>
<p>Il n&rsquo;est pas possible d&rsquo;appeler des m&eacute;thodes depuis rdoc, ni de lui
passer des variables locales. Par cons&eacute;quent, il sera souvent utilis&eacute; en
combinaison avec un autre moteur de rendu :</p>

<pre><code class="ruby">erb :overview, :locals =&gt; { :text =&gt; rdoc(:introduction) }
</code></pre>

<p>Notez que vous pouvez &eacute;galement appeler la m&eacute;thode <code>rdoc</code> au sein
d&rsquo;autres templates :</p>

<pre><code class="ruby">%h1 Hello From Haml !
%p= rdoc(:greetings)
</code></pre>

<p>Comme vous ne pouvez pas appeler de Ruby au sein de RDoc, vous ne pouvez
pas utiliser de layouts &eacute;crits en RDoc. Toutefois, il est
possible d&rsquo;utiliser un moteur de rendu diff&eacute;rent pour le template et
pour le layout en utilisant l&rsquo;option <code>:layout_engine</code>.</p>

<a name='Templates%20Radius'></a>
<h3>Templates Radius</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="http://radius.rubyforge.org/">radius</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.radius</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>radius :index, :locals =&gt; { :key =&gt; 'value' }</tt></td>
  </tr>
</table>
<p>Comme vous ne pouvez pas appeler de m&eacute;thodes Ruby depuis un template
Radius, vous aurez s&ucirc;rement &agrave; lui passer des variables locales.</p>

<a name='Templates%20Markaby'></a>
<h3>Templates Markaby</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="http://markaby.github.com/">markaby</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.mab</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>markaby { h1 "Bienvenue !" }</tt></td>
  </tr>
</table>
<p>Ce moteur accepte &eacute;galement un bloc pour des templates en ligne (voir
exemple).</p>

<a name='Templates%20RABL'></a>
<h3>Templates RABL</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="https://github.com/nesquena/rabl">rabl</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.rabl</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>
<a name='Templates%20Slim'></a>
<h3>Templates Slim</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="http://slim-lang.com/">slim</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.slim</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>
<a name='Templates%20Creole'></a>
<h3>Templates Creole</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="https://github.com/minad/creole">creole</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.creole</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>creole :wiki, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>
<p>Il n'est pas possible d'appeler des m&eacute;thodes depuis markdown, ni de lui
passer des variables locales. Par cons&eacute;quent, il sera souvent utilis&eacute; en
combinaison avec un autre moteur de rendu :</p>

<pre><code class="ruby">erb :overview, :locals =&gt; { :text =&gt; markdown(:introduction) }
</code></pre>

<p>Notez que vous pouvez &eacute;galement appeler la m&eacute;thode +markdown+ au sein d'autres
templates :</p>

<pre><code class="ruby">%h1 Hello From Haml !
%p= markdown(:greetings)
</code></pre>

<p>Comme vous ne pouvez pas appeler de Ruby au sein de Markdown, vous ne pouvez
pas utiliser de +layouts+ &eacute;crits en Markdown. Toutefois, il est possible
d'utiliser un moteur de rendu diff&eacute;rent pour le template et pour le +layout+
en utilisant l'option <code>:layout_engine</code>.</p>

<a name='Templates%20CoffeeScript'></a>
<h3>Templates CoffeeScript</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td>
<a href="https://github.com/josh/ruby-coffee-script">coffee-script</a> et un [moyen d'ex&eacute;cuter javascript](https://github.com/sstephenson/execjs/blob/master/README.md#readme)</td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.coffee</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>
<a name='Templates%20Yajl'></a>
<h3>Templates Yajl</h3>

<table>
<tr>
<td>D&eacute;pendances</td>
    <td><a href="https://github.com/brianmario/yajl-ruby">yajl-ruby</a></td>
  </tr>
<tr>
<td>Extensions de fichier</td>
    <td><tt>.yajl</tt></td>
  </tr>
<tr>
<td>Exemple</td>
    <td>
<tt>yajl :index, :locals =&gt; { :key =&gt; 'qux' }, :callback =&gt; 'present', :variable =&gt; 'resource'</tt>
    </td>
  </tr>
</table>
<p>Le source du template est &eacute;valu&eacute; en tant que chaine Ruby, puis la
variable json obtenue est convertie avec #to_json.</p>

<pre><code class="ruby">json = { :foo =&gt; 'bar' }
json[:baz] = key
</code></pre>

<p>Les options <code>:callback</code> et <code>:variable</code> peuvent &ecirc;tre utilis&eacute;es pour d&eacute;corer l&rsquo;objet retourn&eacute;.</p>

<pre><code>var resource = {"foo":"bar","baz":"qux"}; present(resource);&lt;/pre&gt;
</code></pre>

<a name='Templates%20WLang'></a>
<h3>Templates WLang</h3>

<table>
<tr>
<td>Dependency</td>
    <td><a href="https://github.com/blambeau/wlang/">wlang</a></td>
  </tr>
<tr>
<td>File Extensions</td>
    <td><tt>.wlang</tt></td>
  </tr>
<tr>
<td>Example</td>
    <td><tt>wlang :index, :locals =&gt; { :key =&gt; 'value' }</tt></td>
  </tr>
</table>
<p>L&rsquo;appel de code ruby au sein des templates n&rsquo;est pas idiomatique en wlang. L&rsquo;&eacute;criture de templates sans logique est encourag&eacute;, via le passage de variables locales. Il est n&eacute;anmoins possible d&rsquo;&eacute;crire un layout en wlang et d&rsquo;y utiliser <code>yield</code>.</p>

<a name='Templates%20embarqu&eacute;s'></a>
<h3>Templates embarqu&eacute;s</h3>

<pre><code class="ruby">get '/' do
  haml '%div.title Bonjour le monde'
end
</code></pre>

<p>G&eacute;n&eacute;rera le code du template sp&eacute;cifi&eacute; dans la cha&icirc;ne de caract&egrave;res.</p>

<a name='Acc&eacute;der%20aux%20variables%20dans%20un%20Template'></a>
<h3>Acc&eacute;der aux variables dans un Template</h3>

<p>Un template est &eacute;valu&eacute; dans le m&ecirc;me contexte que l'endroit d'o&ugrave; il a &eacute;t&eacute;
appel&eacute; (gestionnaire de route). Les variables d'instance d&eacute;clar&eacute;es dans le
gestionnaire de route sont directement accessibles dans le template :</p>

<pre><code class="ruby">get '/:id' do
  @foo = Foo.find(params[:id])
  haml '%h1= @foo.nom'
end
</code></pre>

<p>Alternativement, on peut passer un hash contenant des variables locales :</p>

<pre><code class="ruby">get '/:id' do
  foo = Foo.find(params[:id])
  haml '%h1= foo.nom', :locals =&gt; { :foo =&gt; foo }
end
</code></pre>

<p>Ceci est g&eacute;n&eacute;ralement utilis&eacute; lorsque l'on veut utiliser un template comme
partiel (depuis un autre template) et qu'il est donc n&eacute;cessaire d'adapter les
noms de variables.</p>

<a name='Templates%20dans%20le%20fichier%20source'></a>
<h3>Templates dans le fichier source</h3>

<p>Des templates peuvent &ecirc;tre d&eacute;finis dans le fichier source comme ceci :</p>

<pre><code class="ruby">require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Bonjour le monde !
</code></pre>

<p>NOTE : Les templates du fichier source qui contient <code>require 'sinatra'</code>
sont automatiquement charg&eacute;s. Si vous avez des templates dans d'autres
fichiers source, il faut explicitement les d&eacute;clarer avec
<code>enable :inline_templates</code>.</p>

<a name='Templates%20nomm&eacute;s'></a>
<h3>Templates nomm&eacute;s</h3>

<p>Les templates peuvent aussi &ecirc;tre d&eacute;finis gr&acirc;ce &agrave; la m&eacute;thode de haut niveau <code>template</code> :</p>

<pre><code class="ruby">template :layout do
  "%html\n  =yield\n"
end

template :index do
  '%div.title Bonjour le monde !'
end

get '/' do
  haml :index
end
</code></pre>

<p>Si un template nomm&eacute; "layout" existe, il sera utilis&eacute; &agrave; chaque fois qu'un
template sera affich&eacute;. Vous pouvez d&eacute;sactivez les layouts au cas par cas en
passant <code>:layout =&gt; false</code> ou bien les d&eacute;sactiver par d&eacute;faut au moyen
de <code>set :haml, :layout =&gt; false</code> :</p>

<pre><code class="ruby">get '/' do
  haml :index, :layout =&gt; !request.xhr?
end
</code></pre>

<a name='Associer%20des%20extensions%20de%20fichier'></a>
<h3>Associer des extensions de fichier</h3>

<p>Pour associer une extension de fichier avec un moteur de rendu, utilisez
<code>Tilt.register</code>. Par exemple, si vous d&eacute;sirez utiliser l'extension
de fichier <code>tt</code> pour les templates Textile, vous pouvez faire comme suit :</p>

<pre><code class="ruby">Tilt.register :tt, Tilt[:textile]
</code></pre>

<a name='Ajouter%20son%20propre%20moteur%20de%20rendu'></a>
<h3>Ajouter son propre moteur de rendu</h3>

<p>En premier lieu, d&eacute;clarez votre moteur de rendu avec Tilt, ensuite cr&eacute;ez
votre m&eacute;thode de rendu :</p>

<pre><code class="ruby">Tilt.register :monmoteur, MonMerveilleurMoteurDeRendu

helpers do
  def monmoteur(*args) render(:monmoteur, *args) end
end

get '/' do
  monmoteur :index
end
</code></pre>

<p>Utilisera <code>./views/index.monmoteur</code>. Voir <a href="https://github.com/rtomayko/tilt">le d&eacute;p&ocirc;t Github</a> pour en savoir plus sur Tilt.</p>

<a name='Filtres'></a>
<h2>Filtres</h2>

<p>Les filtres before sont ex&eacute;cut&eacute;s avant chaque requ&ecirc;te, dans le m&ecirc;me contexte
que les routes, et permettent de modifier la requ&ecirc;te et sa r&eacute;ponse. Les
variables d'instance d&eacute;clar&eacute;es dans les filtres sont accessibles au niveau
des routes et des templates :</p>

<pre><code class="ruby">before do
  @note = 'Coucou !'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @note #=&gt; 'Coucou !'
  params[:splat] #=&gt; 'bar/baz'
end
</code></pre>

<p>Les filtres after sont ex&eacute;cut&eacute;s apr&egrave;s chaque requ&ecirc;te &agrave; l'int&eacute;rieur du m&ecirc;me
contexte et permettent de modifier la requ&ecirc;te et sa r&eacute;ponse. Les variables
d'instance d&eacute;clar&eacute;es dans les filtres before ou les routes sont accessibles
au niveau des filtres after :</p>

<pre><code class="ruby">after do
  puts response.status
end
</code></pre>

<p>Note : Le corps de la r&eacute;ponse n'est pas disponible au niveau du filtre after
car il ne sera g&eacute;n&eacute;r&eacute; que plus tard (sauf dans le cas o&ugrave; vous utilisez la
m&eacute;thode +body+ au lieu de simplement renvoyer une chaine depuis vos routes).</p>

<p>Les filtres peuvent &ecirc;tre associ&eacute;s &agrave; un masque, ce qui permet de limiter leur
ex&eacute;cution aux cas o&ugrave; la requ&ecirc;te correspond &agrave; ce masque :</p>

<pre><code class="ruby">before '/secret/*' do
  authentification!
end

after '/faire/:travail' do |travail|
  session[:dernier_travail] = travail
end
</code></pre>

<p>Tout comme les routes, les filtres acceptent &eacute;galement des conditions :</p>

<pre><code class="ruby">before :agent =&gt; /Songbird/ do
  # ...
end

after '/blog/*', :host_name =&gt; 'example.com' do
  # ...
end
</code></pre>

<a name='Helpers'></a>
<h2>Helpers</h2>

<p>Utilisez la m&eacute;thode de haut niveau <code>helpers</code> pour d&eacute;finir des routines
qui seront accessibles dans vos gestionnaires de route et dans vos templates :</p>

<pre><code class="ruby">helpers do
  def bar(nom)
    "#{nom}bar"
  end
end

get '/:nom' do
  bar(params[:nom])
end
</code></pre>

<p>Vous pouvez aussi d&eacute;finir les m&eacute;thodes helper dans un module s&eacute;par&eacute; :</p>

<pre><code class="ruby">module FooUtils
  def foo(nom) "#{nom}foo" end
end

module BarUtils
  def bar(nom) "#{nom}bar" end
end

helpers FooUtils, BarUtils
</code></pre>

<p>Cela a le m&ecirc;me r&eacute;sultat que d'inclure les modules dans la classe de
l'application.</p>

<a name='Utiliser%20les%20sessions'></a>
<h3>Utiliser les sessions</h3>

<p>Une session est utilis&eacute;e pour conserver un &eacute;tat entre les requ&ecirc;tes. Une fois
activ&eacute;es, vous avez un +hash+ de session par session utilisateur :</p>

<pre><code class="ruby">enable :sessions

get '/' do
  "valeur = " &lt;&lt; session[:valeur].inspect
end

get '/:value' do
  session[:valeur] = params[:valeur]
end
</code></pre>

<p>Notez que <tt>enable :sessions</tt> enregistre en fait toutes les donn&eacute;es dans
un +cookie+. Ce n'est pas toujours ce que vous voulez (enregistrer beaucoup de
donn&eacute;es va augmenter le traffic par exemple). Vous pouvez utiliser n'importe
quel +middleware+ Rack de session afin d'&eacute;viter cela. N'utiliser <em>pas</em>
<tt>enable :sessions</tt> dans ce cas mais charger le +middleware+ de votre
choix comme vous le feriez pour n'importe quel autre +middleware+ :</p>

<pre><code class="ruby">use Rack::Session::Pool, :expire_after =&gt; 2592000

get '/' do
  "valeur = " &lt;&lt; session[:valeur].inspect
end

get '/:value' do
  session[:valeur] = params[:valeur]
end
</code></pre>

<p>Pour renforcer la s&eacute;curit&eacute;, les donn&eacute;es de session dans le cookie sont sign&eacute;es
avec une cl&eacute; secr&egrave;te de session. Une cl&eacute; secr&egrave;te est g&eacute;n&eacute;r&eacute;e pour vous au
hasard par Sinatra. Toutefois, comme cette cl&eacute; change &agrave; chaque d&eacute;marrage de
votre application, vous pouvez d&eacute;finir cette cl&eacute; vous-m&ecirc;me afin que toutes
les instances de votre application la partage :</p>

<pre><code class="ruby">set :session_secret, 'super secret'
</code></pre>

<p>Si vous souhaitez avoir plus de contr&ocirc;le, vous pouvez &eacute;galement enregistrer un
+hash+ avec des options lors de la configuration de <code>sessions</code> :</p>

<pre><code class="ruby">set :sessions, :domain =&gt; 'foo.com'
</code></pre>

<a name='Halt'></a>
<h3>Halt</h3>

<p>Pour arr&ecirc;ter imm&eacute;diatement la requ&ecirc;te dans un filtre ou un gestionnaire de
route :</p>

<pre><code class="ruby">halt
</code></pre>

<p>Vous pouvez aussi passer le code retour ...</p>

<pre><code class="ruby">halt 410
</code></pre>

<p>Ou le texte ...</p>

<pre><code class="ruby">halt 'Ceci est le texte'
</code></pre>

<p>Ou les deux ...</p>

<pre><code class="ruby">halt 401, 'Partez !'
</code></pre>

<p>Ainsi que les ent&ecirc;tes ...</p>

<pre><code class="ruby">halt 402, {'Content-Type' =&gt; 'text/plain'}, 'revanche'
</code></pre>

<p>Bien s&ucirc;r il est possible de combiner un template avec <code>halt</code> :</p>

<pre><code class="ruby">halt erb(:erreur)
</code></pre>

<a name='Passer'></a>
<h3>Passer</h3>

<p>Une route peut passer le relais aux autres routes qui correspondent &eacute;galement
avec <code>pass</code> :</p>

<pre><code class="ruby">get '/devine/:qui' do
  pass unless params[:qui] == 'Frank'
  "Tu m'as eu !"
end

get '/devine/*' do
  'Manqu&eacute; !'
end
</code></pre>

<p>On sort donc imm&eacute;diatement de ce gestionnaire et on continue &agrave; chercher,
dans les masques suivants, le prochain qui correspond &agrave; la requ&ecirc;te.
Si aucun des masques suivants ne correspond, un code 404 est retourn&eacute;.</p>

<a name='D&eacute;clencher%20une%20autre%20route'></a>
<h3>D&eacute;clencher une autre route</h3>

<p>Parfois, +pass+ n'est pas ce que vous recherchez, au lieu de cela vous
souhaitez obtenir le r&eacute;sultat d'une autre route. Pour cela, utilisez
simplement call :</p>

<pre><code class="ruby">get '/foo' do
  status, headers, body = call env.merge("PATH_INFO" =&gt; '/bar')
  [status, headers, body.map(&amp;:upcase)]
end

get '/bar' do
  "bar"
end
</code></pre>

<p>Notez que dans l'exemple ci-dessus, vous faciliterez les tests et am&eacute;liorerez
la performance en d&eacute;pla&ccedil;ant simplement <code>"bar"</code> dans un helper
utilis&eacute; &agrave; la fois par <code>/foo</code> et <code>/bar</code>.</p>

<p>Si vous souhiatez que la requ&ecirc;te soit envoy&eacute;e &agrave; la m&ecirc;me instance de
l'application plut&ocirc;t qu'&agrave; une copie, utilisez <code>call!</code> au lieu de
<code>call</code>.</p>

<p>Lisez la sp&eacute;cification Rack si vous souhaitez en savoir plus sur
<code>call</code>.</p>

<a name='D&eacute;finir%20le%20corps,%20le%20code%20retour%20et%20les%20ent&ecirc;tes'></a>
<h3>D&eacute;finir le corps, le code retour et les ent&ecirc;tes</h3>

<p>Il est possible et recommand&eacute; de d&eacute;finir le code retour et le corps de la
r&eacute;ponse au moyen de la valeur de retour d'un bloc d&eacute;finissant une route.
Quoiqu'il en soit, dans certains cas vous pourriez avoir besoin de d&eacute;finir
le coprs de la r&eacute;ponse &agrave; un moment arbitraire de l'ex&eacute;cution. Vous pouvez le
faire au moyen de la m&eacute;thode +body+. Si vous faites ainsi, vous pouvez alors
utiliser cette m&ecirc;me m&eacute;thode pour acc&eacute;der au corps de la r&eacute;ponse :</p>

<pre><code class="ruby">get '/foo' do
  body "bar"
end

after do
  puts body
end
</code></pre>

<p>Il est &eacute;galement possible de passer un bloc &agrave; <code>body</code>, qui sera ex&eacute;cut&eacute; par le
gestionnaire Rack (ceci peut &ecirc;tre utilis&eacute; pour impl&eacute;menter un streaming,
voir "Valeurs de retour").</p>

<p>Pareillement au corps de la r&eacute;ponse, vous pouvez &eacute;galement d&eacute;finir le code
retour et les ent&ecirc;tes :</p>

<pre><code class="ruby">get '/foo' do
  status 418
  headers \
    "Allow"   =&gt; "BREW, POST, GET, PROPFIND, WHEN",
    "Refresh" =&gt; "Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"
  body "Je suis une th&eacute;i&egrave;re !"
end
</code></pre>

<p>Comme <code>body</code> <code>headers</code> et <code>status</code> peuvent &ecirc;tre utilis&eacute;s sans arguments
pour acc&eacute;der &agrave; leurs valeurs.</p>

<a name='Faire%20du%20streaming'></a>
<h3>Faire du streaming</h3>

<p>Il y a des cas o&ugrave; vous voulez commencer &agrave; renvoyer des donn&eacute;es pendant que
vous &ecirc;tes en train de g&eacute;n&eacute;rer le reste de la r&eacute;ponse. Dans les cas les plus
extr&egrave;mes, vous souhaitez continuer &agrave; envoyer des donn&eacute;es tant que le client
n'abandonne pas la connection. Vous pouvez alors utiliser le helper <code>stream</code>
pour &eacute;viter de cr&eacute;er votre propre syst&egrave;me :</p>

<pre><code class="ruby">get '/' do
  stream do |out|
    out &lt;&lt; "Ca va &ecirc;tre hallu -\n"
    sleep 0.5
    out &lt;&lt; " (attends la suite) \n"
    sleep 1
    out &lt;&lt; "- cinant !\n"
  end
end
</code></pre>

<p>Cela permet d'impl&eacute;menter des API de streaming ou de
<a href="http://dev.w3.org/html5/eventsource/">Server Sent Events</a> et peut servir de
base pour des <a href="http://en.wikipedia.org/wiki/WebSocket">WebSockets</a>. Vous
pouvez aussi l'employer pour augmenter le d&eacute;bit quand une partie du contenu
provient d'une resource lente.</p>

<p>Le fonctionnement du streaming, notamment le nombre de requ&ecirc;tes simultan&eacute;es,
d&eacute;pend &eacute;norm&eacute;ment du serveur web utilis&eacute;. Certains ne prennent pas du tout en
charge le streaming (WEBRick par exemple). Lorsque le serveur ne g&egrave;re pas le
streaming, la partie body de la r&eacute;ponse sera envoy&eacute;e au client en une seule
fois, apr&egrave;s que l'ex&eacute;cution du bloc pass&eacute; au helper +stream+ sera termin&eacute;e. Le
streaming ne fonctionne pas du tout avec Shotgun.</p>

<p>En utilisant le helper +stream+ avec le param&egrave;tre +keep_open+, il n'appelera
pas la m&eacute;thode +close+ du flux, vous laissant la possibilit&eacute; de le fermer &agrave;
tout moment au cours de l'ex&eacute;cution. Ceci ne fonctionne qu'avec les serveurs
evented (ie non thread&eacute;s) tels que Thin et Rainbows. Les autres serveurs
fermeront malgr&eacute; tout le flux :</p>

<pre><code class="ruby">set :server, :thin
connections = []

get '/' do
  # conserve le flux ouvert
  stream(:keep_open) { |out| connections &lt;&lt; out }
end

post '/' do
  # &eacute;crit dans tous les flux ouverts
  connections.each { |out| out &lt;&lt; params[:message] &lt;&lt; "\n" }
  "message sent"
end
</code></pre>

<a name='Journalisation%20(Logging)'></a>
<h3>Journalisation (Logging)</h3>

<p>Dans le contexte de la requ&ecirc;te, la m&eacute;thode utilitaire +logger+ expose une
instance de +logger+ :</p>

<pre><code class="ruby">get '/' do
  logger.info "chargement des donn&eacute;es"
  # ...
end
</code></pre>

<p>Ce logger va automatiquement prendre en compte les param&egrave;tres de
configuration pour la journalisation de votre gestionnaire Rack. Si la
journalisation est d&eacute;sactiv&eacute;e, cette m&eacute;thode renverra un objet factice et
vous n'avez pas &agrave; vous en inqui&eacute;ter dans vos routes en le filtrant.</p>

<p>Notez que la journalisation est seulement activ&eacute;e par d&eacute;faut pour
<code>Sinatra::Application</code>, donc si vous h&eacute;ritez de <code>&gt;Sinatra::Base</code>,
vous aurez &agrave; l'activer vous-m&ecirc;me :</p>

<pre><code class="ruby">class MonApp &lt; Sinatra::Base
  configure :production, :development do
    enable :logging
  end
end
</code></pre>

<p>Si vous souhaitez utiliser votre propre logger, vous devez d&eacute;finir le param&egrave;tre
<code>logging</code> &agrave; <code>nil</code> pour &ecirc;tre certain qu'aucun middleware de logging ne sera
install&eacute; (notez toutefois que +logger+ renverra alors +nil+). Dans ce cas,
Sinatra utilisera ce qui sera pr&eacute;sent dans <code>env['rack.logger']</code>.</p>

<a name='Types%20Mime'></a>
<h3>Types Mime</h3>

<p>Quand vous utilisez <code>send_file</code> ou des fichiers statiques, vous
pouvez rencontrer des types mime que Sinatra ne conna&icirc;t pas. Utilisez
<code>mime_type</code> pour les d&eacute;clarer par extension de fichier :</p>

<pre><code class="ruby">configure do
  mime_type :foo, 'text/foo'
end
</code></pre>

<p>Vous pouvez &eacute;galement les utiliser avec la m&eacute;thode <code>content_type</code> :</p>

<pre><code class="ruby">get '/' do
  content_type :foo
  "foo foo foo"
end
</code></pre>

<a name='Former%20des%20URLs'></a>
<h3>Former des URLs</h3>

<p>Pour former des URLs, vous devriez utiliser la m&eacute;thode +url+, par exemple en
Haml :</p>

<pre><code class="ruby">%a{:href =&gt; url('/foo')} foo
</code></pre>

<p>Cela prend en compte les proxy inverse et les routeurs Rack, s'ils existent.</p>

<p>Cette m&eacute;thode est &eacute;galement disponible sous l'alias +to+ (voir ci-dessous
pour un exemple).</p>

<a name='Redirection%20du%20navigateur'></a>
<h3>Redirection du navigateur</h3>

<p>Vous pouvez d&eacute;clencher une redirection du navigateur avec la m&eacute;thode
<code>redirect</code> :</p>

<pre><code class="ruby">get '/foo' do
  redirect to('/bar')
end
</code></pre>

<p>Tout param&egrave;tre additionnel est g&eacute;r&eacute; comme des arguments pour la m&eacute;thode
<code>halt</code> :</p>

<pre><code class="ruby">redirect to('/bar'), 303
redirect 'http://google.com', 'mauvais endroit mon pote'
</code></pre>

<p>Vous pouvez aussi rediriger vers la page dont l'utilisateur venait au moyen de
<code>redirect back</code> :</p>

<pre><code class="ruby">get '/foo' do
  "&lt;a href='/bar'&gt;faire quelque chose&lt;/a&gt;"
end

get '/bar' do
  faire_quelque_chose
  redirect back
end
</code></pre>

<p>Pour passer des arguments &agrave; une redirection, ajoutez-les soit &agrave; la requ&ecirc;te :</p>

<pre><code class="ruby">redirect to('/bar?sum=42')
</code></pre>

<p>Ou bien utilisez une session :</p>

<pre><code class="ruby">enable :sessions

get '/foo' do
  session[:secret] = 'foo'
  redirect to('/bar')
end

get '/bar' do
  session[:secret]
end
</code></pre>

<a name='Contr&ocirc;le%20du%20cache'></a>
<h3>Contr&ocirc;le du cache</h3>

<p>D&eacute;finir correctement vos ent&ecirc;tes &agrave; la base pour un bon cache HTTP.</p>

<p>Vous pouvez facilement d&eacute;finir l'ent&ecirc;te Cache-Control de la mani&egrave;re suivante :</p>

<pre><code class="ruby">get '/' do
  cache_control :public
  "met le en cache !"
end
</code></pre>

<p>Conseil de pro : d&eacute;finir le cache dans un filtre +before+ :</p>

<pre><code class="ruby">before do
  cache_control :public, :must_revalidate, :max_age =&gt; 60
end
</code></pre>

<p>Si vous utilisez la m&eacute;thode +expires+ pour d&eacute;finir l'ent&ecirc;te correspondant,
<code>Cache-Control</code> sera alors d&eacute;fini automatiquement :</p>

<pre><code class="ruby">before do
  expires 500, :public, :must_revalidate
end
</code></pre>

<p>Pour utiliser correctement les caches, vous devriez utiliser +etag+ ou
+last_modified+. Il est recommand&eacute; d'utiliser ces m&eacute;thodes <em>avant</em> de faire
d'importantes modifications, car elles vont imm&eacute;diatement d&eacute;clencher la r&eacute;ponse
si le client a d&eacute;j&agrave; la version courante dans son cache :</p>

<pre><code class="ruby">get '/article/:id' do
  @article = Article.find params[:id]
  last_modified @article.updated_at
  etag @article.sha1
  erb :article
end
</code></pre>

<p>Il est &eacute;galement possible d'utiliser un
<a href="http://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation">weak ETag</a> :</p>

<pre><code class="ruby">etag @article.sha1, :weak
</code></pre>

<p>Ces m&eacute;thodes ne sont pas charg&eacute;es de mettre des donn&eacute;es en cache, mais elles
fournissent les informations n&eacute;cessaires pour votre cache. Si vous &ecirc;tes &agrave; la
recherche de solutions rapides pour un reverse-proxy de cache, essayez
<a href="https://github.com/rtomayko/rack-cache">rack-cache</a> :</p>

<pre><code class="ruby">require "rack/cache"
require "sinatra"

use Rack::Cache

get '/' do
  cache_control :public, :max_age =&gt; 36000
  sleep 5
  "hello"
end
</code></pre>

<p>Utilisez le param&egrave;tre <code>:static_cache_control</code> pour ajouter l'information
d'en-t&ecirc;te <code>Cache-Control</code> (voir plus loin).</p>

<p>D'apr&egrave;s la RFC 2616, votre application devrait se comporter diff&eacute;rement lorsque
l'en-t&ecirc;te If-Match ou If-None-Match est d&eacute;fini &agrave; <code>*</code> en tenant compte du
fait que la resource demand&eacute;e existe d&eacute;j&agrave; ou pas. Sinatra consid&egrave;re que les
requ&ecirc;tes portant sur des resources s&ucirc;res (tel que get) ou idempotentes (tel que
put) existent d&eacute;j&agrave; et pour les autres resources (par exemple dans le cas
de requ&ecirc;tes post) qu'il s'agit de nouvelles resources. Vous pouvez modifier ce
comportement en passant une option <code>:new_resource</code> :</p>

<pre><code class="ruby">get '/create' do
  etag '', :new_resource =&gt; true
  Article.create
  erb :new_article
end
</code></pre>

<p>Si vous souhaitez utilisez un ETag faible, utilisez l'option <tt>:kind</tt> :</p>

<pre><code>etag '', :new_resource =&gt; true, :kind =&gt; :weak
</code></pre>

<a name='Envoyer%20des%20fichiers'></a>
<h3>Envoyer des fichiers</h3>

<p>Pour envoyer des fichiers, vous pouvez utiliser la m&eacute;thode
<code>send_file</code> :</p>

<pre><code class="ruby">get '/' do
  send_file 'foo.png'
end
</code></pre>

<p>Quelques options sont &eacute;galement accept&eacute;es :</p>

<pre><code class="ruby">send_file 'foo.png', :type =&gt; :jpg
</code></pre>

<p>Les options sont :</p>

<dl>
<dt>filename</dt>
  <dd>
    le nom du fichier dans la r&eacute;ponse, par d&eacute;faut le nom du fichier envoy&eacute;.
  </dd>

  <dt>last_modified</dt>
  <dd>valeur pour l&rsquo;ent&ecirc;te Last-Modified, par d&eacute;faut la date de modification
du fichier</dd>

  <dt>type</dt>
  <dd>type de contenu &agrave; utiliser, devin&eacute; &agrave; partir de l&rsquo;extension de fichier
  si absent</dd>

  <dt>disposition</dt>
  <dd>utilis&eacute; pour Content-Disposition, les valuers possibles &eacute;tant :
  `nil` (par d&eacute;faut), `:attachment` et `:inline`</dd>

  <dt>length</dt>
  <dd>ent&ecirc;te Content-Length, par d&eacute;faut la taille du fichier</dd>

  <dt>status</dt>
  <dd>code &eacute;tat &agrave; renvoyer. Utile quand un fichier statique sert de page
  d&rsquo;erreur.</dd>
</dl>
<p>Si le gestionnaire Rack le supporte, d'autres moyens que le +streaming+ via le
processus Ruby seront utilis&eacute;s. Si vous utilisez cette m&eacute;thode, Sinatra g&eacute;rera
automatiquement les requ&ecirc;tes de type +range+.</p>

<a name='Acc&eacute;der%20&agrave;%20l'objet%20requ&ecirc;te'></a>
<h3>Acc&eacute;der &agrave; l'objet requ&ecirc;te</h3>

<p>L'objet correspondant &agrave; la requ&ecirc;te envoy&eacute;e peut &ecirc;tre r&eacute;cup&eacute;r&eacute; dans le contexte
de la requ&ecirc;te (filtres, routes, gestionnaires d'erreur) au moyen de la m&eacute;thode
+request+ :</p>

<pre><code class="ruby"># application tournant &agrave; l'adresse http://exemple.com/exemple
get '/foo' do
  t = %w[text/css text/html application/javascript]
  request.accept              # ['text/html', '*/*']
  request.accept? 'text/xml'  # true
  request.preferred_type(t)   # 'text/html'
  request.body                # corps de la requ&ecirc;te envoy&eacute;e par le client
                              # (voir ci-dessous)
  request.scheme              # "http"
  request.script_name         # "/exemple"
  request.path_info           # "/foo"
  request.port                # 80
  request.request_method      # "GET"
  request.query_string        # ""
  request.content_length      # taille de request.body
  request.media_type          # type de m&eacute;dia pour request.body
  request.host                # "exemple.com"
  request.get?                # true (m&eacute;thodes similaires pour les autres
                              # verbes HTTP)
  request.form_data?          # false
  request["UN_ENTETE"]        # valeur de l'ent&ecirc;te UN_ENTETE
  request.referer             # r&eacute;f&eacute;rant du client ou '/'
  request.user_agent          # user agent (utilis&eacute; par la condition :agent)
  request.cookies             # tableau contenant les cookies du navigateur
  request.xhr?                # requ&ecirc;te AJAX ?
  request.url                 # "http://exemple.com/exemple/foo"
  request.path                # "/exemple/foo"
  request.ip                  # adresse IP du client
  request.secure?             # false
  request.forwarded?          # vrai (si on est derri&egrave;re un proxy inverse)
  request.env                 # tableau brut de l'environnement fourni par
                              # Rack
end
</code></pre>

<p>Certaines options, telles que <code>script_name</code> ou <code>path_info</code>
peuvent &eacute;galement &ecirc;tre modifi&eacute;es :</p>

<pre><code class="ruby">before { request.path_info = "/" }

get "/" do
  "toutes les requ&ecirc;tes arrivent ici"
end
</code></pre>

<p><code>request.body</code> est un objet IO ou StringIO :</p>

<pre><code class="ruby">post "/api" do
  request.body.rewind  # au cas o&ugrave; il a d&eacute;j&agrave; &eacute;t&eacute; lu
  donnees = JSON.parse request.body.read
  "Bonjour #{donnees['nom']} !"
end
</code></pre>

<a name='Fichiers%20joints'></a>
<h3>Fichiers joints</h3>

<p>Vous pouvez utiliser la m&eacute;thode +attachment+ pour indiquer au navigateur que
la r&eacute;ponse devrait &ecirc;tre stock&eacute;e sur le disque plut&ocirc;t qu'affich&eacute;e :</p>

<pre><code class="ruby">get '/' do
  attachment
  "enregistre-le !"
end
</code></pre>

<p>Vous pouvez &eacute;galement lui passer un nom de fichier :</p>

<pre><code class="ruby">get '/' do
  attachment "info.txt"
  "enregistre-le !"
end
</code></pre>

<a name='G&eacute;rer%20Date%20et%20Time'></a>
<h3>G&eacute;rer Date et Time</h3>

<p>Sinatra fourni un helper +time_for+ pour convertir une valeur donn&eacute;e en
objet <code>Time</code>. Il peut aussi faire la conversion &agrave; partir d'objets +DateTime+,
<code>Date</code> ou de classes similaires :</p>

<pre><code class="ruby">get '/' do
  pass if Time.now &gt; time_for('Dec 23, 2012')
  "encore temps"
end
</code></pre>

<p>Cette m&eacute;thode est utilis&eacute;e en interne par +expires+, +last<em>modified+ et
consorts. Par cons&eacute;quent, vous pouvez tr&egrave;s facilement &eacute;tendre le
fonctionnement de ces m&eacute;thodes en surchargeant le helper +time</em>for+ dans
votre application :</p>

<pre><code class="ruby">helpers do
  def time_for(value)
    case value
    when :yesterday then Time.now - 24*60*60
    when :tomorrow  then Time.now + 24*60*60
    else super
    end
  end
end

get '/' do
  last_modified :yesterday
  expires :tomorrow
  "salut"
end
</code></pre>

<a name='Chercher%20les%20fichiers%20de%20templates'></a>
<h3>Chercher les fichiers de templates</h3>

<p>La m&eacute;thode <code>find_template</code> est utilis&eacute;e pour trouver les fichiers de
templates &agrave; g&eacute;n&eacute;rer :</p>

<pre><code class="ruby">find_template settings.views, 'foo', Tilt[:haml] do |file|
  puts "pourrait &ecirc;tre #{file}"
end
</code></pre>

<p>Ce n'est pas tr&egrave;s utilise. En revanche, il est utile de pouvoir surcharger
cette m&eacute;thode afin de d&eacute;finir son propre m&eacute;canisme de recherche. Par exemple,
vous pouvez utiliser plus d'un r&eacute;pertoire de vues :</p>

<pre><code class="ruby">set :views, ['views', 'templates']

helpers do
  def find_template(views, name, engine, &amp;block)
    Array(views).each { |v| super(v, name, engine, &amp;block) }
  end
end
</code></pre>

<p>Un autre exemple est d'utiliser des r&eacute;pertoires diff&eacute;rents pour des moteurs
de rendu diff&eacute;rents :</p>

<pre><code class="ruby">set :views, :sass =&gt; 'views/sass', :haml =&gt; 'templates', :default =&gt; 'views'

helpers do
  def find_template(views, name, engine, &amp;block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:default]
    super(folder, name, engine, &amp;block)
  end
end
</code></pre>

<p>Vous pouvez &eacute;galement &eacute;crire cela dans une extension et la partager avec
d'autres !</p>

<p>Notez que <code>find_template</code> ne v&eacute;rifie pas que le fichier existe mais
va plut&ocirc;t ex&eacute;cuter le bloc pour tous les chemins possibles. Cela n'induit pas
un probl&egrave;me de performance dans le sens o&ugrave; <code>render</code> va utiliser +break+ d&egrave;s
qu'un fichier est trouv&eacute;. De plus, l'emplacement des templates (et leur
contenu) est mis en cache si vous n'&ecirc;tes pas en mode d&eacute;veloppement. Vous
devriez garder cela en t&ecirc;te si vous &eacute;crivez une m&eacute;thode vraiment dingue.</p>

<a name='Configuration'></a>
<h2>Configuration</h2>

<p>Lanc&eacute; une seule fois au d&eacute;marrage de tous les environnements :</p>

<pre><code class="ruby">configure do
  # d&eacute;finir un param&egrave;tre
  set :option, 'value'

  # d&eacute;finir plusieurs param&egrave;tre
  set :a =&gt; 1, :b =&gt; 2

  # identique &agrave; "set :option, true"
  enable :option

  # identique &agrave; "set :option, false""
  disable :option

  # vous pouvez &eacute;galement avoir des param&egrave;tres dynamiques avec des blocs
  set(:css_dir) { File.join(views, 'css') }
end
</code></pre>

<p>Lanc&eacute; si l'environnement (variable d'environnement RACK_ENV) est d&eacute;fini comme
<code>:production</code> :</p>

<p>configure :production do
    ...
  end</p>

<p>Lanc&eacute; si l'environnement est <code>:production</code> ou
<code>:test</code> :</p>

<p>configure :production, :test do
    ...
  end</p>

<p>Vous pouvez acc&eacute;der &agrave; ces param&egrave;tres via <code>settings</code> :</p>

<pre><code>configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # =&gt; true
  settings.foo  # =&gt; 'bar'
  ...
end
</code></pre>

<a name='Se%20prot&eacute;ger%20des%20attaques'></a>
<h3>Se prot&eacute;ger des attaques</h3>

<p>Sinatra utilise <a href="https://github.com/rkh/rack-protection#readme">Rack::Protection</a>
pour prot&eacute;ger votre application contre les principales attaques opportunistes.
Vous pouvez tr&egrave;s simplement d&eacute;sactiver cette fonctionnalit&eacute; (ce qui exposera
votre application &agrave; beaucoup de vulnerabilit&eacute;s courantes) :</p>

<pre><code class="ruby">disable :protection
</code></pre>

<p>Pour d&eacute;sactiver seulement un type de protection, vous pouvez d&eacute;finir <code>protection</code>
avec un hash d'options :</p>

<pre><code class="ruby">set :protection, :except =&gt; :path_traversal
</code></pre>

<p>Vous pouvez &eacute;galement lui passer un tableau pour d&eacute;sactiver plusieurs types de
protection :</p>

<pre><code class="ruby">set :protection, :except =&gt; [:path_traversal, :session_hijacking]
</code></pre>

<a name='Param&egrave;tres%20disponibles'></a>
<h3>Param&egrave;tres disponibles</h3>

<dl>
<dt>absolute_redirects</dt>
  <dd>Si d&eacute;sactiv&eacute;, Sinatra permettra les redirections relatives. Toutefois,
  Sinatra ne sera plus conforme &agrave; la RFC 2616 (HTTP 1.1), qui n&rsquo;autorise
  que les redirections absolues.

  Activez si votre application tourne derri&egrave;re un proxy inverse qui n&rsquo;a
  pas &eacute;t&eacute; correctement configur&eacute;. Notez que la m&eacute;thode <tt>url</tt>
  continuera de produire des URLs absolues, sauf si vous lui passez
  <tt>false</tt> comme second argument.

  <p>D&eacute;sactiv&eacute; par d&eacute;faut.</p>
</dd>

  <dt>add_charsets</dt>
  <dd>
<p>types mime pour lesquels la m&eacute;thode <tt>content_type</tt> va
  automatiquement ajouter l&rsquo;information du <tt>charset</tt>.</p>

  <p>Vous devriez lui ajouter des valeurs plut&ocirc;t que de l&rsquo;&eacute;craser :</p>

  <pre>settings.add_charsets &gt;&gt; "application/foobar"</pre>
</dd>

  <dt>app_file</dt>
  <dd><p>chemin pour le fichier de l&rsquo;application principale, utilis&eacute; pour
  d&eacute;tecter la racine du projet, les dossiers public et vues, et les
  templates en ligne.</p></dd>

  <dt>bind</dt>
  <dd>adresse IP sur laquelle se brancher (par d&eacute;faut : 0.0.0.0). Utiliser
  seulement pour le serveur int&eacute;gr&eacute;.</dd>

  <dt>default_encoding</dt>
  <dd>encodage &agrave; utiliser si inconnu (par d&eacute;faut <tt>"utf-8"</tt>)</dd>

  <dt>dump_errors</dt>
  <dd>afficher les erreurs dans le <tt>log</tt>.
  </dd>

  <dt>environment</dt>
  <dd>environnement courant, par d&eacute;faut <tt>ENV['RACK_ENV']</tt>, ou
  <tt>"development"</tt> si absent.</dd>

  <dt>logging</dt>
  <dd>utiliser le <tt>logger</tt>.</dd>

  <dt>lock</dt>
  <dd>
<p>Place un <tt>lock</tt> autour de chaque requ&ecirc;te, n&rsquo;ex&eacute;cutant donc
  qu&rsquo;une seule requ&ecirc;te par processus Ruby.</p>

  <p>Activ&eacute; si votre application n&rsquo;est pas <tt>thread-safe</tt>. D&eacute;sactiv&eacute;
  par d&eacute;faut.</p>
</dd>

  <dt>method_override</dt>
  <dd>utilise la magie de <tt>_method</tt> afin de permettre des formulaires
  put/delete dans des navigateurs qui ne le permettent pas.

  </dd>
  <dt>port</dt>
  <dd>port &agrave; &eacute;couter. Utiliser seulement pour le serveur int&eacute;gr&eacute;.</dd>

  <dt>prefixed_redirects</dt>
  <dd>si oui ou non <tt>request.script_name</tt> doit &ecirc;tre ins&eacute;r&eacute; dans les
  redirections si un chemin non absolu est utilis&eacute;. Ainsi, <tt>redirect
  '/foo'</tt> se comportera comme <tt>redirect to('/foo')</tt>. D&eacute;sactiv&eacute;
  par d&eacute;faut.</dd>

  <dt>protection</dt>
  <dd>d&eacute;fini s&rsquo;il faut activer ou non la protection contre les attaques web.
  Voir la section protection pr&eacute;c&eacute;dente.</dd>

  <dt>public_dir</dt>
  <dd>alias pour <tt>public_folder</tt>. Voir ci-dessous.</dd>

  <dt>public_folder</dt>
  <dd>chemin pour le dossier &agrave; partir duquel les fichiers publics sont servis.
  Utilis&eacute; seulement si les fichiers statiques doivent &ecirc;tre servis (voir le
  param&egrave;tre <tt>static</tt>). Si non d&eacute;fini, il d&eacute;coule du param&egrave;tre
  <tt>app_file</tt>.</dd>

  <dt>reload_templates</dt>
  <dd>si oui ou non les templates doivent &ecirc;tre recharg&eacute;s entre les requ&ecirc;tes.
  Activ&eacute; en mode d&eacute;veloppement.</dd>

  <dt>root</dt>
  <dd>chemin pour le dossier racine du projet. Si non d&eacute;fini, il d&eacute;coule du
  param&egrave;tre <tt>app_file</tt>.</dd>

  <dt>raise_errors</dt>
  <dd>soulever les erreurs (ce qui arr&ecirc;tera l&rsquo;application). D&eacute;sactiv&eacute; par
  d&eacute;faut sauf lorsque <tt>environment</tt> est d&eacute;fini &agrave;
  <tt>"test"</tt>.</dd>

  <dt>run</dt>
  <dd>si activ&eacute;, Sinatra s&rsquo;occupera de d&eacute;marrer le serveur, ne pas activer si
  vous utiliser rackup ou autres.</dd>

  <dt>running</dt>
  <dd>est-ce que le serveur int&eacute;gr&eacute; est en marche ? ne changez pas ce
  param&egrave;tre !</dd>

  <dt>server</dt>
  <dd>serveur ou liste de serveurs &agrave; utiliser pour le serveur int&eacute;gr&eacute;. Par
  d&eacute;faut [&lsquo;thin&rsquo;, &lsquo;mongrel&rsquo;, &lsquo;webrick&rsquo;], l&rsquo;ordre indiquant la
  priorit&eacute;.</dd>

  <dt>sessions</dt>
  <dd>active le support des sessions bas&eacute;es sur les cookies, en utilisant
  <tt>Rack::Session::Cookie</tt>. Reportez-vous &agrave; la section &lsquo;Utiliser les
  sessions&rsquo; pour plus d&rsquo;informations.</dd>

  <dt>show_exceptions</dt>
  <dd>affiche la trace de l&rsquo;erreur dans le navigateur lorsqu&rsquo;une exception se
  produit. D&eacute;sactiv&eacute; par d&eacute;faut sauf lorsque <tt>environment</tt> est
  d&eacute;fini &agrave; <tt>"development"</tt>.</dd>

  <dt>static</dt>
  <dd>Si oui ou non Sinatra doit s&rsquo;occuper de servir les fichiers statiques.
  D&eacute;sactivez si vous utilisez un serveur capable de le g&eacute;rer lui m&ecirc;me. Le
  d&eacute;sactiver augmentera la performance. Activ&eacute; par d&eacute;faut pour le style
  classique, d&eacute;sactiv&eacute; pour le style modulaire.</dd>

  <dt>static_cache_control</dt>
  <dd>A d&eacute;finir quand Sinatra rend des fichiers statiques pour ajouter les
  en-t&ecirc;tes <tt>Cache-Control</tt>. Utilise le helper <tt>cache_control</tt>.
  D&eacute;sactiv&eacute; par d&eacute;faut. Utiliser un array explicite pour d&eacute;finir des
  plusieurs valeurs : <tt>set :static_cache_control, [:public, :max_age =&gt;
  300]</tt>
</dd>

  <dt>threaded</dt>
  <dd>&agrave; d&eacute;finir &agrave; <tt>true</tt> pour indiquer &agrave; Thin d&rsquo;utiliser
  <tt>EventMachine.defer</tt> pour traiter la requ&ecirc;te.</dd>

  <dt>views</dt>
  <dd>chemin pour le dossier des vues. Si non d&eacute;fini, il d&eacute;coule du param&egrave;tre
  <tt>app_file</tt>.</dd>
</dl>
<a name='Environements'></a>
<h2>Environements</h2>

<p>Il existe trois environnements pr&eacute;d&eacute;finis : <code>"development"</code>,
<code>"production"</code> et <code>"test"</code>. Les environements peuvent &ecirc;tre
s&eacute;lectionn&eacute; via la variable d'environnement +RACK_ENV+. Sa valeur par d&eacute;faut
est <code>"development"</code>. Dans ce mode, tous les templates sont recharg&eacute;s &agrave;
chaque requ&ecirc;te. Des handlers sp&eacute;cifiques pour <code>not_found</code> et
<code>error</code> sont install&eacute;s pour vous permettre d'avoir une pile de trace
dans votre navigateur. En mode <code>"production"</code> et <code>"test"</code> les
templates sont mis en cache par d&eacute;faut.</p>

<p>Pour ex&eacute;cuter votre application dans un environnement diff&eacute;rent, utilisez
l'option <code>-e</code> de Ruby :</p>

<pre><code class="bash">$ ruby mon_application.rb -e [ENVIRONMENT]
</code></pre>

<p>Vous pouvez utiliser une des m&eacute;thodes +development?+, +test?+ et +production?+
pour d&eacute;terminer quel est l'environnement en cours.</p>

<a name='G&eacute;rer%20les%20erreurs'></a>
<h2>G&eacute;rer les erreurs</h2>

<p>Les gestionnaires d'erreur s'ex&eacute;cutent dans le m&ecirc;me contexte que les routes ou
les filtres, ce qui veut dire que vous avez acc&egrave;s (entre autres) aux bons
vieux <code>haml</code>, <code>erb</code>, <code>halt</code>, etc.</p>

<a name='NotFound'></a>
<h3>NotFound</h3>

<p>Quand une exception <tt>Sinatra::NotFound</tt> est soulev&eacute;e, ou que le code
retour est 404, le gestionnaire <tt>not_found</tt> est invoqu&eacute; :</p>

<pre><code class="ruby">not_found do
  'Pas moyen de trouver ce que vous cherchez'
end
</code></pre>

<a name='Error'></a>
<h3>Error</h3>

<p>Le gestionnaire +error+ est invoqu&eacute; &agrave; chaque fois qu'une exception est
soulev&eacute;e dans une route ou un filtre. L'objet exception est accessible via la
variable Rack <code>sinatra.error</code> :</p>

<pre><code class="ruby">error do
  'D&eacute;sol&eacute; mais une m&eacute;chante erreur est survenue - ' + env['sinatra.error'].name
end
</code></pre>

<p>Erreur sur mesure :</p>

<pre><code class="ruby">error MonErreurSurMesure do
  'Donc il est arriv&eacute; ceci...' + env['sinatra.error'].message
end
</code></pre>

<p>Donc si ceci arrive :</p>

<pre><code class="ruby">get '/' do
  raise MonErreurSurMesure, 'quelque chose de mal'
end
</code></pre>

<p>Vous obtenez &ccedil;a :</p>

<p>Donc il est arriv&eacute; ceci... quelque chose de mal</p>

<p>Alternativement, vous pouvez avoir un gestionnaire d'erreur associ&eacute; &agrave; un code
particulier :</p>

<pre><code class="ruby">error 403 do
  'Acc&egrave;s interdit'
end

get '/secret' do
  403
end
</code></pre>

<p>Ou un intervalle :</p>

<pre><code class="ruby">error 400..510 do
  'Boom'
end
</code></pre>

<p>Sinatra installe pour vous quelques gestionnaires <code>not_found</code> et
<code>error</code> g&eacute;n&eacute;riques lorsque vous &ecirc;tes en environnement
<code>development</code>.</p>

<a name='Les%20Middlewares%20Rack'></a>
<h2>Les Middlewares Rack</h2>

<p>Sinatra tourne avec <a href="http://rack.rubyforge.org/">Rack</a>, une interface standard
et minimale pour les web frameworks Ruby. Un des points forts de Rack est le
support de ce que l'on appelle des "middlewares" -- composant qui vient se
situer entre le serveur et votre application, et dont le but est de
visualiser/manipuler la requ&ecirc;te/r&eacute;ponse HTTP, et d'offrir diverses
fonctionnalit&eacute;s classiques.</p>

<p>Sinatra permet de construire facilement des middlewares Rack via la m&eacute;thode de
haut niveau +use+ :</p>

<pre><code class="ruby">require 'sinatra'
require 'mon_middleware_perso'

use Rack::Lint
use MonMiddlewarePerso

get '/bonjour' do
  'Bonjour le monde'
end
</code></pre>

<p>La s&eacute;mantique de +use+ est identique &agrave; celle d&eacute;finie dans le DSL de
<a href="http://rack.rubyforge.org/doc/classes/Rack/Builder.html">Rack::Builder</a>
(le plus souvent utilis&eacute; dans un fichier rackup). Par exemple, la m&eacute;thode
+use+ accepte divers arguments ainsi que des blocs :</p>

<pre><code>use Rack::Auth::Basic do |login, password|
  login == 'admin' &amp;&amp; password == 'secret'
end
</code></pre>

<p>Rack est distribu&eacute; avec une bonne vari&eacute;t&eacute; de middlewares standards pour les
logs, d&eacute;buguer, faire du routage URL, de l'authentification, g&eacute;rer des
sessions. Sinatra utilise beaucoup de ces composants automatiquement via la
configuration, donc pour ceux-ci vous n'aurez pas &agrave; utiliser la m&eacute;thode <code>use</code>.</p>

<a name='Tester'></a>
<h2>Tester</h2>

<p>Les tests pour Sinatra peuvent &ecirc;tre &eacute;crit avec n'importe quelle biblioth&egrave;que
bas&eacute;e sur Rack. <a href="http://gitrdoc.com/brynary/rack-test">Rack::Test</a> est
recommand&eacute; :</p>

<pre><code class="ruby">require 'mon_application_sinatra'
require 'test/unit'
require 'rack/test'

class MonTest &lt; Test::Unit::TestCase
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_ma_racine
    get '/'
    assert_equal 'Bonjour le monde !', last_response.body
  end

  def test_avec_des_parametres
    get '/rencontrer', :name =&gt; 'Frank'
    assert_equal 'Salut Frank !', last_response.body
  end

  def test_avec_rack_env
    get '/', {}, 'HTTP_USER_AGENT' =&gt; 'Songbird'
    assert_equal "Vous utilisez Songbird !", last_response.body
  end
end
</code></pre>

<a name='Sinatra::Base%20-%20Les%20Middlewares,%20Biblioth&egrave;ques,%20et%20Applications%20Modulaires'></a>
<h2>Sinatra::Base - Les Middlewares, Biblioth&egrave;ques, et Applications Modulaires</h2>

<p>D&eacute;finir votre application au niveau sup&eacute;rieur fonctionne bien dans le cas des
micro-applications mais pr&eacute;sente pas mal d'inconv&eacute;nients pour cr&eacute;er des
composants r&eacute;utilisables sous forme de middlewares Rack, de Rails metal, de
simples librairies avec un composant serveur ou m&ecirc;me d'extensions Sinatra. Le
niveau sup&eacute;rieur suppose une configuration dans le style des micro-applications
(une application d'un seul fichier, des r&eacute;pertoires <code>./public</code> et
<code>./views</code>, des logs, une page d'erreur, etc...). C'est l&agrave; que
<code>Sinatra::Base</code> prend tout son int&eacute;r&ecirc;t :</p>

<pre><code class="ruby">require 'sinatra/base'

class MonApplication &lt; Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Bonjour le monde !'
  end
end
</code></pre>

<p>Les m&eacute;thodes de la classe <code>Sinatra::Base</code> sont parfaitement identiques &agrave;
celles disponibles via le DSL de haut niveau. Il suffit de deux modifications
pour transformer la plupart des applications de haut niveau en un composant
<code>Sinatra::Base</code> :</p>

<ul>
<li>Votre fichier doit charger <code>sinatra/base</code> au lieu de <code>sinatra</code>, sinon toutes
les m&eacute;thodes du DSL Sinatra seront import&eacute;es dans l'espace de nom principal.</li>
<li>Les gestionnaires de routes, la gestion d'erreur, les filtres et les options
doivent &ecirc;tre plac&eacute;s dans une classe h&eacute;ritant de <code>Sinatra::Base</code>.</li>
</ul>
<p><code>Sinatra::Base</code> est une page blanche. La plupart des options sont
d&eacute;sactiv&eacute;es par d&eacute;faut, y compris le serveur int&eacute;gr&eacute;. Reportez-vous &agrave;
<a href="http://sinatra.github.com/configuration.html">Options et Configuration</a>
pour plus d'informations sur les options et leur fonctionnement.</p>

<a name='Style%20modulaire%20vs.%20style%20classique'></a>
<h3>Style modulaire vs. style classique</h3>

<p>Contrairement aux id&eacute;es re&ccedil;ues, il n'y a rien de mal &agrave; utiliser le style
classique. Si c'est ce qui convient pour votre application, vous n'avez pas
aucune raison de passer &agrave; une application modulaire.</p>

<p>Le principal inconv&eacute;nient du style classique sur le style modulaire est que vous
ne pouvez avoir qu'une application Ruby par processus Ruby. Si vous pensez en
utiliser plus, passez au style modulaire. Et rien ne vous emp&ecirc;che de mixer style
classique et style modulaire.</p>

<p>Si vous passez d'un style &agrave; l'autre, souvenez-vous des quelques diff&eacute;rences
mineures en ce qui concerne les param&egrave;tres par d&eacute;faut :</p>

<p>Param&egrave;tre         Classique                   Modulaire</p>

<p>app<em>file          fichier chargeant sinatra   fichier h&eacute;ritant de Sinatra::Base
  run               $0 == app</em>file              false
  logging           true                        false
  method<em>override   true                        false
  inline</em>templates  true                        false
  static            true                        false</p>

<a name='Servir%20une%20application%20modulaire'></a>
<h3>Servir une application modulaire</h3>

<p>Il y a deux fa&ccedil;ons de faire pour d&eacute;marrer une application modulaire, d&eacute;marrez
avec <code>run!</code> :</p>

<pre><code class="ruby"># my_app.rb
require 'sinatra/base'

class MyApp &lt; Sinatra::Base
  # ... code de l'application ici ...

  # d&eacute;marre le serveur si ce fichier est directement ex&eacute;cut&eacute;
  run! if app_file == $0
end
</code></pre>

<p>D&eacute;marrez ensuite avec :</p>

<pre><code class="bash">$ ruby my_app.rb
</code></pre>

<p>Ou alors avec un fichier <code>config.ru</code>, qui permet d'utiliser n'importe
quel gestionnaire Rack :</p>

<pre><code class="ruby"># config.ru
require './my_app'
run MyApp
</code></pre>

<p>Ex&eacute;cutez :</p>

<pre><code class="bash">$ rackup -p 4567
</code></pre>

<a name='Utiliser%20une%20application%20de%20style%20classique%20avec%20un%20fichier%20config.ru'></a>
<h3>Utiliser une application de style classique avec un fichier config.ru</h3>

<p>Ecrivez votre application :</p>

<pre><code class="ruby"># app.rb
require 'sinatra'

get '/' do
  'Bonjour le monde !'
end
</code></pre>

<p>Et un fichier <code>config.ru</code> correspondant :</p>

<pre><code class="ruby">require './app'
run Sinatra::Application
</code></pre>

<a name='Quand%20utiliser%20un%20fichier%20config.ru%20?'></a>
<h3>Quand utiliser un fichier config.ru ?</h3>

<p>Quelques cas o&ugrave; vous devriez utiliser un fichier <code>config.ru</code> :</p>

<ul>
<li>Vous souhaitez d&eacute;ployer avec un autre gestionnaire Rack (Passenger, Unicorn,
Heroku, ...).</li>
<li>Vous souhaitez utiliser plus d'une sous-classe de <code>Sinatra::Base</code>.</li>
<li>Vous voulez utiliser Sinatra comme un middleware, non en tant que
endpoint.</li>
</ul>
<p><strong>Il n'est pas n&eacute;cessaire de passer par un fichier <code>config.ru</code> pour la
seule raison que vous &ecirc;tes pass&eacute; au style modulaire, et vous n'avez pas besoin
de passer au style modulaire pour utiliser un fichier <code>config.ru</code>.</strong></p>

<a name='Utiliser%20Sinatra%20comme%20Middleware'></a>
<h3>Utiliser Sinatra comme Middleware</h3>

<p>Non seulement Sinatra peut utiliser d'autres middlewares Rack, il peut
&eacute;galement &ecirc;tre &agrave; son tour utilis&eacute; au-dessus de n'importe quel endpoint Rack
en tant que middleware. Ce endpoint peut tr&egrave;s bien &ecirc;tre une autre
application Sinatra, ou n'importe quelle application bas&eacute;e sur Rack
(Rails/Ramaze/Camping/...) :</p>

<pre><code class="ruby">require 'sinatra/base'

class EcranDeConnexion &lt; Sinatra::Base
  enable :sessions

  get('/connexion') { haml :connexion }

  post('/connexion') do
    if params[:nom] = 'admin' &amp;&amp; params[:motdepasse] = 'admin'
      session['nom_utilisateur'] = params[:nom]
    else
      redirect '/connexion'
    end
  end
end

class MonApp &lt; Sinatra::Base
  # le middleware sera appel&eacute; avant les filtres
  use EcranDeConnexion

  before do
    unless session['nom_utilisateur']
      halt "Acc&egrave;s refus&eacute;, merci de vous &lt;a href='/connexion'&gt;connecter&lt;/a&gt;."
    end
  end

  get('/') { "Bonjour #{session['nom_utilisateur']}." }
end
</code></pre>

<a name='Cr&eacute;ation%20dynamique%20d'applications'></a>
<h3>Cr&eacute;ation dynamique d'applications</h3>

<p>Il se peut que vous ayez besoin de cr&eacute;er une nouvelle application &agrave; l'ex&eacute;cution
sans avoir &agrave; les assigner &agrave; une constante, vous pouvez le faire gr&acirc;ce &agrave;
<code>Sinatra.new</code> :</p>

<pre><code class="ruby">require 'sinatra/base'
mon_app = Sinatra.new { get('/') { "salut" } }
mon_app.run!
</code></pre>

<p>L'application dont elle h&eacute;rite peut &ecirc;tre pass&eacute; en argument optionnel :</p>

<pre><code class="ruby"># config.ru
require 'sinatra/base'

controleur = Sinatra.new do
  enable :logging
  helpers MyHelpers
end

map('/a') do
  run Sinatra.new(controleur) { get('/') { 'a' } }
end

map('/b') do
  run Sinatra.new(controleur) { get('/') { 'b' } }
end
</code></pre>

<p>C'est notamment utile pour tester des extensions &agrave; Sinatra ou bien pour
utiliser Sinatra dans votre propre biblioth&egrave;que.</p>

<p>Cela permet &eacute;galement d'utiliser tr&egrave;s facilement Sinatra comme middleware :</p>

<pre><code class="ruby">require 'sinatra/base'

use Sinatra do
  get('/') { ... }
end

run RailsProject::Application
</code></pre>

<a name='Contextes%20et%20Binding'></a>
<h2>Contextes et Binding</h2>

<p>Le contexte dans lequel vous &ecirc;tes d&eacute;termine les m&eacute;thodes et variables
disponibles.</p>

<a name='Contexte%20de%20l'application/classe'></a>
<h3>Contexte de l'application/classe</h3>

<p>Toute application Sinatra correspond &agrave; une sous-classe de <code>Sinatra::Base</code>.
Si vous utilisez le DSL haut niveau (<code>require 'sinatra'</code>), alors cette
classe est <code>Sinatra::Application</code>, sinon il s'agit de la sous-classe que
vous avez d&eacute;finie. Dans le contexte de la classe, vous avez acc&egrave;s aux m&eacute;thodes
telles que <code>get</code> ou <code>before</code>, mais vous n'avez pas acc&egrave;s aux objets +request+
ou +session+ car c'est la m&ecirc;me classe d'application qui traitera toutes les
requ&ecirc;tes.</p>

<p>Les options d&eacute;finies au moyen de +set+ deviennent des m&eacute;thodes de classe :</p>

<pre><code class="ruby">class MonApp &lt; Sinatra::Base
  # Eh, je suis dans le contexte de l'application !
  set :foo, 42
  foo # =&gt; 42

  get '/foo' do
    # Eh, je ne suis plus dans le contexte de l'application !
  end
end
</code></pre>

<p>Vous avez le binding du contexte de l'application dans :</p>

<ul>
<li>Le corps de la classe d'application</li>
<li>Les m&eacute;thodes d&eacute;finies par les extensions</li>
<li>Le bloc pass&eacute; &agrave; <code>helpers</code>
</li>
<li>Les procs/blocs utilis&eacute;s comme argument pour <code>set</code>
</li>
<li>Le bloc pass&eacute; &agrave; <code>Sinatra.new</code>
</li>
</ul>
<p>Vous pouvez atteindre ce contexte (donc la classe) de la fa&ccedil;on suivante :</p>

<ul>
<li>Via l'objet pass&eacute; dans les blocs <code>configure</code> (<code>configure { |c| ... }</code>)</li>
<li>En utilisant <code>settings</code> dans le contexte de la requ&ecirc;te</li>
</ul>
<a name='Contexte%20de%20la%20requ&ecirc;te/instance'></a>
<h3>Contexte de la requ&ecirc;te/instance</h3>

<p>Pour tout traitement d'une requ&ecirc;te, une nouvelle instance de votre classe
d'application est cr&eacute;&eacute;e et tous vos gestionnaires sont ex&eacute;cut&eacute;s dans ce
contexte. Dans ce dernier, vous pouvez acc&eacute;der aux objets <code>request</code> et
<code>session</code> et faire appel aux fonctions de rendu telles que <code>erb</code> ou <code>haml</code>.
Vous pouvez acc&eacute;der au contexte de l'application depuis le contexte de la
requ&ecirc;te au moyen de <code>settings</code> :</p>

<pre><code class="ruby">class MonApp &lt; Sinatra::Base
  # Eh, je suis dans le contexte de l'application !
  get '/ajouter_route/:nom' do
    # Contexte de la requ&ecirc;te pour '/ajouter_route/:nom'
    @value = 42

    settings.get("/#{params[:nom]}") do
      # Contexte de la requ&ecirc;te pour "/#{params[:nom]}"
      @value # =&gt; nil (on est pas au sein de la m&ecirc;me requ&ecirc;te)
    end

    "Route ajout&eacute;e !"
  end
end
</code></pre>

<p>Vous avez le binding du contexte de la requ&ecirc;te dans :</p>

<ul>
<li>les blocs get/head/post/put/delete/options</li>
<li>les filtres before/after</li>
<li>les m&eacute;thodes utilitaires (d&eacute;finies au moyen de <code>helpers</code>)</li>
<li>les vues/templates</li>
</ul>
<a name='Le%20contexte%20de%20d&eacute;l&eacute;gation'></a>
<h3>Le contexte de d&eacute;l&eacute;gation</h3>

<p>Le contexte de d&eacute;l&eacute;gation se contente de transmettre les appels de m&eacute;thodes au
contexte de classe. Toutefois, il ne se comporte pas &agrave; 100% comme le contexte
de classe car vous n'avez pas le binding de la classe : seules les m&eacute;thodes
sp&eacute;cifiquement d&eacute;clar&eacute;es pour d&eacute;l&eacute;gation sont disponibles et il n'est pas
possible de partager des variables/&eacute;tats avec le contexte de classe
(comprenez : <code>self</code> n'est pas le m&ecirc;me). Vous pouvez ajouter des d&eacute;l&eacute;gation de
m&eacute;thodes en appelant <code>Sinatra::Delegator.delegate :method_name</code>.</p>

<p>Vous avez le binding du contexte de d&eacute;l&eacute;gation dans :</p>

<ul>
<li>Le binding de haut niveau, si vous avez utilis&eacute; <code>require "sinatra"</code>
</li>
<li>Un objet qui inclut le module <code>Sinatra::Delegator</code>
</li>
</ul>
<p>Jetez un oeil pour vous faire une id&eacute;e : voici le
<a href="https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/base.rb#L1609-1633">mixin Sinatra::Delegator</a>
qui <a href="https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/main.rb#L28-30">&eacute;tend l'objet principal</a>.</p>

<a name='Ligne%20de%20commande'></a>
<h2>Ligne de commande</h2>

<p>Les applications Sinatra peuvent &ecirc;tre lanc&eacute;es directement :</p>

<pre><code class="ruby">$ ruby mon_application.rb [-h] [-x] [-e ENVIRONNEMENT] [-p PORT] [-o HOTE] [-s SERVEUR]
</code></pre>

<p>Les options sont :</p>

<pre><code>-h # aide
-p # d&eacute;clare le port (4567 par d&eacute;faut)
-o # d&eacute;clare l'h&ocirc;te (0.0.0.0 par d&eacute;faut)
-e # d&eacute;clare l'environnement (+development+ par d&eacute;faut)
-s # d&eacute;clare le serveur/gestionnaire &agrave; utiliser (thin par d&eacute;faut)
-x # active le mutex lock (off par d&eacute;faut)
</code></pre>

<a name='Configuration%20n&eacute;cessaire'></a>
<h2>Configuration n&eacute;cessaire</h2>

<p>Les versions suivantes de Ruby sont officiellement support&eacute;es :</p>

<dl>
<dt>Ruby 1.8.7</dt>
  <dd>1.8.7 est compl&egrave;tement support&eacute;, toutefois si rien ne vous en emp&ecirc;che,
  nous vous recommandons de passer &agrave; 1.9.2 ou bien de passer &agrave; JRuby ou
  Rubinius. Le support de Ruby 1.8.7 ne sera pas supprim&eacute; avant la sortie de
  Sinatra 2.0 et de Ruby 2.0, &agrave; moins qu&rsquo;un improbable Ruby 1.8.8
  apparaisse. Et m&ecirc;me dans ce cas, nous pourrions continuer &agrave; le supporter.
  **Ruby 1.8.6 n&rsquo;est plus support&eacute;**. Si vous souhaitez utiliser la
  version 1.8.6, vous devez revenir &agrave; Sinatra 1.2 qui continuera &agrave; recevoir
  des corrections de bugs tant que Sinatra 1.4.0 ne sera pas livr&eacute;.</dd>

  <dt>Ruby 1.9.2</dt>
  <dd>1.9.2 est totalement support&eacute; et recommand&eacute;. N&rsquo;utilisez pas 1.9.2p0 car
  il provoque des erreurs de segmentation &agrave; l&rsquo;ex&eacute;cution de Sinatra. Son
  support continuera au minimum jusqu&rsquo;&agrave; la sortie de Ruby 1.9.4/2.0 et le
  support de la derni&egrave;re version 1.9 se poursuivra aussi longtemps que la
  core team de Ruby la supportera.</dd>

  <dt>Ruby 1.9.3</dt>
  <dd>1.9.3 est totalement support&eacute; et recommand&eacute;. Nous vous rappelons que
  passer &agrave; 1.9.3 depuis une version pr&eacute;c&eacute;dente annulera toutes les
  sessions.</dd>


  <dt>Rubinius</dt>
  <dd>Rubinius est officiellement support&eacute; (Rubinius 

  </dd>
<dt>JRuby</dt>
  <dd>JRuby est officiellement support&eacute; (JRuby 
</dd>
</dl>
<p>Nous gardons &eacute;galement un oeil sur les versions Ruby &agrave; venir.</p>

<p>Les impl&eacute;mentations Ruby suivantes ne sont pas officiellement support&eacute;es mais
sont malgr&eacute; tout connues pour permettre de faire fonctionner Sinatra :</p>

<ul>
<li>Versions plus anciennes de JRuby et Rubinius</li>
<li>Ruby Enterprise Edition</li>
<li>MacRuby, Maglev, IronRuby</li>
<li>Ruby 1.9.0 et 1.9.1 (mais nous d&eacute;conseillons leur utilisation)</li>
</ul>
<p>Le fait de ne pas &ecirc;tre officiellement support&eacute; signifie que si quelque chose
ne fonctionne pas uniquement sur cette plateforme alors c'est un probl&egrave;me de la
plateforme et pas un bug de Sinatra.</p>

<p>Nous lan&ccedil;ons &eacute;galement notre int&eacute;gration continue (CI) avec ruby-head (la
future 2.0.0) et la branche 1.9.4, mais &eacute;tant donn&eacute; les &eacute;volutions continuelles,
nous ne pouvont rien garantir, si ce n'est que les versions 1.9.4p0 et 2.0.0p0
seront support&eacute;es.</p>

<p>Sinatra devrait fonctionner sur n'importe quel syst&egrave;me d'exploitation
supportant l'impl&eacute;mentation Ruby choisie.</p>

<p>Il n'est pas possible d'utiliser Sinatra sur Cardinal, SmallRuby, Blueuby ou
toute version de Ruby ant&eacute;rieure &agrave; 1.8.7 &agrave; l'heure actuelle.</p>

<a name='Essuyer%20les%20pl&acirc;tres'></a>
<h2>Essuyer les pl&acirc;tres</h2>

<p>Si vous voulez utiliser la toute derni&egrave;re version de Sinatra, n'ayez pas peur
de faire tourner votre application sur la branche master, cela devrait &ecirc;tre
stable.</p>

<p>Nous publions &eacute;galement une gem de +prerelease+ de temps en temps que vous
pouvez installer comme suit :</p>

<pre><code class="ruby">$ gem install sinatra --pre
</code></pre>

<p>afin d'avoir les toutes derni&egrave;res fonctionnalit&eacute;s.</p>

<a name='Avec%20Bundler'></a>
<h3>Avec Bundler</h3>

<p>Si vous voulez faire tourner votre application avec le tout dernier
Sinatra, <a href="http://gembundler.com/">Bundler</a> est recommand&eacute;.</p>

<p>Tout d'abord, installer bundler si vous ne l'avez pas :</p>

<pre><code class="bash">$ gem install bundler
</code></pre>

<p>Ensuite, dans le dossier de votre projet, cr&eacute;ez un fichier +Gemfile+ :</p>

<pre><code class="ruby">source :rubygems
gem 'sinatra', :git =&gt; "git://github.com/sinatra/sinatra.git"

# autres d&eacute;pendances
gem 'haml'                    # par exemple, si vous utilisez haml
gem 'activerecord', '~&gt; 3.0'  # peut-&ecirc;tre que vous avez &eacute;galement besoin
                              # de ActiveRecord 3.x
</code></pre>

<p>Notez que vous aurez &agrave; lister toutes les d&eacute;pendances de votre application dans
ce fichier. Les d&eacute;pendances directes de Sinatra (Rack et Tilt) seront
automatiquement t&eacute;l&eacute;charg&eacute;es et ajout&eacute;es par Bundler.</p>

<p>Maintenant, vous pouvez faire tourner votre application de la fa&ccedil;on suivante :</p>

<pre><code class="bash">$ bundle exec ruby myapp.rb
</code></pre>

<a name='Faites%20le%20vous-m&ecirc;me'></a>
<h3>Faites le vous-m&ecirc;me</h3>

<p>Cr&eacute;ez un clone local et d&eacute;marrez votre application avec le dossier
<code>sinatra/lib</code> dans le <code>$LOAD_PATH</code> :</p>

<pre><code class="bash">$ cd myapp
$ git clone git://github.com/sinatra/sinatra.git
$ ruby -Isinatra/lib myapp.rb

A l'avenir, pour mettre &agrave; jour le code source de Sinatra :

```bash
$ cd myapp/sinatra
$ git pull
</code></pre>

<a name='Installez%20globalement'></a>
<h3>Installez globalement</h3>

<p>Vous pouvez construire la gem vous-m&ecirc;me :</p>

<pre><code class="bash">$ git clone git://github.com/sinatra/sinatra.git
$ cd sinatra
$ rake sinatra.gemspec
$ rake install
</code></pre>

<p>Si vous installez les gems en tant que +root+, la derni&egrave;re &eacute;tape sera :</p>

<pre><code class="bash">$ sudo rake install
</code></pre>

<a name='Versions'></a>
<h2>Versions</h2>

<p>Sinatra se conforme aux (versions s&eacute;mantiques)[http://semver.org/], aussi bien
SemVer que SemVerTag.</p>

<a name='Mais%20encore'></a>
<h2>Mais encore</h2>

<ul>
<li>
<a href="http://www.sinatrarb.com/">Site internet</a> - Plus de documentation,
de news, et des liens vers d'autres ressources.</li>
<li>
<a href="http://www.sinatrarb.com/contributing">Contribuer</a> - Vous avez trouv&eacute; un
bug ? Besoin d'aide ? Vous avez un patch ?</li>
<li><a href="http://github.com/sinatra/sinatra/issues">Suivi des probl&egrave;mes</a></li>
<li><a href="http://twitter.com/sinatra">Twitter</a></li>
<li>[Mailing List])(http://groups.google.com/group/sinatrarb/topics)</li>
<li>
<a href="irc://chat.freenode.net/#sinatra">IRC : #sinatra</a> sur http://freenode.net</li>
<li>
<a href="irc://chat.freenode.net/#sinatra">IRC : #sinatra</a> on http://freenode.net</li>
<li>
<a href="http://sinatra-book.gittr.com">Sinatra Book</a> Tutoriels et recettes</li>
<li>
<a href="http://recipes.sinatrarb.com/">Sinatra Recipes</a> trucs et astuces r&eacute;dig&eacute;s par 
la communaut&eacute;</li>
<li>Documentation API de la <a href="http://rubydoc.info/gems/sinatra">derni&egrave;re version</a>
ou du <a href="http://rubydoc.info/github/sinatra/sinatra">HEAD courant</a> sur
http://rubydoc.info</li>
<li><a href="http://travis-ci.org/sinatra/sinatra">CI server</a></li>
</ul>
</body></html>
