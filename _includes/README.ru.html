<div class='toc'>
	<ol class='level-1'>
		<li><a href='#%D0%9C%D0%B0%D1%80%D1%88%D1%80%D1%83%D1%82%D1%8B'>Маршруты</a></li>
		<ol class='level-2'>
			<li><a href='#%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D1%8F'>Условия</a></li>
			<li><a href='#%D0%92%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F'>Возвращаемые значения</a></li>
		</ol>
		<li><a href='#%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D1%84%D0%B0%D0%B9%D0%BB%D1%8B'>Статические файлы</a></li>
		<li><a href='#%D0%92%D0%B8%D0%B4%D1%8B%20/%20%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Виды / Шаблоны</a></li>
		<ol class='level-2'>
			<li><a href='#Haml%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Haml шаблоны</a></li>
			<li><a href='#Erb%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Erb шаблоны</a></li>
			<li><a href='#Erubis%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Erubis шаблоны</a></li>
			<li><a href='#Builder%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Builder шаблоны</a></li>
			<li><a href='#Nokogiri%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Nokogiri шаблоны</a></li>
			<li><a href='#Sass%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Sass шаблоны</a></li>
			<li><a href='#Scss%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Scss шаблоны</a></li>
			<li><a href='#Less%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Less шаблоны</a></li>
			<li><a href='#Liquid%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Liquid шаблоны</a></li>
			<li><a href='#Markdown%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Markdown шаблоны</a></li>
			<li><a href='#Textile%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Textile шаблоны</a></li>
			<li><a href='#RDoc%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>RDoc шаблоны</a></li>
			<li><a href='#Radius%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Radius шаблоны</a></li>
			<li><a href='#Markaby%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Markaby шаблоны</a></li>
			<li><a href='#CoffeeScript%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>CoffeeScript шаблоны</a></li>
			<li><a href='#%D0%92%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Встроенные шаблоны</a></li>
			<li><a href='#%D0%94%D0%BE%D1%81%D1%82%D1%83%D0%BF%20%D0%BA%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%BC%20%D0%B2%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B0%D1%85'>Доступ к переменным в шаблонах</a></li>
			<li><a href='#%D0%92%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Вложенные шаблоны</a></li>
			<li><a href='#%D0%98%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Именные шаблоны</a></li>
		</ol>
		<li><a href='#%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B%20%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%BD%D0%B8%D0%BA%D0%B8'>Методы помощники</a></li>
		<li><a href='#%D0%A4%D0%B8%D0%BB%D1%8C%D1%82%D1%80%D1%8B'>Фильтры</a></li>
		<li><a href='#%D0%9F%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5'>Прерывание</a></li>
		<li><a href='#%D0%9F%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0'>Передача</a></li>
		<li><a href='#%D0%94%D0%BE%D1%81%D0%BF%D1%83%D1%82%20%D0%BA%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%83%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0'>Доспут к объекту запроса</a></li>
		<li><a href='#%D0%9A%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F'>Конфигурация</a></li>
		<li><a href='#%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0%20%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA'>Обработка ошибок</a></li>
		<ol class='level-2'>
			<li><a href='#%C2%A0NotFound'> NotFound</a></li>
			<li><a href='#%D0%9E%D1%88%D0%B8%D0%B1%D0%BA%D0%B8'>Ошибки</a></li>
		</ol>
		<li><a href='#Mime%20%D1%82%D0%B8%D0%BF%D1%8B'>Mime типы</a></li>
		<li><a href='#Rack%20%E2%80%9C%D0%BF%D1%80%D0%BE%D1%81%D0%BB%D0%BE%D0%B9%D0%BA%D0%B8%E2%80%9D'>Rack “прослойки”</a></li>
		<li><a href='#%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5'>Тестирование</a></li>
		<li><a href='#Sinatra::Base%20%E2%80%94%20%E2%80%9C%D0%BF%D1%80%D0%BE%D1%81%D0%BB%D0%BE%D0%B9%D0%BA%D0%B8%E2%80%9D,%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8%20%D0%B8%20%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F'>Sinatra::Base — “прослойки”, библиотеки и модульные приложения</a></li>
		<ol class='level-2'>
			<li><a href='#%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA%20%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D1%8B%D1%85%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9'>Запуск модульных приложений</a></li>
			<li><a href='#%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA%20%E2%80%9C%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85%E2%80%9D%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9%20%D1%81%20config.ru'>Запуск “классических” приложений с config.ru</a></li>
			<li><a href='#%D0%9A%D0%BE%D0%B3%D0%B4%D0%B0%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20config.ru?'>Когда использовать config.ru?</a></li>
			<li><a href='#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20Sinatra%20%D0%B2%20%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B5%20%E2%80%9C%D0%BF%D1%80%D0%BE%D1%81%D0%BB%D0%BE%D0%B9%D0%BA%D0%B8%E2%80%9D'>Использование Sinatra в качестве “прослойки”</a></li>
		</ol>
		<li><a href='#%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%B8%20%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D0%BA%D0%B0'>Области видимости и привязка</a></li>
		<ol class='level-2'>
			<li><a href='#%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20/%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0'>Область видимости приложения / класса</a></li>
			<li><a href='#%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0/%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%B0'>Область видимости запроса/экземпляра</a></li>
			<li><a href='#%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F'>Область видимости делегирования</a></li>
		</ol>
		<li><a href='#%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%B0%D1%8F%20%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0'>Командная строка</a></li>
		<li><a href='#%D0%9D%D0%B0%20%D0%BE%D1%81%D1%82%D1%80%D0%B8%D0%B5'>На острие</a></li>
		<li><a href='#%D0%91%D0%BE%D0%BB%D1%8C%D1%88%D0%B5%20%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B8'>Больше информации</a></li>
	</ol>
</div>



<p><em>Внимание: Этот документ является
переводом Английской версии и может быть
устаревшим</em></p>

<p>Sinatra — это предметно-ориентированный
язык (DSL) для быстрого создания
приложений на Ruby с приложением минимума
усилий:</p>

<pre># myapp.rb
require 'sinatra'

get '/' do
  'Hello world!'
end</pre>

<p>Установите gem и запустите приложение с
помощью:</p>

<pre>gem install sinatra
ruby -rubygems myapp.rb</pre>

<p>Результат будет тут: <a
href="http://localhost:4567">localhost:4567</a></p>

<a name='%D0%9C%D0%B0%D1%80%D1%88%D1%80%D1%83%D1%82%D1%8B'></a>
<h2>Маршруты</h2>

<p>В Sinatra маршрут — это пара: HTTP метод и
шаблон (образец) URL. Каждый маршрут
ассоциирован с блоком:</p>

<pre>get '/' do
  .. что-то показать ..
end

post '/' do
  .. что-то создать ..
end

put '/' do
  .. что-то обновить ..
end

delete '/' do
  .. что-то удалить ..
end</pre>

<p>Маршруты сверяются с запросом по
очередности определения. Первый же
совпавший с запросом маршрут и будет
вызван.</p>

<p>Шаблоны маршрутов могут включать в себя
параметры доступные в <tt>params</tt> xэше:</p>

<pre>get '/hello/:name' do
  # соответствует &quot;GET /hello/foo&quot; и &quot;GET /hello/bar&quot;,
  # где params[:name] 'foo' или 'bar'
  &quot;Hello #{params[:name]}!&quot;
end</pre>

<p>Можно также использовать именные
параметры в переменных блоков:</p>

<pre>get '/hello/:name' do |n|
  &quot;Hello #{n}!&quot;
end</pre>

<p>Шаблоны маршрутов также могут включать
splat (wildcard, *, любая строка символов)
параметры доступные в <tt>params[:splat]</tt>
массиве.</p>

<pre>get '/say/*/to/*' do
  # соответствует /say/hello/to/world
  params[:splat] # =&gt; [&quot;hello&quot;, &quot;world&quot;]
end

get '/download/*.*' do
  # соответствует /download/path/to/file.xml
  params[:splat] # =&gt; [&quot;path/to/file&quot;, &quot;xml&quot;]
end</pre>

<p>Маршруты также могут использовать
регулярные выражения в качестве шаблона
URL:</p>

<pre>get %r{/hello/([\w]+)} do
  &quot;Hello, #{params[:captures].first}!&quot;
end</pre>

<p>Или с параметром блока:</p>

<pre>get %r{/hello/([\w]+)} do |c|
  &quot;Hello, #{c}!&quot;
end</pre>

<a name='%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D1%8F'></a>
<h3>Условия</h3>

<p>Маршруты могут включать различные
условия совпадений, такие как user agent:</p>

<pre>get '/foo', :agent =&gt; /Songbird (\d\.\d)[\d\/]*?/ do
  &quot;You're using Songbird version #{params[:agent][0]}&quot;
end

get '/foo' do
  # соответствует non-songbird браузерам
end</pre>

<p>Другими доступными условиями являются
<tt>host_name</tt> и <tt>provides</tt>:</p>

<pre>get '/', :host_name =&gt; /^admin\./ do
  &quot;Admin Area, Access denied!&quot;
end

get '/', :provides =&gt; 'html' do
  haml :index
end

get '/', :provides =&gt; ['rss', 'atom', 'xml'] do
  builder :feed
end</pre>

<p>Довольно легко можно задать собственные
условия:</p>

<pre>set(:probability) { |value| condition { rand &lt;= value } }

get '/win_a_car', :probability =&gt; 0.1 do
  &quot;You won!&quot;
end

get '/win_a_car' do
  &quot;Sorry, you lost.&quot;
end</pre>

<a name='%D0%92%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F'></a>
<h3>Возвращаемые значения</h3>

<p>Возвращаемое значение блока маршрута
ограничивается телом ответа, которое
будет передано HTTP клиенту, или следующей
“прослойкой” (middleware, промежуточная
программа) в Rack стеке. Чаще всего это
строка, как в вышеизложенных примерах. Но
и другие значения также приемлемы.</p>

<p>Вы можете вернуть любой объект, который
будет либо корректным Rack ответом, Rack
телом ответа, либо кодом состояния HTTP:</p>
<ul><li>
<p>Массив с тремя переменными: <tt>[status (Fixnum),
headers (Hash), response body (должен отвечать на
#each)]</tt></p>
</li><li>
<p>Массив с двумя переменными: <tt>[status (Fixnum),
response body (должен отвечать на #each)]</tt></p>
</li><li>
<p>Объект, отвечающий на <tt>#each</tt>, который
передает только строковые типы данных в
этот блок</p>
</li><li>
<p>Fixnum, соответствующий коду состояния HTTP</p>
</li></ul>

<p>Таким образом мы легко можем создать
поточный пример:</p>

<pre>class Stream
  def each
    100.times { |i| yield &quot;#{i}\n&quot; }
  end
end

get('/') { Stream.new }</pre>

<a name='%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D1%84%D0%B0%D0%B9%D0%BB%D1%8B'></a>
<h2>Статические файлы</h2>

<p>Статические файлы отдаются из <tt>./public</tt>
директории. Вы можете указать другое
место, используя <tt>:public</tt> опцию:</p>

<pre>set :public, File.dirname(__FILE__) + '/static'</pre>

<p>Учтите, что имя директории со
статическими файлами не включено в URL.
Например, файл <tt>./public/css/style.css</tt> будет
доступен как <tt><a
href="http://example.com/css/style.css">example.com/css/style.css</a></tt>.</p>

<a name='%D0%92%D0%B8%D0%B4%D1%8B%20/%20%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h2>Виды / Шаблоны</h2>

<p>Шаблоны по умолчанию будут использованы
из директории <tt>./views</tt>. Для
использования другой директории:</p>

<pre>set :views, File.dirname(__FILE__) + '/templates'</pre>

<p>Важно помнить, что вы всегда должны
указывать шаблоны с помощью символов,
даже если это подкаталог (в этом случае
используйте <tt>:'subdir/template'</tt>). Вы должны
использовать символ, иначе методы,
ответственные за рендеринг, отобразят
просто переданную им строку.</p>

<a name='Haml%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Haml шаблоны</h3>

<p>Haml gem/библиотека необходима для
рендеринга HAML шаблонов:</p>

<pre>## Вам нужно будет подключить haml gem в приложении
require 'haml'

get '/' do
  haml :index
end</pre>

<p>Отрисует <tt>./views/index.haml</tt>.</p>

<p><a
href="http://haml-lang.com/docs/yardoc/file.HAML_REFERENCE.html#options">Опции
Haml</a> могут быть установлены глобально
через конфигурацию Sinatra, см. <a
href="http://www.sinatrarb.com/configuration.html">Опции и
Конфигурация</a>, и переопределены
локально.</p>

<pre>set :haml, :format =&gt; :html5 # :xhtml - Haml формат по умолчанию

get '/' do
  haml :index, :format =&gt; :html4 # переопределен
end</pre>

<a name='Erb%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Erb шаблоны</h3>

<pre>## Вам нужно будет подключить erb в приложении
require 'erb'

get '/' do
  erb :index
end</pre>

<p>Отрисует <tt>./views/index.erb</tt></p>

<a name='Erubis%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Erubis шаблоны</h3>

<p>Erubis gem/библиотека необходима для
рендеринга erubis шаблонов:</p>

<pre>## Вам нужно будет подключить erubis в приложении
require 'erubis'

get '/' do
  erubis :index
end</pre>

<p>Отрисует <tt>./views/index.erubis</tt></p>

<a name='Builder%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Builder шаблоны</h3>

<p>Builder gem/библиотека необходима для
рендеринга builder шаблонов:</p>

<pre>## Вам нужно будет подключить builder в приложении
require 'builder'

get '/' do
  builder :index
end</pre>

<p>Отрисует <tt>./views/index.builder</tt>.</p>

<a name='Nokogiri%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Nokogiri шаблоны</h3>

<p>Nokogiri gem/библиотека необходима для
рендеринга nokogiri шаблонов:</p>

<pre>## Вам нужно будет подключить nokogiri в приложении
require 'nokogiri'

get '/' do
  nokogiri :index
end</pre>

<p>Отрисует <tt>./views/index.nokogiri</tt>.</p>

<a name='Sass%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Sass шаблоны</h3>

<p>Haml gem/библиотека необходима для
рендеринга Sass шаблонов:</p>

<pre>## Вам нужно будет подключить haml или sass в приложении
require 'sass'

get '/stylesheet.css' do
  sass :stylesheet
end</pre>

<p>Отрисует <tt>./views/stylesheet.sass</tt>.</p>

<p><a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Опции
Sass</a> могут быть установлены глобально
через конфигурацию Sinatra, см. <a
href="http://www.sinatrarb.com/configuration.html">Опции и
Конфигурация</a>, и переопределены
локально.</p>

<pre>set :sass, :style =&gt; :compact # :nested - стиль Sass по умолчанию

get '/stylesheet.css' do
  sass :stylesheet, :style =&gt; :expanded # переопределен
end</pre>

<a name='Scss%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Scss шаблоны</h3>

<p>Haml gem/библиотека необходима для
рендеринга Scss шаблонов:</p>

<pre>## Вам нужно будет подключить haml или sass в приложении
require 'sass'

get '/stylesheet.css' do
  scss :stylesheet
end</pre>

<p>Отрисует <tt>./views/stylesheet.scss</tt>.</p>

<p><a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Опции
Scss</a> могут быть установлены глобально
через конфигурацию Sinatra, см. <a
href="http://www.sinatrarb.com/configuration.html">Опции и
Конфигурация</a>, и переопределены
локально.</p>

<pre>set :scss, :style =&gt; :compact # :nested - стиль Scss по умолчанию

get '/stylesheet.css' do
  scss :stylesheet, :style =&gt; :expanded # переопределен
end</pre>

<a name='Less%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Less шаблоны</h3>

<p>less gem/библиотека необходима для
рендеринга Less шаблонов:</p>

<pre>## Вам нужно будет подключить less в приложении
require 'less'

get '/stylesheet.css' do
  less :stylesheet
end</pre>

<p>Отрисует <tt>./views/stylesheet.less</tt>.</p>

<a name='Liquid%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Liquid шаблоны</h3>

<p>liquid gem/библиотека необходима для
рендеринга liquid шаблонов:</p>

<pre>## Вам нужно будет подключить liquid в приложении
require 'liquid'

get '/' do
  liquid :index
end</pre>

<p>Отрисует <tt>./views/index.liquid</tt>.</p>

<p>Так как в Liquid шаблонах невозможно
вызывать методы из Ruby (кроме <tt>yield</tt>), то
вы почти всегда будете передавать
локальные переменные:</p>

<pre>liquid :index, :locals =&gt; { :key =&gt; 'value' }</pre>

<a name='Markdown%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Markdown шаблоны</h3>

<p>rdiscount gem/библиотека необходима для
рендеринга Markdown шаблонов:</p>

<pre>## Вам нужно будет подключить rdiscount в приложении
require &quot;rdiscount&quot;

get '/' do
  markdown :index
end</pre>

<p>Отрисует <tt>./views/index.markdown</tt> (<tt>md</tt> и
<tt>mkd</tt> также являются допустимыми
файловыми расширениями).</p>

<p>В Markdown невозможно вызывать методы или
передавать локальные переменные.
Следовательно, вам скорее всего придется
использовать этот шаблон совместно с
другим движком рендеринга:</p>

<pre>erb :overview, :locals =&gt; { :text =&gt; markdown(:introduction) }</pre>

<p>Заметьте, что вы можете вызывать метод
<tt>markdown</tt> из других шаблонов:</p>

<pre>%h1 Hello From Haml!
%p= markdown(:greetings)</pre>

<p>Также возможно обрабатывать Markdown с
помощью BlueCloth, а не RDiscount:</p>

<pre>require 'bluecloth'

Tilt.register 'markdown', BlueClothTemplate
Tilt.register 'mkd',      BlueClothTemplate
Tilt.register 'md',       BlueClothTemplate

get '/' do
  markdown :index
end</pre>

<p>Отрисует <tt>./views/index.md</tt> с помощью BlueCloth.</p>

<a name='Textile%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Textile шаблоны</h3>

<p>RedCloth gem/библиотека необходима для
рендеринга Textile шаблонов:</p>

<pre>## Вам нужно будет подключить redcloth в приложении
require &quot;redcloth&quot;

get '/' do
  textile :index
end</pre>

<p>Отрисует <tt>./views/index.textile</tt>.</p>

<p>В textile невозможно вызывать методы или
передавать локальные переменные.
Следовательно, вам скорее всего придется
использовать этот шаблон совместно с
другим движком рендеринга:</p>

<pre>erb :overview, :locals =&gt; { :text =&gt; textile(:introduction) }</pre>

<p>Заметьте, что вы можете вызывать метод
textile из других шаблонов:</p>

<pre>%h1 Hello From Haml!
%p= textile(:greetings)</pre>

<a name='RDoc%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>RDoc шаблоны</h3>

<p>RDoc gem/библиотека необходима для
рендеринга RDoc шаблонов:</p>

<pre>## Вам нужно будет подключить rdoc в приложении
require &quot;rdoc&quot;

get '/' do
  rdoc :index
end</pre>

<p>Отрисует <tt>./views/index.rdoc</tt>.</p>

<p>В rdoc невозможно вызывать методы или
передавать локальные переменные.
Следовательно, вам скорее всего придется
использовать этот шаблон совместно с
другим движком рендеринга:</p>

<pre>erb :overview, :locals =&gt; { :text =&gt; rdoc(:introduction) }</pre>

<p>Заметьте, что вы можете вызывать метод rdoc
из других шаблонов:</p>

<pre>%h1 Hello From Haml!
%p= rdoc(:greetings)</pre>

<a name='Radius%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Radius шаблоны</h3>

<p>radius gem/библиотека необходима для
рендеринга Radius шаблонов:</p>

<pre>## Вам нужно будет подключить radius в приложении
require 'radius'

get '/' do
  radius :index
end</pre>

<p>Отрисует <tt>./views/index.radius</tt>.</p>

<p>Так как в Radius шаблоне невозможно
вызывать методы из Ruby (кроме <tt>yield</tt>),  то
вы почти всегда будете передавать
локальные переменные:</p>

<pre>radius :index, :locals =&gt; { :key =&gt; 'value' }</pre>

<a name='Markaby%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Markaby шаблоны</h3>

<p>markaby gem/библиотека необходима для
рендеринга Markaby шаблонов:</p>

<pre>## Вам нужно будет подключить markaby в приложении
require 'markaby'

get '/' do
  markaby :index
end</pre>

<p>Отрисует <tt>./views/index.mab</tt>.</p>

<a name='CoffeeScript%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>CoffeeScript шаблоны</h3>

<p>coffee-script gem/библиотека и `coffee` бинарный
файл необходимы для рендеринга CoffeeScript
шаблонов:</p>

<pre>## Вам нужно будет подключить coffee-script в приложении
require 'coffee-script'

get '/application.js' do
  coffee :application
end</pre>

<p>Отрисует <tt>./views/application.coffee</tt>.</p>

<a name='%D0%92%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Встроенные шаблоны</h3>

<pre>get '/' do
  haml '%div.title Hello World'
end</pre>

<p>Отрисует встроенный (строчный) шаблон.</p>

<a name='%D0%94%D0%BE%D1%81%D1%82%D1%83%D0%BF%20%D0%BA%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%BC%20%D0%B2%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B0%D1%85'></a>
<h3>Доступ к переменным в шаблонах</h3>

<p>Шаблоны интерпретируются в том же
контексте, что и обработчики маршрутов.
Переменные экзмепляра,  установленные в
процесе обработки маршрутов, будут
доступны напрямую в шаблонах:</p>

<pre>get '/:id' do
  @foo = Foo.find(params[:id])
  haml '%h1= @foo.name'
end</pre>

<p>Либо установите их через хеш локальных
переменных:</p>

<pre>get '/:id' do
  foo = Foo.find(params[:id])
  haml '%h1= foo.name', :locals =&gt; { :foo =&gt; foo }
end</pre>

<p>Это обычно используется когда шаблоны
рендерятся как частные (partials) из других
шаблонов.</p>

<a name='%D0%92%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Вложенные шаблоны</h3>

<p>Шаблоны также могут быть определены в
конце файла-исходника:</p>

<pre>require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Hello world!!!!!</pre>

<p>Заметьте: Вложенные шаблоны,
определенные в файле-исходнике, который
подключил sinatra, будут автоматически
загружены. Вызовите <tt>enable :inline_templates</tt>
напрямую, если у вас вложенные шаблоны в
других файлах.</p>

<a name='%D0%98%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Именные шаблоны</h3>

<p>Шаблоны также могут быть определены,
используя <tt>template</tt> метод:</p>

<pre>template :layout do
  &quot;%html\n  =yield\n&quot;
end

template :index do
  '%div.title Hello World!'
end

get '/' do
  haml :index
end</pre>

<p>Если шаблон с именем “layout” существует,
то он будет использован каждый раз, когда
шаблоны будут отрисовываться. Вы можете
отключать layout-шаблон в каждом конкретном
случае с помощью <tt>:layout =&gt; false</tt> или
отключить его для всего приложения,
например, так: <tt>set :haml, :layout =&gt; false</tt>.</p>

<pre>get '/' do
  haml :index, :layout =&gt; !request.xhr?
end</pre>

<a name='%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B%20%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%BD%D0%B8%D0%BA%D0%B8'></a>
<h2>Методы помощники</h2>

<p>Используйте <tt>helpers</tt> метод для
определения методов помощников для
дальнейшего  использования в
обработчиках маршрутов и шаблонах:</p>

<pre>helpers do
  def bar(name)
    &quot;#{name}bar&quot;
  end
end

get '/:name' do
  bar(params[:name])
end</pre>

<a name='%D0%A4%D0%B8%D0%BB%D1%8C%D1%82%D1%80%D1%8B'></a>
<h2>Фильтры</h2>

<p>Before-фильтры выполняются перед каждым
запросом в том же контексте, что и
маршруты. Фильтры могут изменять как
запрос, так и ответ на него. Переменные
экземпляра, установленные в фильтрах,
доступны в маршрутах и шаблонах:</p>

<pre>before do
  @note = 'Hi!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @note #=&gt; 'Hi!'
  params[:splat] #=&gt; 'bar/baz'
end</pre>

<p>After-фильтры выполняются после каждого
запроса в том же контексте, что и пути.
Фильтры могут изменять как запрос, так и
ответ на него. Переменные экземпляра,
установленные в before-фильтрах и
маршрутах, будут доступны в after-фильтрах:</p>

<pre>after do
  puts response.status
end</pre>

<p>Фильтры могут использовать шаблоны URL и
будут интерпретированы, только если путь
запроса совпадет с этим шаблоном:</p>

<pre>before '/protected/*' do
  authenticate!
end

after '/create/:slug' do |slug|
  session[:last_slug] = slug
end</pre>

<a name='%D0%9F%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5'></a>
<h2>Прерывание</h2>

<p>Чтобы незамедлительно прервать
обработку запроса внутри фильтра или
маршрута, используйте:</p>

<pre>halt</pre>

<p>Можно также указать статус при
прерывании:</p>

<pre>halt 410</pre>

<p>Тело:</p>

<pre>halt 'this will be the body'</pre>

<p>И то, и другое:</p>

<pre>halt 401, 'go away!'</pre>

<p>Можно указать заголовки:</p>

<pre>halt 402, {'Content-Type' =&gt; 'text/plain'}, 'revenge'</pre>

<a name='%D0%9F%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0'></a>
<h2>Передача</h2>

<p>Маршрут может передать обработку
запроса следующему совпадающему
маршруту, используя <tt>pass</tt>:</p>

<pre>get '/guess/:who' do
  pass unless params[:who] == 'Frank'
  'You got me!'
end

get '/guess/*' do
  'You missed!'
end</pre>

<p>Блок маршрута сразу же прерывается, и
контроль переходит к следующему
совпадающему маршруту. Если
соответствующий маршрут не найден, то
ответом на запрос будет 404.</p>

<a name='%D0%94%D0%BE%D1%81%D0%BF%D1%83%D1%82%20%D0%BA%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%83%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0'></a>
<h2>Доспут к объекту запроса</h2>

<p>Объект входящего запроса доступен на
уровне обработки запроса (в фильтрах,
маршрутах, обработчиках ошибок) с
помощью `request` метода:</p>

<pre># приложение запущено на http://example.com/example
get '/foo' do
  request.body              # тело запроса, посланное клиентом (см. ниже)
  request.scheme            # &quot;http&quot;
  request.script_name       # &quot;/example&quot;
  request.path_info         # &quot;/foo&quot;
  request.port              # 80
  request.request_method    # &quot;GET&quot;
  request.query_string      # &quot;&quot;
  request.content_length    # длина тела запроса
  request.media_type        # медиа тип тела запроса
  request.host              # &quot;example.com&quot;
  request.get?              # true (для других участвующих HTTP глаголов есть похожие методы)
  request.form_data?        # false
  request[&quot;SOME_HEADER&quot;]    # значение SOME_HEADER заголовка
  request.referer           # источник запроса клиента либо '/'
  request.user_agent        # user agent (используется для :agent условия)
  request.cookies           # хеш куки браузера
  request.xhr?              # является ли запрос ajax запросом?
  request.url               # &quot;http://example.com/example/foo&quot;
  request.path              # &quot;/example/foo&quot;
  request.ip                # IP адрес клиента
  request.secure?           # false
  request.env               # env хеш как получено Rack
end</pre>

<p>Некоторые опции, такие как <tt>script_name</tt>
или <tt>path_info</tt> могут быть переписаны:</p>

<pre>before { request.path_info = &quot;/&quot; }

get &quot;/&quot; do
  &quot;all requests end up here&quot;
end</pre>

<p><tt>request.body</tt> является IO или StringIO объектом:</p>

<pre>post &quot;/api&quot; do
  request.body.rewind  # в случае, если кто-то уже прочитал тело запроса
  data = JSON.parse request.body.read
  &quot;Hello #{data['name']}!&quot;
end</pre>

<a name='%D0%9A%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F'></a>
<h2>Конфигурация</h2>

<p>Этот блок исполняется один раз при
старте в любом окружении, режиме (environment):</p>

<pre>configure do
  ...
end</pre>

<p>Будет запущено, когда окружение (RACK_ENV
переменная) установлена в <tt>:production</tt>:</p>

<pre>configure :production do
  ...
end</pre>

<p>Будет запущено, когда окружение
<tt>:production</tt> или <tt>:test</tt>:</p>

<pre>configure :production, :test do
  ...
end</pre>

<a name='%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0%20%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA'></a>
<h2>Обработка ошибок</h2>

<p>Обработчики ошибок исполняются в том же
контексте, что и маршруты, before-фильтры, а
это означает, что всякие прелести вроде
<tt>haml</tt>, <tt>erb</tt>, <tt>halt</tt> и т.д. доступны и
им.</p>

<a name='%C2%A0NotFound'></a>
<h3> NotFound</h3>

<p>Когда возбуждено исключение
<tt>Sinatra::NotFound</tt>, или кодом ответа является
404, то будет вызван <tt>not_found</tt> обработчик:</p>

<pre>not_found do
  'This is nowhere to be found.'
end</pre>

<a name='%D0%9E%D1%88%D0%B8%D0%B1%D0%BA%D0%B8'></a>
<h3>Ошибки</h3>

<p>Обработчик ошибок <tt>error</tt> будет вызван,
когда исключение возбуждено из блока
маршрута, либо из фильтра.
Объект-исключение доступен как
переменная <tt>sinatra.error</tt> в Rack:</p>

<pre>error do
  'Sorry there was a nasty error - ' + env['sinatra.error'].name
end</pre>

<p>Частные ошибки:</p>

<pre>error MyCustomError do
  'So what happened was...' + request.env['sinatra.error'].message
end</pre>

<p>Тогда, если это произошло:</p>

<pre>get '/' do
  raise MyCustomError, 'something bad'
end</pre>

<p>То вы получите:</p>

<pre>So what happened was... something bad</pre>

<p>Также вы можете установить обработчик
ошибок для кода состояния HTTP:</p>

<pre>error 403 do
  'Access forbidden'
end

get '/secret' do
  403
end</pre>

<p>Либо набора кодов:</p>

<pre>error 400..510 do
  'Boom'
end</pre>

<p>Sinatra устанавливает специальные
<tt>not_found</tt> и <tt>error</tt> обработчики, когда
запущена в режиме разработки (окружение
<tt>:development</tt>).</p>

<a name='Mime%20%D1%82%D0%B8%D0%BF%D1%8B'></a>
<h2>Mime типы</h2>

<p>Когда вы используете <tt>send_file</tt> или
статические файлы, у вас могут быть mime
типы, которые Sinatra не понимает по
умолчанию. Используйте <tt>mime_type</tt> для их
регистрации по расширению файла:</p>

<pre>mime_type :foo, 'text/foo'</pre>

<p>Вы также можете использовать это в
<tt>content_type</tt> помощнике:</p>

<pre>content_type :foo</pre>

<a name='Rack%20%E2%80%9C%D0%BF%D1%80%D0%BE%D1%81%D0%BB%D0%BE%D0%B9%D0%BA%D0%B8%E2%80%9D'></a>
<h2>Rack “прослойки”</h2>

<p>Sinatra использует <a href="http://rack.rubyforge.org/">Rack</a>,
минимальный стандартный  интерфейс для
веб-фреймворков на Ruby. Одной из самых
интересных для разработчиков
возможностей Rack является поддержка
“прослоек” (“middleware”) — компонентов,
“сидящих” между сервером и вашим
приложением, которые отслеживают и/или
манипулируют HTTP запросами/ответами для
предоставления различной
функциональности.</p>

<p>В Sinatra очень просто использовать такие
“прослойки” с помощью метода <tt>use</tt>:</p>

<pre>require 'sinatra'
require 'my_custom_middleware'

use Rack::Lint
use MyCustomMiddleware

get '/hello' do
  'Hello World'
end</pre>

<p>Семантика <tt>use</tt> идентична той, что
определена для <a
href="http://rack.rubyforge.org/doc/classes/Rack/Builder.html">Rack::Builder</a>
DSL (чаще всего используется в rackup файлах).
Например, <tt>use</tt> метод принимает
множественные переменные, также как и
блоки:</p>

<pre>use Rack::Auth::Basic do |username, password|
  username == 'admin' &amp;&amp; password == 'secret'
end</pre>

<p>Rack распространяется с различными
стандартными “прослойками” для
логирования, отладки, маршрутизации URL,
аутентификации, обработки сессий. Sinatra
использует многие из этих компонентов
автоматически, основываясь на
конфигурации, чтобы вам не приходилось
регистрировать/использовать (<tt>use</tt>) их
вручную.</p>

<a name='%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5'></a>
<h2>Тестирование</h2>

<p>Тесты для Sinatra приложений могут быть
написаны с помощью библиотек,
фреймворков, поддерживающих
тестирование Rack. <a
href="http://gitrdoc.com/brynary/rack-test">Rack::Test</a>
рекомендован:</p>

<pre>require 'my_sinatra_app'
require 'test/unit'
require 'rack/test'

class MyAppTest &lt; Test::Unit::TestCase
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_my_default
    get '/'
    assert_equal 'Hello World!', last_response.body
  end

  def test_with_params
    get '/meet', :name =&gt; 'Frank'
    assert_equal 'Hello Frank!', last_response.body
  end

  def test_with_rack_env
    get '/', {}, 'HTTP_USER_AGENT' =&gt; 'Songbird'
    assert_equal &quot;You're using Songbird!&quot;, last_response.body
  end
end</pre>

<p>Заметьте: Встроенные модули Sinatra::Test и
Sinatra::TestHarness являются устаревшими,
начиная с 0.9.2 релиза.</p>

<a name='Sinatra::Base%20%E2%80%94%20%E2%80%9C%D0%BF%D1%80%D0%BE%D1%81%D0%BB%D0%BE%D0%B9%D0%BA%D0%B8%E2%80%9D,%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8%20%D0%B8%20%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F'></a>
<h2>Sinatra::Base — “прослойки”, библиотеки и модульные приложения</h2>

<p>Описание своего приложения самым
простейшим способом (с помощью DSL
верхнего уровня, как в примерах выше)
работает отлично для крохотных
приложений, но имеет множество
недостатков, когда надо создать
компоненты, такие как Rack middleware
(“прослойки”), Rails metal, простые
библиотеки с серверными компонентами,
расширения Sinatra. DSL верхнего уровня
загрязняет пространство имен <tt>Object</tt> и
подразумевает стиль конфигурации
микро-приложения (например, единый файл
приложения, ./public и ./views директории,
создание логов, страницу деталей об
исключениях  и т.д.). И тут на помощь
приходит Sinatra::Base:</p>

<pre>require 'sinatra/base'

class MyApp &lt; Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Hello world!'
  end
end</pre>

<p>Методы, доступные Sinatra::Base сабклассам
идентичны тем, что доступны в DSL верхнего
уровня. Большинство приложений верхнего
уровня могут быть конвертированы в
Sinatra::Base компоненты с помощью двух
модификаций:</p>
<ul><li>
<p>Вы должны подключать <tt>sinatra/base</tt> вместо
<tt>sinatra</tt>, иначе все методы
предоставляемые Sinatra будут
импортированные в глобальное
пространство имен.</p>
</li><li>
<p>Поместите все маршруты, обработчики
ошибок, фильтры и опции в сабкласс
Sinatra::Base.</p>
</li></ul>

<p><tt>Sinatra::Base</tt> — это чистый лист.
Большинство опций, включая встроенный
сервер, по умолчанию отключены. Смотрите
<a href="http://www.sinatrarb.com/configuration.html">Опции и
Конфигурация</a> для детальной информации
об опциях и их поведении.</p>

<a name='%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA%20%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D1%8B%D1%85%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9'></a>
<h3>Запуск модульных приложений</h3>

<p>Есть два общепринятых способа запускать
модульные приложения: запуск напрямую с
помощью <tt>run!</tt>:</p>

<pre># my_app.rb
require 'sinatra/base'

class MyApp &lt; Sinatra::Base
  # ... здесь код приложения ...

  # запускаем сервер, если исполняется текущий файл
  run! if app_file == $0
end</pre>

<p>И запускаем с помощью:</p>

<pre>ruby my_app.rb</pre>

<p>Или с помощью конфигурационного файла
<tt>config.ru</tt>, который позволяет
использовать любой Rack-совместимый
сервер приложений.</p>

<pre># config.ru
require 'my_app'
run MyApp</pre>

<p>Запускаем:</p>

<pre>rackup -p 4567</pre>

<a name='%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA%20%E2%80%9C%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85%E2%80%9D%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9%20%D1%81%20config.ru'></a>
<h3>Запуск “классических” приложений с config.ru</h3>

<p>Файл приложения:</p>

<pre># app.rb
require 'sinatra'

get '/' do
  'Hello world!'
end</pre>

<p>И соответствующий <tt>config.ru</tt>:</p>

<pre>require 'app'
run Sinatra::Application</pre>

<a name='%D0%9A%D0%BE%D0%B3%D0%B4%D0%B0%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20config.ru?'></a>
<h3>Когда использовать config.ru?</h3>

<p>Вот несколько причин, по которым вы,
возможно, захотите использовать
<tt>config.ru</tt>:</p>
<ul><li>
<p>вы хотите разворачивать свое приложение
на различных Rack-совместимых серверах
(Passenger, Unicorn, Heroku, …).</p>
</li><li>
<p>вы хотите использовать более одного
сабкласса <tt>Sinatra::Base</tt>.</p>
</li><li>
<p>вы хотите использовать Sinatra только в
качестве “прослойки” Rack.</p>
</li></ul>

<p><b>Совсем необязательно переходить на
использование <tt>config.ru</tt> лишь потому, что
вы стали использовать модульный стиль
приложения. И необязательно
использовать модульный стиль, чтобы
запускать приложение с помощью
<tt>config.ru</tt>.</b></p>

<a name='%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20Sinatra%20%D0%B2%20%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B5%20%E2%80%9C%D0%BF%D1%80%D0%BE%D1%81%D0%BB%D0%BE%D0%B9%D0%BA%D0%B8%E2%80%9D'></a>
<h3>Использование Sinatra в качестве “прослойки”</h3>

<p>Не только сама Sinatra может использовать
“прослойки” Rack, но и любое Sinatra
приложение само может быть добавлено к
любому Rack эндпоинту в качестве
“прослойки”. Этим эндпоинтом может быть
другое Sinatra приложение, или приложение,
основанное на Rack (Rails/Ramaze/Camping/…).</p>

<pre>require 'sinatra/base'

class LoginScreen &lt; Sinatra::Base
  enable :sessions

  get('/login') { haml :login }

  post('/login') do
    if params[:name] = 'admin' and params[:password] = 'admin'
      session['user_name'] = params[:name]
    else
      redirect '/login'
    end
  end
end

class MyApp &lt; Sinatra::Base
  # &quot;прослойка&quot; будет запущена перед фильтрами
  use LoginScreen

  before do
    unless session['user_name']
      halt &quot;Access denied, please &lt;a href='/login'&gt;login&lt;/a&gt;.&quot;
    end
  end

  get('/') { &quot;Hello #{session['user_name']}.&quot; }
end</pre>

<a name='%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%B8%20%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D0%BA%D0%B0'></a>
<h2>Области видимости и привязка</h2>

<p>Текущая область видимости определяет
методы и переменные, доступные в данный
момент.</p>

<a name='%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20/%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0'></a>
<h3>Область видимости приложения / класса</h3>

<p>Любое Sinatra приложение соответствует
сабклассу Sinatra::Base. Если вы  используете DSL
верхнего  уровня (<tt>require 'sinatra'</tt>), то этим
классом будет  Sinatra::Application, иначе это
будет сабкласс, который вы создали
вручную. На уровне класса вам будут
доступны такие методы, как `get` или `before`,
но вы не сможете иметь доступ к объектам
`request` или `session`, так как существует только
единый класс приложения для всех
запросов.</p>

<p>Опции, созданные с помощью `set`, являются
методами уровня класса:</p>

<pre>class MyApp &lt; Sinatra::Base
  # Я в области видимости приложения!
  set :foo, 42
  foo # =&gt; 42

  get '/foo' do
    # Я больше не в области видимости приложения!
  end
end</pre>

<p>У вас будет область видимости приложения
внутри:</p>
<ul><li>
<p>Тела вашего класса приложения</p>
</li><li>
<p>Методов, определенных расширениями</p>
</li><li>
<p>Блока, переданного в `helpers`</p>
</li><li>
<p>Блоков, использованных как значения для
`set`</p>
</li></ul>

<p>Вы можете получить доступ к объекту
области видимости (классу приложения)
следующими способами:</p>
<ul><li>
<p>объект, переданный блокам конфигурации
(<tt>configure { |c| ... }</tt>)</p>
</li><li>
<p>`settings` внутри области видимости запроса</p>
</li></ul>

<a name='%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0/%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%B0'></a>
<h3>Область видимости запроса/экземпляра</h3>

<p>Для каждого входящего запроса будет
создан новый экземпляр вашего
приложения, и все блоки обработчика
будут запущены в этом контексте. В этой
области видимости вам доступны `request` и
`session` объекты, вызовы методов рендеринга,
такие как `erb` или `haml`. Вы можете получить
доступ к области видимости приложения из
контекста запроса, используя помощник
`settings`:</p>

<pre>class MyApp &lt; Sinatra::Base
  # Я в области видимости приложения!
  get '/define_route/:name' do
    # Область видимости запроса '/define_route/:name'
    @value = 42

    settings.get(&quot;/#{params[:name]}&quot;) do
      # Область видимости запроса &quot;/#{params[:name]}&quot;
      @value # =&gt; nil (другой запрос)
    end

    &quot;Route defined!&quot;
  end
end</pre>

<p>У вас будет область видимости запроса
внутри:</p>
<ul><li>
<p>get/head/post/put/delete блоков</p>
</li><li>
<p>before/after фильтрах</p>
</li><li>
<p>методах помощниках</p>
</li><li>
<p>шаблонах/видах</p>
</li></ul>

<a name='%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F'></a>
<h3>Область видимости делегирования</h3>

<p>Область видимости делегирования просто
перенаправляет методы в область
видимости класса. Однако, оно не
полностью на 100% ведет себя как область
видимости класса, так как у вас нету
привязки к классу: только методы, явно
помеченные для делегирования, будут
доступны, а переменных/состояний области
видимости класса не будет (иначе говоря,
у вас будет другой `self` объект). Вы можете
непосредственно добавить методы
делегирования, используя
<tt>Sinatra::Delegator.delegate :method_name</tt>.</p>

<p>У вас будет контекст делегирования
внутри:</p>
<ul><li>
<p>Привязки верхнего уровня, если вы
сделали <tt>require &quot;sinatra&quot;</tt></p>
</li><li>
<p>Объекта, расширенного с помощью примеси
`Sinatra::Delegator`</p>
</li></ul>

<p>Посмотрите сами в код: тут <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/base.rb#L1128">Sinatra::Delegator
примесь</a> будет <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/main.rb#L28">включена
в глобальное пространство имен</a>.</p>

<a name='%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%B0%D1%8F%20%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0'></a>
<h2>Командная строка</h2>

<p>Sinatra приложения могут быть запущены
напрямую:</p>

<pre>ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-o HOST] [-s HANDLER]</pre>

<p>Опции включают:</p>

<pre>-h # помощь
-p # настроить порт (по умолчанию 4567)
-o # настроить хост (по умолчанию 0.0.0.0)
-e # настроить окружение, режим (по умолчанию development)
-s # настроить rack сервер/обработчик (по умолчанию thin)
-x # включить мьютекс (по умолчанию выключен)</pre>

<a name='%D0%9D%D0%B0%20%D0%BE%D1%81%D1%82%D1%80%D0%B8%D0%B5'></a>
<h2>На острие</h2>

<p>Если вы хотите использовать новейший код
Sinatra, то создайте локальный клон и
запускайте свое приложение с <tt>sinatra/lib</tt>
директорией в <tt>LOAD_PATH</tt>:</p>

<pre>cd myapp
git clone git://github.com/sinatra/sinatra.git
ruby -Isinatra/lib myapp.rb</pre>

<p>Также вы можете добавить <tt>sinatra/lib</tt>
директорию в <tt>LOAD_PATH</tt> приложения:</p>

<pre>$LOAD_PATH.unshift File.dirname(__FILE__) + '/sinatra/lib'
require 'rubygems'
require 'sinatra'

get '/about' do
  &quot;I'm running version &quot; + Sinatra::VERSION
end</pre>

<p>Чтобы обновить исходники Sinatra:</p>

<pre>cd myproject/sinatra
git pull</pre>

<a name='%D0%91%D0%BE%D0%BB%D1%8C%D1%88%D0%B5%20%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B8'></a>
<h2>Больше информации</h2>
<ul><li>
<p><a href="http://www.sinatrarb.com/">Вебсайт проекта</a> -
Дополнительная документация, новости и
ссылки на другие ресурсы.</p>
</li><li>
<p><a href="http://www.sinatrarb.com/contributing">Участие</a> -
Нашли баг? Нужна помощь?	Написали патч?</p>
</li><li>
<p><a href="http://github.com/sinatra/sinatra/issues">Слежение за
проблемами</a></p>
</li><li>
<p><a href="http://twitter.com/sinatra">Twitter</a></p>
</li><li>
<p><a href="http://groups.google.com/group/sinatrarb/topics">Лист
рассылки</a></p>
</li><li>
<p><a href="irc://chat.freenode.net/#sinatra">IRC: #sinatra</a> on <a
href="http://freenode.net">freenode.net</a> </p>
</li></ul>
