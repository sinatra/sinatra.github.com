<div class='toc'>
	<ol class='level-1'>
		<li><a href='#Rutas'>Rutas</a></li>
		<ol class='level-2'>
			<li><a href='#Condiciones'>Condiciones</a></li>
			<li><a href='#Valores%20de%20Retorno'>Valores de Retorno</a></li>
			<li><a href='#Comparadores%20de%20Rutas%20Personalizados'>Comparadores de Rutas Personalizados</a></li>
		</ol>
		<li><a href='#Archivos%20Est%C3%A1ticos'>Archivos Estáticos</a></li>
		<li><a href='#Vistas%20/%20Plantillas'>Vistas / Plantillas</a></li>
		<ol class='level-2'>
			<li><a href='#Plantillas%20Haml'>Plantillas Haml</a></li>
			<li><a href='#Plantillas%20Erb'>Plantillas Erb</a></li>
			<li><a href='#Plantillas%20Erubis'>Plantillas Erubis</a></li>
			<li><a href='#Plantillas%20Builder'>Plantillas Builder</a></li>
			<li><a href='#Plantillas%20Nokogiri'>Plantillas Nokogiri</a></li>
			<li><a href='#Plantillas%20Sass'>Plantillas Sass</a></li>
			<li><a href='#Plantillas%20Scss'>Plantillas Scss</a></li>
			<li><a href='#Plantillas%20Less'>Plantillas Less</a></li>
			<li><a href='#Plantillas%20Liquid'>Plantillas Liquid</a></li>
			<li><a href='#Plantillas%20Markdown'>Plantillas Markdown</a></li>
			<li><a href='#Plantillas%20Textile'>Plantillas Textile</a></li>
			<li><a href='#Plantillas%20RDoc'>Plantillas RDoc</a></li>
			<li><a href='#Plantillas%20Radius'>Plantillas Radius</a></li>
			<li><a href='#Plantillas%20Markaby'>Plantillas Markaby</a></li>
			<li><a href='#Plantillas%20Slim'>Plantillas Slim</a></li>
			<li><a href='#Plantillas%20CoffeeScript'>Plantillas CoffeeScript</a></li>
			<li><a href='#Plantillas%20Embebidas'>Plantillas Embebidas</a></li>
			<li><a href='#Accediendo%20a%20Variables%20en%20Plantillas'>Accediendo a Variables en Plantillas</a></li>
			<li><a href='#Plantillas%20Inline'>Plantillas Inline</a></li>
			<li><a href='#Plantillas%20Nombradas'>Plantillas Nombradas</a></li>
			<li><a href='#Asociando%20Extensiones%20de%20Archivo'>Asociando Extensiones de Archivo</a></li>
			<li><a href='#Agregando%20Tu%20Propio%20Motor%20de%20Renderizado'>Agregando Tu Propio Motor de Renderizado</a></li>
		</ol>
		<li><a href='#Filtros'>Filtros</a></li>
		<li><a href='#Ayudantes'>Ayudantes</a></li>
		<ol class='level-2'>
			<li><a href='#Usando%20Sesiones'>Usando Sesiones</a></li>
			<li><a href='#Interrupci%C3%B3n'>Interrupción</a></li>
			<li><a href='#Paso'>Paso</a></li>
			<li><a href='#Ejecutando%20Otra%20Ruta'>Ejecutando Otra Ruta</a></li>
			<li><a href='#Asignando%20el%20C%C3%B3digo%20de%20Estado,%20los%20Encabezados%20y%20el%20Cuerpo%20de%20una%20Respuesta'>Asignando el Código de Estado, los Encabezados y el Cuerpo de una Respuesta</a></li>
			<li><a href='#Tipos%20Mime'>Tipos Mime</a></li>
			<li><a href='#Generando%20URLs'>Generando URLs</a></li>
			<li><a href='#Redirecci%C3%B3n%20del%20Navegador'>Redirección del Navegador</a></li>
			<li><a href='#Cache%20Control'>Cache Control</a></li>
			<li><a href='#Enviando%20Archivos'>Enviando Archivos</a></li>
			<li><a href='#Accediendo%20al%20objeto%20de%20la%20petici%C3%B3n'>Accediendo al objeto de la petición</a></li>
			<li><a href='#Archivos%20Adjuntos'>Archivos Adjuntos</a></li>
			<li><a href='#Buscando%20los%20Archivos%20de%20las%20Plantillas'>Buscando los Archivos de las Plantillas</a></li>
		</ol>
		<li><a href='#Configuraci%C3%B3n'>Configuración</a></li>
		<ol class='level-2'>
			<li><a href='#Configuraciones%20Disponibles'>Configuraciones Disponibles</a></li>
		</ol>
		<li><a href='#Manejo%20de%20Errores'>Manejo de Errores</a></li>
		<ol class='level-2'>
			<li><a href='#No%20encontrado%20%3Cem%3E(Not%20Found)%3C/em%3E'>No encontrado <em>(Not Found)</em></a></li>
			<li><a href='#Error'>Error</a></li>
		</ol>
		<li><a href='#Rack%20Middleware'>Rack Middleware</a></li>
		<li><a href='#Pruebas'>Pruebas</a></li>
		<li><a href='#Sinatra::Base%20-%20Middleware,%20Librer%C3%ADas,%20y%20Aplicaciones%20Modulares'>Sinatra::Base - Middleware, Librerías, y Aplicaciones Modulares</a></li>
		<ol class='level-2'>
			<li><a href='#Estilo%20Modular%20vs.%20Cl%C3%A1sico'>Estilo Modular vs. Clásico</a></li>
			<li><a href='#Sirviendo%20una%20Aplicaci%C3%B3n%20Modular'>Sirviendo una Aplicación Modular</a></li>
			<li><a href='#Usando%20una%20Aplicaci%C3%B3n%20Cl%C3%A1sica%20con%20un%20Archivo%20config.ru'>Usando una Aplicación Clásica con un Archivo config.ru</a></li>
			<li><a href='#%C2%BFCu%C3%A1ndo%20Usar%20config.ru?'>¿Cuándo Usar config.ru?</a></li>
			<li><a href='#Utilizando%20Sinatra%20como%20Middleware'>Utilizando Sinatra como Middleware</a></li>
		</ol>
		<li><a href='#%C3%81mbitos%20y%20Ligaduras'>Ámbitos y Ligaduras</a></li>
		<ol class='level-2'>
			<li><a href='#%C3%81mbito%20de%20Aplicaci%C3%B3n/Clase'>Ámbito de Aplicación/Clase</a></li>
			<li><a href='#%C3%81mbito%20de%20Petici%C3%B3n/Instancia'>Ámbito de Petición/Instancia</a></li>
			<li><a href='#%C3%81mbito%20de%20Delegaci%C3%B3n'>Ámbito de Delegación</a></li>
		</ol>
		<li><a href='#L%C3%ADnea%20de%20Comandos'>Línea de Comandos</a></li>
		<li><a href='#Requerimientos'>Requerimientos</a></li>
		<li><a href='#A%20la%20Vanguardia'>A la Vanguardia</a></li>
		<ol class='level-2'>
			<li><a href='#Con%20Bundler'>Con Bundler</a></li>
			<li><a href='#Con%20Git'>Con Git</a></li>
			<li><a href='#Instalaci%C3%B3n%20Global'>Instalación Global</a></li>
		</ol>
		<li><a href='#Lecturas%20Recomendadas'>Lecturas Recomendadas</a></li>
	</ol>
</div>



<p><em>Atención: Este documento es una traducción de la versión en inglés
y puede estar desactualizado.</em></p>

<p>Sinatra es un DSL para crear aplicaciones web rápidamente en Ruby con un
mínimo esfuerzo:</p>

<pre># miapp.rb
require 'sinatra'

get '/' do
  'Hola mundo!'
end</pre>

<p>Instalá la gem y ejecutá la aplicación con:</p>

<pre>gem install sinatra
ruby -rubygems miapp.rb</pre>

<p>Podés verla en: <a href="http://localhost:4567">localhost:4567</a></p>

<p>Es recomendable además ejecutar <tt>gem install thin</tt>, ya que Sinatra
lo va a utilizar cuando esté disponible.</p>

<a name='Rutas'></a>
<h2>Rutas</h2>

<p>En Sinatra, una ruta está compuesta por un método HTTP y un patrón de
una URL. Cada ruta se asocia con un bloque:</p>

<pre>get '/' do
  .. mostrar algo ..
end

post '/' do
  .. crear algo ..
end

put '/' do
  .. actualizar algo ..
end

delete '/' do
  .. aniquilar algo ..
end

options '/' do
  .. informar algo ..
end</pre>

<p>Las rutas son comparadas en el orden en el que son definidas. La primer
ruta que coincide con la petición es invocada.</p>

<p>Los patrones de las rutas pueden incluir parámetros nombrados, accesibles
a través de el hash <tt>params</tt>:</p>

<pre>get '/hola/:nombre' do
  # coincide con &quot;GET /hola/foo&quot; y &quot;GET /hola/bar&quot;
  # params[:nombre] es 'foo' o 'bar'
  &quot;Hola #{params[:nombre]}!&quot;
end</pre>

<p>También podés acceder a los parámetros nombrados usando parámetros de
bloque:</p>

<pre>get '/hola/:nombre' do |n|
  &quot;Hola #{n}!&quot;
end</pre>

<p>Los patrones de ruta también pueden incluir parámetros splat (o
wildcard), accesibles a través del arreglo <tt>params[:splat]</tt>.</p>

<pre>get '/decir/*/al/*' do
  # coincide con /decir/hola/al/mundo
  params[:splat] # =&gt; [&quot;hola&quot;, &quot;mundo&quot;]
end

get '/descargar/*.*' do
  # coincide con /descargar/path/al/archivo.xml
  params[:splat] # =&gt; [&quot;path/al/archivo&quot;, &quot;xml&quot;]
end</pre>

<p>Rutas con Expresiones Regulares:</p>

<pre>get %r{/hola/([\w]+)} do
  &quot;Hola, #{params[:captures].first}!&quot;
end</pre>

<p>O con un parámetro de bloque:</p>

<pre>get %r{/hola/([\w]+)} do |c|
  &quot;Hola, #{c}!&quot;
end</pre>

<a name='Condiciones'></a>
<h3>Condiciones</h3>

<p>Las rutas pueden incluir una variedad de condiciones de selección, como
por ejemplo el user agent:</p>

<pre>get '/foo', :agent =&gt; /Songbird (\d\.\d)[\d\/]*?/ do
  &quot;Estás usando la versión de Songbird #{params[:agent][0]}&quot;
end

get '/foo' do
  # Coincide con browsers que no sean songbird
end</pre>

<p>Otras condiciones disponibles son <tt>host_name</tt> y <tt>provides</tt>:</p>

<pre>get '/', :host_name =&gt; /^admin\./ do
  &quot;Área de Administración, Acceso denegado!&quot;
end

get '/', :provides =&gt; 'html' do
  haml :index
end

get '/', :provides =&gt; ['rss', 'atom', 'xml'] do
  builder :feed
end</pre>

<p>Podés definir tus propias condiciones fácilmente:</p>

<pre>set(:probabilidad) { |valor| condition { rand &lt;= valor } }

get '/gana_un_auto', :probabilidad =&gt; 0.1 do
  &quot;Ganaste!&quot;
end

get '/gana_un_auto' do
  &quot;Lo siento, perdiste.&quot;
end</pre>

<a name='Valores%20de%20Retorno'></a>
<h3>Valores de Retorno</h3>

<p>El valor de retorno de un bloque de ruta determina al menos el cuerpo de la
respuesta que se le pasa al cliente HTTP o al siguiente middleware en la
pila de Rack. Lo más común es que sea un string, como en los ejemplos
anteriores. Sin embargo, otros valor también son aceptados.</p>

<p>Podés devolver cualquier objeto que sea una respuesta Rack válida, un
objeto que represente el cuerpo de una respuesta Rack o un código de
estado HTTP:</p>
<ul><li>
<p>Un arreglo con tres elementos: <tt>[estado (Fixnum), cabeceras (Hash),
cuerpo de la respuesta (responde a #each)]</tt></p>
</li><li>
<p>Un arreglo con dos elementos: <tt>[estado (Fixnum), cuerpo de la respuesta
(responde a #each)]</tt></p>
</li><li>
<p>Un objeto que responde a <tt>#each</tt> y que le pasa únicamente strings
al bloque dado</p>
</li><li>
<p>Un Fixnum representando el código de estado</p>
</li></ul>

<p>De esa manera podemos, por ejemplo, implementar fácilmente un streaming:</p>

<pre>class Stream
  def each
    100.times { |i| yield &quot;#{i}\n&quot; }
  end
end

get('/') { Stream.new }</pre>

<a name='Comparadores%20de%20Rutas%20Personalizados'></a>
<h3>Comparadores de Rutas Personalizados</h3>

<p>Como se mostró anteriormente, Sinatra permite utilizar Strings y
expresiones regulares para definir las rutas.  Sin embargo, la cosa no
termina ahí.  Podés definir tus propios comparadores muy fácilmente:</p>

<pre>class PattronCualquieraMenos
  Match = Struct.new(:captures)

  def initialize(excepto)
    @excepto  = excepto
    @caputras = Match.new([])
  end

  def match(str)
    @caputras unless @excepto === str
  end
end

def cualquiera_menos(patron)
  PatronCualquieraMenos.new(patron)
end

get cualquiera_menos(&quot;/index&quot;) do
  # ...
end</pre>

<p>Tené en cuenta que el ejemplo anterior es un poco rebuscado.  Un resultado
similar puede conseguirse más sencillamente:</p>

<pre>get // do
  pass if request.path_info == &quot;/index&quot;
  # ...
end</pre>

<p>O, usando un lookahead negativo:</p>

<pre>get %r{^(?!/index$)} do
  # ...
end</pre>

<a name='Archivos%20Est%C3%A1ticos'></a>
<h2>Archivos Estáticos</h2>

<p>Los archivos estáticos son servidos desde el directorio público
<tt>./public</tt>. Podés especificar una ubicación diferente ajustando la
opción <tt>:public</tt>:</p>

<pre>set :public, File.dirname(__FILE__) + '/estaticos'</pre>

<p>Notá que el nombre del directorio público no está incluido en la URL.
Por ejemplo, el archivo <tt>./public/css/style.css</tt> se accede a través
de <tt><a
href="http://ejemplo.com/css/style.css">ejemplo.com/css/style.css</a></tt>.</p>

<a name='Vistas%20/%20Plantillas'></a>
<h2>Vistas / Plantillas</h2>

<p>Se asume que las plantillas están ubicadas directamente bajo el directorio
<tt>./views</tt>. Para usar un directorio de vistas diferente:</p>

<pre>set :views, File.dirname(__FILE__) + '/plantillas'</pre>

<p>Es importante acordarse que siempre tenés que referenciar a las plantillas
con símbolos, incluso cuando se encuentran en un subdirectorio (en este
caso tenés que usar <tt>:'subdir/plantilla'</tt>). Tenés que usar un
símbolo porque los métodos de renderización van a renderizar
directamente cualquier string que se les pase como argumento.</p>

<a name='Plantillas%20Haml'></a>
<h3>Plantillas Haml</h3>

<p>La gem/librería <tt>haml</tt> es necesaria para para renderizar plantillas
HAML:</p>

<pre># Vas a necesitar requerir haml en tu app
require 'haml'

get '/' do
  haml :index
end</pre>

<p>Renderiza <tt>./views/index.haml</tt>.</p>

<p>Las <a
href="http://haml-lang.com/docs/yardoc/file.HAML_REFERENCE.html#options">opciones
de Haml</a> pueden ser ajustadas globalmente a través de las
configuraciones de Sinatra, ver <a
href="http://www.sinatrarb.com/configuration.html">Opciones y
Configuraciones</a>, y reemplazadas individualmente.</p>

<pre>set :haml, :format =&gt; :html5 # el formato por defecto de Haml es :xhtml

get '/' do
  haml :index, :format =&gt; :html4 # reemplazado
end</pre>

<a name='Plantillas%20Erb'></a>
<h3>Plantillas Erb</h3>

<pre># Vas a necesitar requerir erb en tu app
require 'erb'

get '/' do
  erb :index
end</pre>

<p>Renderiza <tt>./views/index.erb</tt></p>

<a name='Plantillas%20Erubis'></a>
<h3>Plantillas Erubis</h3>

<p>La gem/librería <tt>erubis</tt> es necesaria para renderizar plantillas
Erubis:</p>

<pre># Vas a necesitar requerir erubis en tu app
require 'erubis'

get '/' do
  erubis :index
end</pre>

<p>Renderiza <tt>./views/index.erubis</tt>.</p>

<p>También es posible reemplazar Erb con Erubis:</p>

<pre>require 'erubis'
Tilt.register :erb, Tilt[:erubis]

get '/' do
  erb :index
end</pre>

<p>Renderiza <tt>./views/index.erb</tt> con Erubis.</p>

<a name='Plantillas%20Builder'></a>
<h3>Plantillas Builder</h3>

<p>La gem/librería <tt>builder</tt> es necesaria para renderizar plantillas
builder:</p>

<pre># Vas a necesitar requerir builder en tu app
require 'builder'

get '/' do
  builder :index
end</pre>

<p>Renderiza <tt>./views/index.builder</tt>.</p>

<a name='Plantillas%20Nokogiri'></a>
<h3>Plantillas Nokogiri</h3>

<p>La gem/librería <tt>nokogiri</tt> es necesaria para renderizar plantillas
nokogiri:</p>

<pre># Vas a necesitar requerir nokogiri en tu app
require 'nokogiri'

get '/' do
  nokogiri :index
end</pre>

<p>Renderiza <tt>./views/index.nokogiri</tt>.</p>

<a name='Plantillas%20Sass'></a>
<h3>Plantillas Sass</h3>

<p>La gem/librería <tt>haml</tt> o <tt>sass</tt> es necesaria para renderizar
plantillas Sass:</p>

<pre># Vas a necesitar requerir haml o sass en tu app
require 'sass'

get '/stylesheet.css' do
  sass :stylesheet
end</pre>

<p>Renderiza <tt>./views/stylesheet.sass</tt>.</p>

<p>Las <a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">opciones
de Sass</a> pueden ser ajustadas globalmente a través de las
configuraciones de Sinatra, ver <a
href="http://www.sinatrarb.com/configuration.html">Opciones y
Configuraciones</a>, y reemplazadas individualmente.</p>

<pre>set :sass, :style =&gt; :compact # el estilo por defecto de Sass es :nested

get '/stylesheet.css' do
  sass :stylesheet, :style =&gt; :expanded # reemplazado
end</pre>

<a name='Plantillas%20Scss'></a>
<h3>Plantillas Scss</h3>

<p>La gem/librería <tt>haml</tt> o <tt>sass</tt>es necesaria para renderizar
plantillas Scss:</p>

<pre># Vas a necesitar requerir haml o sass en tu app
require 'sass'

get '/stylesheet.css' do
  scss :stylesheet
end</pre>

<p>Renderiza <tt>./views/stylesheet.scss</tt>.</p>

<p>Las <a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">opciones
de Scss</a> pueden ser ajustadas globalmente a través de las
configuraciones de Sinatra, ver <a
href="http://www.sinatrarb.com/configuration.html">Opciones y
Configuraciones</a>, y reemplazadas individualmente.</p>

<pre>set :scss, :style =&gt; :compact # el estilo por defecto de Sass es :nested

get '/stylesheet.css' do
  scss :stylesheet, :style =&gt; :expanded # reemplazado
end</pre>

<a name='Plantillas%20Less'></a>
<h3>Plantillas Less</h3>

<p>La gem/librería <tt>less</tt> es necesaria para renderizar plantillas
Less:</p>

<pre># Vas a necesitar requerir less en tu app
require 'less'

get '/stylesheet.css' do
  less :stylesheet
end</pre>

<p>Renderiza <tt>./views/stylesheet.less</tt>.</p>

<a name='Plantillas%20Liquid'></a>
<h3>Plantillas Liquid</h3>

<p>La gem/librería <tt>liquid</tt> es necesaria para renderizar plantillas
Liquid:</p>

<pre># Vas a necesitar requerir liquid en tu app
require 'liquid'

get '/' do
  liquid :index
end</pre>

<p>Renderiza <tt>./views/index.liquid</tt>.</p>

<p>Como no vas a poder llamar a métodos de Ruby (excepto a <tt>yield</tt>)
desde una plantilla Liquid, casi siempre vas a querer pasarle locales:</p>

<pre>liquid :index, :locals =&gt; { :clave =&gt; 'valor' }</pre>

<a name='Plantillas%20Markdown'></a>
<h3>Plantillas Markdown</h3>

<p>La gem/librería <tt>rdiscount</tt> es necesaria para renderizar plantillas
Markdown:</p>

<pre># Vas a necesitar requerir rdiscount en tu app
require &quot;rdiscount&quot;

get '/' do
  markdown :index
end</pre>

<p>Renderiza <tt>./views/index.markdown</tt> (<tt>md</tt> y <tt>mkd</tt>
también son extensiones de archivo válidas).</p>

<p>No es posible llamar métodos desde markdown, ni pasarle locales. Por lo
tanto, generalmente vas a usarlo en combinación con otro motor de
renderizado:</p>

<pre>erb :resumen, :locals =&gt; { :texto =&gt; markdown(:introduccion) }</pre>

<p>Tené en cuenta que también podés llamar al método <tt>markdown</tt>
desde otras plantillas:</p>

<pre>%h1 Hola Desde Haml!
%p= markdown(:saludos)</pre>

<p>Como no podés utilizar Ruby desde Markdown, no podés usar layouts
escritos en Markdown. De todos modos, es posible usar un motor de
renderizado para el layout distinto al de la plantilla pasando la opción
<tt>:layout_engine</tt>:</p>

<pre>get '/' do
  markdown :index, :layout_engine =&gt; :erb
end</pre>

<p>Renderiza <tt>./views/index.md</tt> con el layout
<tt>./views/layout.erb</tt>.</p>

<p>Recordá que podés asignar las opciones de renderizado globalmente:</p>

<pre>set :markdown, :layout_engine =&gt; :haml, :layout =&gt; :post

get '/' do
  markdown :index
end</pre>

<p>Renderiza <tt>./views/index.md</tt> (o cualquier otra plantilla Markdown)
con el layout <tt>./views/post.haml</tt>.</p>

<p>También es posible parsear Markdown con BlueCloth en lugar de RDiscount:</p>

<pre>require 'bluecloth'

Tilt.register 'markdown', BlueClothTemplate
Tilt.register 'mkd',      BlueClothTemplate
Tilt.register 'md',       BlueClothTemplate

get '/' do
  markdown :index
end</pre>

<p>Renderiza <tt>./views/index.md</tt> con BlueCloth.</p>

<a name='Plantillas%20Textile'></a>
<h3>Plantillas Textile</h3>

<p>La gem/librería <tt>RedCloth</tt> es necesaria para renderizar plantillas
Textile:</p>

<pre># Vas a necesitar requerir redcloth en tu app
require &quot;redcloth&quot;

get '/' do
  textile :index
end</pre>

<p>Renderiza <tt>./views/index.textile</tt>.</p>

<p>No es posible llamar métodos desde textile, ni pasarle locales. Por lo
tanto, generalmente vas a usarlo en combinación con otro motor de
renderizado:</p>

<pre>erb :resumen, :locals =&gt; { :texto =&gt; textile(:introduccion) }</pre>

<p>Tené en cuenta que también podés llamar al método <tt>textile</tt>
desde otras plantillas:</p>

<pre>%h1 Hola Desde Haml!
%p= textile(:saludos)</pre>

<p>Como no podés utilizar Ruby desde Textile, no podés usar layouts escritos
en Textile. De todos modos, es posible usar un motor de renderizado para el
layout distinto al de la plantilla pasando la opción
<tt>:layout_engine</tt>:</p>

<pre>get '/' do
  textile :index, :layout_engine =&gt; :erb
end</pre>

<p>Renderiza <tt>./views/index.textile</tt> con el layout
<tt>./views/layout.erb</tt>.</p>

<p>Recordá que podés asignar las opciones de renderizado globalmente:</p>

<pre>set :textile, :layout_engine =&gt; :haml, :layout =&gt; :post

get '/' do
  textile :index
end</pre>

<p>Renderiza <tt>./views/index.textile</tt> (o cualquier otra plantilla
Textile) con el layout <tt>./views/post.haml</tt>.</p>

<a name='Plantillas%20RDoc'></a>
<h3>Plantillas RDoc</h3>

<p>La gem/librería <tt>rdoc</tt> es necesaria para renderizar plantillas
RDoc:</p>

<pre># Vas a necesitar requerir rdoc/markup/to_html en tu app
require &quot;rdoc/markup/to_html&quot;

get '/' do
  rdoc :index
end</pre>

<p>Renderiza <tt>./views/index.rdoc</tt>.</p>

<p>No es posible llamar métodos desde rdoc, ni pasarle locales. Por lo tanto,
generalmente vas a usarlo en combinación con otro motor de renderizado:</p>

<pre>erb :resumen, :locals =&gt; { :texto =&gt; rdoc(:introduccion) }</pre>

<p>Tené en cuenta que también podés llamar al método <tt>rdoc</tt> desde
otras plantillas:</p>

<pre>%h1 Hola Desde Haml!
%p= rdoc(:saludos)</pre>

<p>Como no podés utilizar Ruby desde RDoc, no podés usar layouts escritos en
RDoc. De todos modos, es posible usar un motor de renderizado para el
layout distinto al de la plantilla pasando la opción
<tt>:layout_engine</tt>:</p>

<pre>get '/' do
  rdoc :index, :layout_engine =&gt; :erb
end</pre>

<p>Renderiza <tt>./views/index.rdoc</tt> con el layout
<tt>./views/layout.erb</tt>.</p>

<p>Recordá que podés asignar las opciones de renderizado globalmente:</p>

<pre>set :rdoc, :layout_engine =&gt; :haml, :layout =&gt; :post

get '/' do
  rdoc :index
end</pre>

<p>Renderiza <tt>./views/index.rdoc</tt> (o cualquier otra plantilla RDoc) con
el layout <tt>./views/post.haml</tt>.</p>

<a name='Plantillas%20Radius'></a>
<h3>Plantillas Radius</h3>

<p>La gem/librería <tt>radius</tt> es necesaria para renderizar plantillas
Radius:</p>

<pre># Vas a necesitar requerir radius en tu app
require 'radius'

get '/' do
  radius :index
end</pre>

<p>Renderiza <tt>./views/index.radius</tt>.</p>

<p>Como no vas a poder llamar a métodos de Ruby (excepto a <tt>yield</tt>)
desde una plantilla Radius, casi siempre vas a querer pasarle locales:</p>

<pre>radius :index, :locals =&gt; { :clave =&gt; 'valor' }</pre>

<a name='Plantillas%20Markaby'></a>
<h3>Plantillas Markaby</h3>

<p>La gem/librería <tt>markaby</tt> es necesaria para renderizar plantillas
Markaby:</p>

<pre># Vas a necesitar requerir markaby en tu app
require 'markaby'

get '/' do
  markaby :index
end</pre>

<p>Renderiza <tt>./views/index.mab</tt>.</p>

<p>También podés usar Markaby inline:</p>

<pre>get '/' do
  markaby { h1 &quot;Bienvenido!&quot; }
end</pre>

<a name='Plantillas%20Slim'></a>
<h3>Plantillas Slim</h3>

<p>La gem/librería <tt>slim</tt> es necesaria para renderizar plantillas
Slim:</p>

<pre># Vas a necesitar requerir slim en tu app
require 'slim'

get '/' do
  slim :index
end</pre>

<p>Renderiza <tt>./views/index.slim</tt>.</p>

<a name='Plantillas%20CoffeeScript'></a>
<h3>Plantillas CoffeeScript</h3>

<p>La gem/librería <tt>coffee-script</tt> y al menos <b>una</b> de las
siguientes opciones para ejecutar JavaScript:</p>
<ul><li>
<p><tt>node</tt> (de Node.js) en tu path</p>
</li><li>
<p>utilizar OSX</p>
</li><li>
<p>la gem/librería <tt>therubyracer</tt></p>
</li></ul>

<p>son necesarios para renderizar plantillas CoffeeScript:</p>

<pre># Vas a necesitar requerir coffee-script en tu app
require 'coffee-script'

get '/application.js' do
  coffee :application
end</pre>

<p>Renderiza <tt>./views/application.coffee</tt>.</p>

<a name='Plantillas%20Embebidas'></a>
<h3>Plantillas Embebidas</h3>

<pre>get '/' do
  haml '%div.titulo Hola Mundo'
end</pre>

<p>Renderiza el template embebido en el string.</p>

<a name='Accediendo%20a%20Variables%20en%20Plantillas'></a>
<h3>Accediendo a Variables en Plantillas</h3>

<p>Las plantillas son evaluadas dentro del mismo contexto que los manejadores
de ruta. Las variables de instancia asignadas en los manejadores de ruta
son accesibles directamente por las plantillas:</p>

<pre>get '/:id' do
  @foo = Foo.find(params[:id])
  haml '%h1= @foo.nombre'
end</pre>

<p>O es posible especificar un Hash de variables locales explícitamente:</p>

<pre>get '/:id' do
  foo = Foo.find(params[:id])
  haml '%h1= foo.nombre', :locals =&gt; { :foo =&gt; foo }
end</pre>

<p>Esto es usado típicamente cuando se renderizan plantillas como parciales
desde adentro de otras plantillas.</p>

<a name='Plantillas%20Inline'></a>
<h3>Plantillas Inline</h3>

<p>Las plantillas pueden ser definidas al final del archivo fuente:</p>

<pre>require 'rubygems'
require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.titulo Hola mundo!!!!!</pre>

<p>NOTA: únicamente las plantillas inline definidas en el archivo fuente que
requiere sinatra son cargadas automáticamente. Llamá <tt>enable
:inline_templates</tt> explícitamente si tenés plantillas inline en otros
archivos fuente.</p>

<a name='Plantillas%20Nombradas'></a>
<h3>Plantillas Nombradas</h3>

<p>Las plantillas también pueden ser definidas usando el método top-level
<tt>template</tt>:</p>

<pre>template :layout do
  &quot;%html\n  =yield\n&quot;
end

template :index do
  '%div.titulo Hola Mundo!'
end

get '/' do
  haml :index
end</pre>

<p>Si existe una plantilla con el nombre “layout”, va a ser usada cada vez
que una plantilla es renderizada. Podés desactivar los layouts
individualmente pasando <tt>:layout =&gt; false</tt> o globalmente con
<tt>set :haml, :layout =&gt; false</tt>.</p>

<pre>get '/' do
  haml :index, :layout =&gt; !request.xhr?
end</pre>

<a name='Asociando%20Extensiones%20de%20Archivo'></a>
<h3>Asociando Extensiones de Archivo</h3>

<p>Para asociar una extensión de archivo con un motor de renderizado, usá
<tt>Tilt.register</tt>. Por ejemplo, si querés usar la extensión
<tt>tt</tt> para las plantillas Textile, podés hacer lo siguiente:</p>

<pre>Tilt.register :tt, Tilt[:textile]</pre>

<a name='Agregando%20Tu%20Propio%20Motor%20de%20Renderizado'></a>
<h3>Agregando Tu Propio Motor de Renderizado</h3>

<p>Primero, registrá tu motor con Tilt, y después, creá tu método de
renderizado:</p>

<pre>Tilt.register :mipg, MiMotorParaPlantillaGenial

helpers do
  def mypg(*args) render(:mypg, *args) end
end

get '/' do
  mypg :index
end</pre>

<p>Renderiza <tt>./views/index.mypg</tt>. Mirá <a
href="https://github.com/rtomayko/tilt">github.com/rtomayko/tilt</a> para
aprender más de Tilt.</p>

<a name='Filtros'></a>
<h2>Filtros</h2>

<p>Los filtros <tt>before</tt> son evaluados antes de cada petición dentro
del mismo contexto que las rutas. Pueden modificar la petición y la
respuesta.  Las variables de instancia asignadas en los filtros son
accesibles por las rutas y las plantillas:</p>

<pre>before do
  @nota = 'Hey!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @nota #=&gt; 'Hey!'
  params[:splat] #=&gt; 'bar/baz'
end</pre>

<p>Los filtros <tt>after</tt> son evaluados después de cada petición dentro
del mismo contexto y también pueden modificar la petición y la respuesta.
Las variables de instancia asignadas en los filtros <tt>before</tt> y en
las rutas son accesibles por los filtros <tt>after</tt>:</p>

<pre>after do
  puts response.status
end</pre>

<p>Nota: A menos que usés el método <tt>body</tt> en lugar de simplemente
devolver un string desde una ruta, el cuerpo de la respuesta no va a estar
disponible en un filtro after, debido a que todavía no se ha generado.</p>

<p>Los filtros aceptan un patrón opcional, que cuando está presente causa
que los mismos sean evaluados únicamente si el path de la petición
coincide con ese patrón:</p>

<pre>before '/protegido/*' do
  autenticar!
end

after '/crear/:slug' do |slug|
  session[:ultimo_slug] = slug
end</pre>

<p>Al igual que las rutas, los filtros también pueden aceptar condiciones:</p>

<pre>before :agent =&gt; /Songbird/ do
  # ...
end

after '/blog/*', :host_name =&gt; 'ejemplo.com' do
  # ...
end</pre>

<a name='Ayudantes'></a>
<h2>Ayudantes</h2>

<p>Usá el método top-level <tt>helpers</tt> para definir métodos ayudantes
que pueden ser utilizados dentro de los manejadores de rutas y las
plantillas:</p>

<pre>helpers do
  def bar(nombre)
    &quot;#{nombre}bar&quot;
  end
end

get '/:nombre' do
  bar(params[:nombre])
end</pre>

<a name='Usando%20Sesiones'></a>
<h3>Usando Sesiones</h3>

<p>Una sesión es usada para mantener el estado a través de distintas
peticiones. Cuando están activadas, tenés un hash de sesión para cada
sesión de usuario:</p>

<pre>enable :sessions

get '/' do
  &quot;valor = &quot; &lt;&lt; session[:valor].inspect
end

get '/:valor' do
  session[:valor] = params[:valor]
end</pre>

<p>Tené en cuenta que <tt>enable :sessions</tt> guarda todos los datos en una
cookie, lo que no es siempre deseable (guardar muchos datos va a
incrementar tu tráfico, por citar un ejemplo).  Podés usar cualquier
middleware Rack para manejar sesiones, de la misma manera que usarías
cualquier otro middleware, pero con la salvedad de que <b>no</b> tenés que
llamar a <tt>enable :sessions</tt>:</p>

<pre>use Rack::Session::Pool, :expire_after =&gt; 2592000

get '/' do
  &quot;valor = &quot; &lt;&lt; session[:valor].inspect
end

get '/:valor' do
  session[:valor] = params[:valor]
end</pre>

<a name='Interrupci%C3%B3n'></a>
<h3>Interrupción</h3>

<p>Para detener inmediatamente una petición dentro de un filtro o una ruta
usá:</p>

<pre>halt</pre>

<p>También podés especificar el estado:</p>

<pre>halt 410</pre>

<p>O el cuerpo:</p>

<pre>halt 'esto va a ser el cuerpo'</pre>

<p>O los dos:</p>

<pre>halt 401, 'salí de acá!'</pre>

<p>Con cabeceras:</p>

<pre>halt 402, { 'Content-Type' =&gt; 'text/plain' }, 'venganza'</pre>

<a name='Paso'></a>
<h3>Paso</h3>

<p>Una ruta puede pasarle el procesamiento a la siguiente ruta que coincida
con la petición usando <tt>pass</tt>:</p>

<pre>get '/adivina/:quien' do
  pass unless params[:quien] == 'Franco'
  'Adivinaste!'
end

get '/adivina/*' do
  'Erraste!'
end</pre>

<p>Se sale inmediatamente del bloque de la ruta y se le pasa el control a la
siguiente ruta que coincida. Si no coincide ninguna ruta, se devuelve un
404.</p>

<a name='Ejecutando%20Otra%20Ruta'></a>
<h3>Ejecutando Otra Ruta</h3>

<p>Cuando querés obtener el resultado de la llamada a una ruta, <tt>pass</tt>
no te va a servir.  Para lograr esto, podés usar <tt>call</tt>:</p>

<pre>get '/foo' do
  status, headers, body = call request.env.merge(&quot;PATH_INFO&quot; =&gt; '/bar')
  [status, body.upcase]
end

get '/bar' do
  &quot;bar&quot;
end</pre>

<p>Notá que en el ejemplo anterior, es conveniente mover
<tt>&quot;bar&quot;</tt> a un helper, y llamarlo desde <tt>/foo</tt> y
<tt>/bar</tt>.  Así, vas a simplificar las pruebas y a mejorar el
rendimiento.</p>

<p>Si querés que la petición se envíe a la misma instancia de la
aplicación en lugar de a otra, usá <tt>call!</tt> en lugar de
<tt>call</tt>.</p>

<p>En la especificación de Rack podés encontrar más información sobre
<tt>call</tt>.</p>

<a name='Asignando%20el%20C%C3%B3digo%20de%20Estado,%20los%20Encabezados%20y%20el%20Cuerpo%20de%20una%20Respuesta'></a>
<h3>Asignando el Código de Estado, los Encabezados y el Cuerpo de una Respuesta</h3>

<p>Es posible, y se recomienda, asignar el código de estado y el cuerpo de
una respuesta con el valor de retorno de una ruta.  De cualquier manera, en
varios escenarios, puede que sea conveniente asignar el cuerpo en un punto
arbitrario del flujo de ejecución con el método <tt>body</tt>.  A partir
de ahí, podés usar ese mismo método para acceder al cuerpo de la
respuesta:</p>

<pre>get '/foo' do
  body &quot;bar&quot;
end

after do
  puts body
end</pre>

<p>También es posible pasarle un bloque a <tt>body</tt>, que será ejecutado
por el Rack handler (podés usar esto para implementar streaming, mirá
“Valores de retorno”).</p>

<p>De manera similar, también podés asignar el código de estado y
encabezados:</p>

<pre>get '/foo' do
  status 418
  headers \
    &quot;Allow&quot;   =&gt; &quot;BREW, POST, GET, PROPFIND, WHEN&quot;
    &quot;Refresh&quot; =&gt; &quot;Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt&quot;
  body &quot;I'm a tea pot!&quot;
end</pre>

<p>También, al igual que <tt>body</tt>, tanto <tt>status</tt> como
<tt>headers</tt> pueden utilizarse para obtener sus valores cuando no se
les pasa argumentos.</p>

<a name='Tipos%20Mime'></a>
<h3>Tipos Mime</h3>

<p>Cuando usás <tt>send_file</tt> o archivos estáticos tal vez tengas tipos
mime que Sinatra no entiende. Usá <tt>mime_type</tt> para registrarlos a
través de la extensión de archivo:</p>

<pre>mime_type :foo, 'text/foo'</pre>

<p>También lo podés usar con el ayudante <tt>content_type</tt>:</p>

<pre>get '/' do
  content_type :foo
  &quot;foo foo foo&quot;
end</pre>

<a name='Generando%20URLs'></a>
<h3>Generando URLs</h3>

<p>Para generar URLs deberías usar el método <tt>url</tt>.  Por ejemplo, en
Haml:</p>

<pre>%a{:href =&gt; url('/foo')} foo</pre>

<p>Tiene en cuenta proxies inversos y encaminadores de Rack, si están
presentes.</p>

<p>Este método también puede invocarse mediante su alias <tt>to</tt>  (mirá
un ejemplo a continuación).</p>

<a name='Redirecci%C3%B3n%20del%20Navegador'></a>
<h3>Redirección del Navegador</h3>

<p>Podés redireccionar al navegador con el método <tt>redirect</tt>:</p>

<pre>get '/foo' do
  redirect to('/bar')
end</pre>

<p>Cualquier parámetro adicional se utiliza de la misma manera que los
argumentos pasados a <tt>halt</tt>:</p>

<pre>redirect to('/bar'), 303
redirect 'http://google.com', 'te confundiste de lugar, compañero'</pre>

<p>También podés redireccionar fácilmente de vuelta hacia la página desde
donde vino el usuario con +redirect back+:</p>

<pre>get '/foo' do
  &quot;&lt;a href='/bar'&gt;hacer algo&lt;/a&gt;&quot;
end

get '/bar' do
  hacer_algo
  redirect back
end</pre>

<p>Para pasar argumentos con una redirección, podés agregarlos a la cadena
de búsqueda:</p>

<pre>redirect to('/bar?suma=42')</pre>

<p>O usar una sesión:</p>

<pre>enable :session

get '/foo' do
  session[:secreto] = 'foo'
  redirect to('/bar')
end

get '/bar' do
  session[:secreto]
end</pre>

<a name='Cache%20Control'></a>
<h3>Cache Control</h3>

<p>Asignar tus encabezados correctamente es el cimiento para realizar un
cacheo HTTP correcto.</p>

<p>Podés asignar el encabezado Cache-Control fácilmente:</p>

<pre>get '/' do
  cache_control :public
  &quot;cachealo!&quot;
end</pre>

<p>Pro tip: configurar el cacheo en un filtro <tt>before</tt>.</p>

<pre>before do
  cache_control :public, :must_revalidate, :max_age =&gt; 60
end</pre>

<p>Si estás usando el helper <tt>expires</tt> para definir el encabezado
correspondiente, <tt>Cache-Control</tt> se va a definir automáticamente:</p>

<pre>before do
  expires 500, :public, :must_revalidate
end</pre>

<p>Para usar cachés adecuadamente, deberías considerar usar <tt>etag</tt> y
<tt>last_modified</tt>.  Es recomendable que llames a estos helpers
<b>antes</b> de hacer cualquier trabajo pesado, ya que van a enviar la
respuesta inmediatamente si el cliente ya tiene la versión actual en su
caché.</p>

<pre>get '/articulo/:id' do
  @articulo = Articulo.find params[:id]
  last_modified @articulo.updated_at
  etag @articulo.sha1
  erb :articulo
end</pre>

<p>También es posible usar una <a
href="http://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation">weak
ETag</a>:</p>

<pre>etag @articulo.sha1, :weak</pre>

<p>Estos helpers no van a cachear nada por vos, sino que van a facilitar la
información necesaria para poder hacerlo.  Si estás buscando soluciones
rápidas de cacheo, mirá <a
href="http://rtomayko.github.com/rack-cache/">rack-cache</a>:</p>

<pre>require &quot;rack/cache&quot;
require &quot;sinatra&quot;

use Rack::Cache

get '/' do
  cache_control :public, :max_age =&gt; 36000
  sleep 5
  &quot;hola&quot;
end</pre>

<a name='Enviando%20Archivos'></a>
<h3>Enviando Archivos</h3>

<p>Para enviar archivos, podés usar el método <tt>send_file</tt>:</p>

<pre>get '/' do
  send_file 'foo.png'
end</pre>

<p>Además acepta un par de opciones:</p>

<pre>send_file 'foo.png', :type =&gt; :jpg</pre>

<p>Estas opciones son:</p>
<dl><dt>filename</dt>
<dd>
<p>nombre del archivo respondido, por defecto es el nombre real del archivo.</p>
</dd><dt>last_modified</dt>
<dd>
<p>valor para el encabezado Last-Modified, por defecto toma el mtime del
archivo.</p>
</dd><dt>type</dt>
<dd>
<p>el content type que se va a utilizar, si no está presente se intenta
adivinar a partir de la extensión del archivo.</p>
</dd><dt>disposition</dt>
<dd>
<p>se utiliza para el encabezado Content-Disposition, y puede tomar alguno de
los siguientes valores: <tt>nil</tt> (por defecto), <tt>:attachment</tt> e
<tt>:inline</tt></p>
</dd><dt>length</dt>
<dd>
<p>encabezado Content-Length, por defecto toma el tamaño del archivo.</p>
</dd></dl>

<p>Si el Rack handler lo soporta, se intentará no transmitir directamente
desde el proceso de Ruby.  Si usás este método, Sinatra se va a encargar
automáticamente peticiones de rango.</p>

<a name='Accediendo%20al%20objeto%20de%20la%20petici%C3%B3n'></a>
<h3>Accediendo al objeto de la petición</h3>

<p>El objeto de la petición entrante puede ser accedido desde el nivel de la
petición (filtros, rutas y manejadores de errores) a través del método
<tt>request</tt>:</p>

<pre># app corriendo en http://ejemplo.com/ejemplo
get '/foo' do
  request.body              # cuerpo de la petición enviado por el cliente (ver más abajo)
  request.scheme            # &quot;http&quot;
  request.script_name       # &quot;/ejemplo&quot;
  request.path_info         # &quot;/foo&quot;
  request.port              # 80
  request.request_method    # &quot;GET&quot;
  request.query_string      # &quot;&quot;
  request.content_length    # longitud de request.body
  request.media_type        # tipo de medio de request.body
  request.host              # &quot;ejemplo.com&quot;
  request.get?              # verdadero (hay métodos análogos para los otros verbos)
  request.form_data?        # falso
  request[&quot;UNA_CABECERA&quot;]   # valor de la cabecera UNA_CABECERA
  request.referrer          # la referencia del cliente o '/'
  request.user_agent        # user agent (usado por la condición :agent)
  request.cookies           # hash de las cookies del browser
  request.xhr?              # es una petición ajax?
  request.url               # &quot;http://ejemplo.com/ejemplo/foo&quot;
  request.path              # &quot;/ejemplo/foo&quot;
  request.ip                # dirección IP del cliente
  request.secure?           # falso (sería verdadero sobre ssl)
  request.forwarded?        # verdadero (si se está corriendo atrás de un proxy inverso)
  requuest.env              # hash de entorno directamente entregado por Rack
end</pre>

<p>Algunas opciones, como <tt>script_name</tt> o <tt>path_info</tt> pueden
también ser escritas:</p>

<pre>before { request.path_info = &quot;/&quot; }

get &quot;/&quot; do
  &quot;todas las peticiones llegan acá&quot;
end</pre>

<p>El objeto <tt>request.body</tt> es una instancia de IO o StringIO:</p>

<pre>post &quot;/api&quot; do
  request.body.rewind  # en caso de que alguien ya lo haya leído
  datos = JSON.parse request.body.read
  &quot;Hola #{datos['nombre']}!&quot;
end</pre>

<a name='Archivos%20Adjuntos'></a>
<h3>Archivos Adjuntos</h3>

<p>Podés usar el método helper <tt>attachment</tt> para indicarle al
navegador que almacene la respuesta en el disco en lugar de mostrarla en
pantalla.</p>

<pre>get '/' do
  attachment
  &quot;guardalo!&quot;
end</pre>

<p>También podés pasarle un nombre de archivo:</p>

<pre>get '/' do
  attachment &quot;info.txt&quot;
  &quot;guardalo!&quot;
end</pre>

<a name='Buscando%20los%20Archivos%20de%20las%20Plantillas'></a>
<h3>Buscando los Archivos de las Plantillas</h3>

<p>El helper <tt>find_template</tt> se utiliza para encontrar los archivos de
las plantillas que se van a renderizar:</p>

<pre>find_template settings.views, 'foo', Tilt[:haml] do |archivo|
  puts &quot;podría ser #{archivo}&quot;
end</pre>

<p>Si bien esto no es muy útil, lo interesante es que podés sobreescribir
este método, y así enganchar tu propio mecanismo de búsqueda.  Por
ejemplo, para poder utilizar más de un directorio de vistas:</p>

<pre>set :views, ['vistas', 'plantillas']

helpers do
  def find_template(views, name, engine, &amp;block)
    Array(views).each { |v| super(v, name, engine, &amp;block) }
  end
end</pre>

<p>Otro ejemplo consiste en usar directorios diferentes para los distintos
motores de renderizado:</p>

<pre>set :views, :sass =&gt; 'vistas/sass', :haml =&gt; 'plantillas', :defecto =&gt; 'vistas'

helpers do
  def find_template(views, name, engine, &amp;block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:defecto]
    super(folder, name, engine, &amp;block)
  end
end</pre>

<p>¡Es muy fácil convertir estos ejemplos en una extensión y compartirla!.</p>

<p>Notá que <tt>find_template</tt> no verifica si un archivo existe
realmente, sino que llama al bloque que recibe para cada path posible. 
Esto no representa un problema de rendimiento debido a que <tt>render</tt>
va a usar <tt>break</tt> ni bien encuentre un archivo que exista.  Además,
las ubicaciones de las plantillas (y su contenido) se cachean cuando no
estás en el modo de desarrollo.  Es bueno tener en cuenta lo anteiror si
escribís un método medio loco.</p>

<a name='Configuraci%C3%B3n'></a>
<h2>Configuración</h2>

<p>Ejecutar una vez, en el inicio, en cualquier entorno:</p>

<pre>configure do
  # asignando una opción
  set :opcion, 'valor'

  # asignando varias opciones
  set :a =&gt; 1, :b =&gt; 2

  # atajo para `set :opcion, true`
  enable :opcion

  # atajo para `set :opcion, false`
  disable :opcion

  # también podés tener configuraciones dinámicas usando bloques
  set(:css_dir) { File.join(views, 'css') }
end</pre>

<p>Ejecutar únicamente cuando el entorno (la variable de entorno RACK_ENV) es
<tt>:production</tt>:</p>

<pre>configure :production do
  ...
end</pre>

<p>Ejecutar cuando el entorno es <tt>:production</tt> o <tt>:test</tt>:</p>

<pre>configure :production, :test do
  ...
end</pre>

<p>Podés acceder a estas opciones utilizando el método <tt>settings</tt>:</p>

<pre>configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # =&gt; true
  settings.foo  # =&gt; 'bar'
  ...
end</pre>

<a name='Configuraciones%20Disponibles'></a>
<h3>Configuraciones Disponibles</h3>
<dl><dt>absolute_redirects</dt>
<dd>
<p>si está deshabilitada, Sinatra va a permitir redirecciones relativas, sin
embargo, como consecuencia de esto, va a dejar de cumplir con el RFC 2616
(HTTP 1.1), que solamente permite redirecciones absolutas.</p>

<p>Activalo si tu apliación está corriendo atrás de un proxy inverso que no
se ha configurado adecuadamente.  Notá que el helper <tt>url</tt> va a
seguir produciendo URLs absolutas, a menos que le pasés <tt>false</tt>
como segundo parámetro.</p>

<p>Deshabilitada por defecto.</p>
</dd><dt>add_charsets</dt>
<dd>
<p>tipos mime a los que el helper <tt>content_type</tt> les añade
automáticamente el charset.</p>

<p>En general, no deberías asignar directamente esta opción, sino añadirle
los charsets que quieras:</p>

<pre>settings.add_charsets &lt;&lt; &quot;application/foobar&quot;</pre>
</dd><dt>app_file</dt>
<dd>
<p>archivo principal de la aplicación, se utiliza para detectar la raíz del
proyecto, el directorio de las vistas y el público así como las
plantillas inline.</p>
</dd><dt>bind</dt>
<dd>
<p>dirección IP que utilizará el servidor integrado (por defecto: 0.0.0.0).</p>
</dd><dt>default_encoding</dt>
<dd>
<p>encoding utilizado cuando el mismo se desconoce (por defecto
<tt>&quot;utf-8&quot;</tt>).</p>
</dd><dt>dump_errors</dt>
<dd>
<p>mostrar errores en el log.</p>
</dd><dt>environment</dt>
<dd>
<p>entorno actual, por defecto toma el valor de <tt>ENV['RACK_ENV']</tt>, o
<tt>&quot;development&quot;</tt> si no está disponible.</p>
</dd><dt>logging</dt>
<dd>
<p>define si se utiliza el logger.</p>
</dd><dt>lock</dt>
<dd>
<p>coloca un lock alrededor de cada petición, procesando solamente una por
proceso.</p>

<p>Habilitá esta opción si tu aplicación no es thread-safe. Se encuentra
deshabilitada por defecto.</p>
</dd><dt>method_override</dt>
<dd>
<p>utiliza el parámetro <tt>_method</tt> para permtir formularios put/delete
en navegadores que no los soportan.</p>
</dd><dt>port</dt>
<dd>
<p>puerto en el que escuchará el servidor integrado.</p>
</dd><dt>prefixed_redirects</dt>
<dd>
<p>define si inserta <tt>request.script_name</tt> en las redirecciones cuando
no se proporciona un path absoluto. De esta manera, cuando está
habilitada, <tt>redirect '/foo'</tt> se comporta de la misma manera que
<tt>redirect to('/foo')</tt>.  Se encuentra deshabilitada por defecto.</p>
</dd><dt>public</dt>
<dd>
<p>directorio desde donde se sirven los archivos públicos.</p>
</dd><dt>reload_templates</dt>
<dd>
<p>define si se recargan las plantillas entre peticiones.</p>

<p>Se encuentra activado en el entorno de desarrollo y en Ruby 1.8.6 (para
compoensar un bug en Ruby que provoca una pérdida de memoria).</p>
</dd><dt>root</dt>
<dd>
<p>directorio raíz del proyecto.</p>
</dd><dt>raise_errors</dt>
<dd>
<p>elevar excepciones (detiene la aplicación).</p>
</dd><dt>run</dt>
<dd>
<p>cuando está habilitada, Sinatra se va a encargar de iniciar el servidor
web, no la habilités cuando estés usando rackup o algún otro medio.</p>
</dd><dt>running</dt>
<dd>
<p>indica si el servidor integrado está ejecutandose, ¡no cambiés esta
configuración!.</p>
</dd><dt>server</dt>
<dd>
<p>servidor, o lista de servidores, para usar como servidor integrado.  Por
defecto: [‘thin’, ‘mongrel’, ‘webrick’], el orden establece la
prioridad.</p>
</dd><dt>sessions</dt>
<dd>
<p>habilita sesiones basadas en cookies.</p>
</dd><dt>show_exceptions</dt>
<dd>
<p>muestra un stack trace en el navegador.</p>
</dd><dt>static</dt>
<dd>
<p>define si Sinatra debe encargarse de servir archivos estáticos.</p>

<p>Deshabilitala cuando usés un servidor capaz de hacerlo por sí solo,
porque mejorará el rendimiento.  Se encuentra habilitada por defecto.</p>
</dd><dt>views</dt>
<dd>
<p>directorio de las vistas.</p>
</dd></dl>

<a name='Manejo%20de%20Errores'></a>
<h2>Manejo de Errores</h2>

<p>Los manejadores de errores se ejecutan dentro del mismo contexto que las
rutas y los filtros <tt>before</tt>, lo que significa que podés usar, por
ejemplo, <tt>haml</tt>, <tt>erb</tt>, <tt>halt</tt>, etc.</p>

<a name='No%20encontrado%20%3Cem%3E(Not%20Found)%3C/em%3E'></a>
<h3>No encontrado <em>(Not Found)</em></h3>

<p>Cuando se eleva una excepción <tt>Sinatra::NotFound</tt>, o el código de
estado de la respuesta es 404, el manejador <tt>not_found</tt> es invocado:</p>

<pre>not_found do
  'No existo'
end</pre>

<a name='Error'></a>
<h3>Error</h3>

<p>El manejador <tt>error</tt> es invocado cada vez que una excepción es
elevada desde un bloque de ruta o un filtro. El objeto de la excepción se
puede obtener de la variable Rack <tt>sinatra.error</tt>:</p>

<pre>error do
  'Disculpá, ocurrió un error horrible - ' + env['sinatra.error'].name
end</pre>

<p>Errores personalizados:</p>

<pre>error MiErrorPersonalizado do
  'Lo que pasó fue...' request.env['sinatra.error'].message
end</pre>

<p>Entonces, si pasa esto:</p>

<pre>get '/' do
  raise MiErrorPersonalizado, 'algo malo'
end</pre>

<p>Obtenés esto:</p>

<pre>Lo que pasó fue... algo malo</pre>

<p>También, podés instalar un manejador de errores para un código de
estado:</p>

<pre>error 403 do
  'Acceso prohibido'
end

get '/secreto' do
  403
end</pre>

<p>O un rango:</p>

<pre>error 400..510 do
  'Boom'
end</pre>

<p>Sinatra instala manejadores <tt>not_found</tt> y
&lt;tt&gt;error&lt;/ttt&gt; especiales cuando se ejecuta dentro del entorno
de desarrollo “development”.</p>

<a name='Rack%20Middleware'></a>
<h2>Rack Middleware</h2>

<p>Sinatra corre sobre <a href="http://rack.rubyforge.org/">Rack</a>, una
interfaz minimalista que es un estándar para frameworks webs escritos en
Ruby. Una de las capacidades más interesantes de Rack para los
desarrolladores de aplicaciones es el soporte de “middleware” –
componentes que se ubican entre el servidor y tu aplicación, supervisando
y/o manipulando la petición/respuesta HTTP para proporcionar varios tipos
de funcionalidades comunes.</p>

<p>Sinatra hace muy sencillo construir tuberías de Rack middleware a través
del método top-level <tt>use</tt>:</p>

<pre>require 'sinatra'
require 'mi_middleware_personalizado'

use Rack::Lint
use MiMiddlewarePersonalizado

get '/hola' do
  'Hola Mundo'
end</pre>

<p>Las semánticas de <tt>use</tt> son idénticas a las definidas para el DSL
<a
href="http://rack.rubyforge.org/doc/classes/Rack/Builder.html">Rack::Builder</a>
(más frecuentemente usado desde archivos rackup). Por ejemplo, el método
<tt>use</tt> acepta argumentos múltiples/variables así como bloques:</p>

<pre>use Rack::Auth::Basic do |nombre_de_usuario, password|
  nombre_de_usuario == 'admin' &amp;&amp; password == 'secreto'
end</pre>

<p>Rack es distribuido con una variedad de middleware estándar para logging,
debugging, enrutamiento URL, autenticación, y manejo de sesiones. Sinatra
usa muchos de estos componentes automáticamente de acuerdo a su
configuración para que típicamente no tengas que usarlas (con
<tt>use</tt>) explícitamente.</p>

<a name='Pruebas'></a>
<h2>Pruebas</h2>

<p>Las pruebas para las aplicaciones Sinatra pueden ser escritas utilizando
cualquier framework o librería de pruebas basada en Rack. Se recomienda
usar <a href="http://gitrdoc.com/brynary/rack-test">Rack::Test</a>:</p>

<pre>require 'mi_app_sinatra'
require 'test/unit'
require 'rack/test'

class MiAppTest &lt; Test::Unit::TestCase
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_mi_defecto
    get '/'
    assert_equal 'Hola Mundo!', last_response.body
  end

  def test_con_parametros
    get '/saludar', :name =&gt; 'Franco'
    assert_equal 'Hola Frank!', last_response.body
  end

  def test_con_entorno_rack
    get '/', {}, 'HTTP_USER_AGENT' =&gt; 'Songbird'
    assert_equal &quot;Estás usando Songbird!&quot;, last_response.body
  end
end</pre>

<p>NOTA: El módulo Sinatra::Test y la clase Sinatra::TestHarness están
deprecados a partir de la versión 0.9.2.</p>

<a name='Sinatra::Base%20-%20Middleware,%20Librer%C3%ADas,%20y%20Aplicaciones%20Modulares'></a>
<h2>Sinatra::Base - Middleware, Librerías, y Aplicaciones Modulares</h2>

<p>Definir tu aplicación en el top-level funciona bien para
micro-aplicaciones pero trae inconvenientes considerables a la hora de
construir componentes reutilizables como Rack middleware, Rails metal,
simple librerías con un componente de servidor, o incluso extensiones de
Sinatra. El DSL de top-level contamina el espacio de nombres de Object y
asume una configuración apropiada para micro-aplicaciones (por ejemplo, un
único archivo de aplicación, los directorios ./public y ./views, logging,
página con detalles de excepción, etc.). Ahí es donde Sinatra::Base
entra en el juego:</p>

<pre>require 'sinatra/base'

class MiApp &lt; Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Hola Mundo!'
  end
end</pre>

<p>Las subclases de Sinatra::Base tienen disponibles exactamente los mismos
métodos que los provistos por el DSL de top-level. La mayoría de las
aplicaciones top-level se pueden convertir en componentes Sinatra::Base con
dos modificaciones:</p>
<ul><li>
<p>Tu archivo debe requerir <tt>sinatra/base</tt> en lugar de
<tt>sinatra</tt>; de otra manera, todos los métodos del DSL de sinatra son
importados dentro del espacio de nombres principal.</p>
</li><li>
<p>Poné las rutas, manejadores de errores, filtros y opciones de tu
aplicación en una subclase de Sinatra::Base.</p>
</li></ul>

<p><tt>Sinatra::Base</tt> es una pizarra en blanco. La mayoría de las
opciones están desactivadas por defecto, incluyendo el servidor
incorporado. Mirá <a
href="http://sinatra.github.com/configuration.html">Opciones y
Configuraciones</a> para detalles sobre las opciones disponibles y su
comportamiento.</p>

<a name='Estilo%20Modular%20vs.%20Cl%C3%A1sico'></a>
<h3>Estilo Modular vs. Clásico</h3>

<p>Contrariamente a la creencia popular, no hay nada de malo con el estilo
clásico. Si se ajusta a tu aplicación, no es necesario que la cambies a
una modular.</p>

<p>Existen tan solo dos desventajas en comparación con el estilo modular:</p>
<ul><li>
<p>Solamente podés tener una aplicación Sinatra por proceso Ruby - si tenés
planificado usar más, cambiá al estilo modular.</p>
</li><li>
<p>El estilo clásico contamina Object con métodos delegadores - si tenés
planificado empaquetar tu aplicación en una librería/gem, cambiá al
estilo modular.</p>
</li></ul>

<p>No hay ninguna razón por la cuál no puedas mezclar los estilos modular y
clásico.</p>

<p>Cuando cambiés de un estilo al otro, tené en cuenta las sutiles
diferencias entre sus configuraciones:</p>

<pre>Configuración       Clásica                      Modular

app_file            archivo que carga sinatra    nil
run                 $0 == app_file               false
logging             true                         false
method_override     true                         false
inline_templates    true                         false</pre>

<a name='Sirviendo%20una%20Aplicaci%C3%B3n%20Modular'></a>
<h3>Sirviendo una Aplicación Modular</h3>

<p>Las dos opciones más comunes para iniciar una aplicación modular son,
iniciarla activamente con <tt>run!</tt>:</p>

<pre># mi_app.rb
require 'sinatra/base'

class MiApp &lt; Sinatra::Base
  # ... código de la app  ...

  # iniciar el servidor si el archivo fue ejecutado directamente
  run! if app_file == $0
end</pre>

<p>Iniciar con:</p>

<pre>ruby mi_app.rb</pre>

<p>O, con un archivo <tt>config.ru</tt>, que permite usar cualquier handler
Rack:</p>

<pre># config.ru
require 'mi_app'
run MiApp</pre>

<p>Después ejecutar:</p>

<pre>rackup -p 4567</pre>

<a name='Usando%20una%20Aplicaci%C3%B3n%20Cl%C3%A1sica%20con%20un%20Archivo%20config.ru'></a>
<h3>Usando una Aplicación Clásica con un Archivo config.ru</h3>

<p>Escribí el archivo de tu aplicación:</p>

<pre># app.rb
require 'sinatra'

get '/' do
  'Hola mundo!'
end</pre>

<p>Y el <tt>config.ru</tt> correspondiente:</p>

<pre>require 'app'
run Sinatra::Application</pre>

<a name='%C2%BFCu%C3%A1ndo%20Usar%20config.ru?'></a>
<h3>¿Cuándo Usar config.ru?</h3>

<p>Indicadores de que probablemente querés usar <tt>config.ru</tt>:</p>
<ul><li>
<p>Querés realizar el deploy con un hanlder Rack distinto (Passenger,
Unicorn, Heroku, …).</p>
</li><li>
<p>Querés usar más de una subclase de <tt>Sinatra::Base</tt>.</p>
</li><li>
<p>Querés usar Sinatra únicamente para middleware, pero no como un endpoint.</p>
</li></ul>

<p><b>No hay necesidad de utilizar un archivo <tt>config.ru</tt>
exclusivamente porque tenés una aplicación modular, y no necesitás una
aplicación modular para iniciarla con <tt>config.ru</tt>.</b></p>

<a name='Utilizando%20Sinatra%20como%20Middleware'></a>
<h3>Utilizando Sinatra como Middleware</h3>

<p>Sinatra no solo es capaz de usar otro Rack middleware, sino que a su vez,
cualquier aplicación Sinatra puede ser agregada delante de un endpoint
Rack como middleware. Este endpoint puede ser otra aplicación Sinatra, o
cualquier aplicación basada en Rack (Rails/Ramaze/Camping/…).</p>

<pre>require 'sinatra/base'

class PantallaDeLogin &lt; Sinatra::Base
  enable :sessions

  get('/login') { haml :login }

  post('/login') do
    if params[:nombre] = 'admin' and params[:password] = 'admin'
      session['nombre_de_usuario'] = params[:nombre]
    else
      redirect '/login'
    end
  end
end

class MiApp &lt; Sinatra::Base
  # el middleware se ejecutará antes que los filtros
  use PantallaDeLogin

  before do
    unless session['nombre_de_usuario']
      halt &quot;Acceso denegado, por favor &lt;a href='/login'&gt;iniciá sesión&lt;/a&gt;.&quot;
    end
  end

  get('/') { &quot;Hola #{session['nombre_de_usuario']}.&quot; }
end</pre>

<a name='%C3%81mbitos%20y%20Ligaduras'></a>
<h2>Ámbitos y Ligaduras</h2>

<p>El ámbito en el que te encontrás determina que métodos y variables
están disponibles.</p>

<a name='%C3%81mbito%20de%20Aplicaci%C3%B3n/Clase'></a>
<h3>Ámbito de Aplicación/Clase</h3>

<p>Cada aplicación Sinatra es una subclase de Sinatra::Base. Si estás usando
el DSL de top-level (<tt>require 'sinatra'</tt>), entonces esta clase es
Sinatra::Application, de otra manera es la subclase que creaste
explícitamente. Al nivel de la clase tenés métodos como <tt>get</tt> o
<tt>before</tt>, pero no podés acceder a los objetos <tt>request</tt> o
<tt>session</tt>, ya que hay una única clase de la aplicación para todas
las peticiones.</p>

<p>Las opciones creadas utilizando <tt>set</tt> son métodos al nivel de la
clase:</p>

<pre>class MiApp &lt; Sinatra::Base
  # Ey, estoy en el ámbito de la aplicación!
  set :foo, 42
  foo # =&gt; 42

  get '/foo' do
    # Hey, ya no estoy en el ámbito de la aplicación!
  end
end</pre>

<p>Tenés la ligadura al ámbito de la aplicación dentro de:</p>
<ul><li>
<p>El cuerpo de la clase de tu aplicación</p>
</li><li>
<p>Métodos definidos por extensiones</p>
</li><li>
<p>El bloque pasado a <tt>helpers</tt></p>
</li><li>
<p>Procs/bloques usados como el valor para <tt>set</tt></p>
</li></ul>

<p>Este ámbito puede alcanzarse de las siguientes maneras:</p>
<ul><li>
<p>A través del objeto pasado a los bloques de configuración (<tt>configure
{ |c| ...}</tt>)</p>
</li><li>
<p>Llamando a <tt>settings</tt> desde dentro del ámbito de la petición</p>
</li></ul>

<a name='%C3%81mbito%20de%20Petici%C3%B3n/Instancia'></a>
<h3>Ámbito de Petición/Instancia</h3>

<p>Para cada petición entrante, una nueva instancia de la clase de tu
aplicación es creada y todos los bloques de rutas son ejecutados en ese
ámbito. Desde este ámbito podés acceder a los objetos <tt>request</tt> y
<tt>session</tt> o llamar a los métodos de renderización como
<tt>erb</tt> o <tt>haml</tt>. Podés acceder al ámbito de la aplicación
desde el ámbito de la petición utilizando <tt>settings</tt>:</p>

<pre>class MiApp &lt; Sinatra::Base
  # Ey, estoy en el ámbito de la aplicación!
  get '/definir_ruta/:nombre' do
    # Ámbito de petición para '/definir_ruta/:nombre'
    @valor = 42

    settings.get(&quot;/#{params[:nombre]}&quot;) do
      # Ámbito de petición para &quot;/#{params[:nombre]}&quot;
      @valor # =&gt; nil (no es la misma petición)
    end

    &quot;Ruta definida!&quot;
  end
end</pre>

<p>Tenés la ligadura al ámbito de la petición dentro de:</p>
<ul><li>
<p>bloques pasados a get/head/post/put/delete/options</p>
</li><li>
<p>filtros before/after</p>
</li><li>
<p>métodos ayudantes</p>
</li><li>
<p>plantillas/vistas</p>
</li></ul>

<a name='%C3%81mbito%20de%20Delegaci%C3%B3n'></a>
<h3>Ámbito de Delegación</h3>

<p>El ámbito de delegación solo reenvía métodos al ámbito de clase. De
cualquier manera, no se comporta 100% como el ámbito de clase porque no
tenés la ligadura de la clase: únicamente métodos marcados
explícitamente para delegación están disponibles y no compartís
variables/estado con el ámbito de clase (léase: tenés un <tt>self</tt>
diferente). Podés agregar delegaciones de método llamando a
<tt>Sinatra::Delegator.delegate :nombre_del_metodo</tt>.</p>

<p>Tenés la ligadura al ámbito de delegación dentro de:</p>
<ul><li>
<p>La ligadura del top-level, si hiciste <tt>require &quot;sinatra&quot;</tt></p>
</li><li>
<p>Un objeto extendido con el mixin <tt>Sinatra::Delegator</tt></p>
</li></ul>

<p>Pegale una mirada al código: acá está el <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/base.rb#L1128">Sinatra::Delegator
mixin</a> que es <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/main.rb#L28">incluido
en el espacio de nombres principal</a>.</p>

<a name='L%C3%ADnea%20de%20Comandos'></a>
<h2>Línea de Comandos</h2>

<p>Las aplicaciones Sinatra pueden ser ejecutadas directamente:</p>

<pre>ruby miapp.rb [-h] [-x] [-e ENTORNO] [-p PUERTO] [-o HOST] [-s MANEJADOR]</pre>

<p>Las opciones son:</p>

<pre>-h # ayuda
-p # asigna el puerto (4567 es usado por defecto)
-o # asigna el host (0.0.0.0 es usado por defecto)
-e # asigna el entorno (development es usado por defecto)
-s # especifica el servidor/manejador rack (thin es usado por defecto)
-x # activa el mutex lock (está desactivado por defecto)</pre>

<a name='Requerimientos'></a>
<h2>Requerimientos</h2>

<p>Se recomienda instalar Sinatra en Ruby 1.8.7, 1.9.2, JRuby o Rubinius.</p>

<p>Las siguientes versiones de Ruby son soportadas oficialmente:</p>
<dl><dt> Ruby 1.8.6 </dt>
<dd>
<p>No se recomienda utilizar Sinatra en 1.8.6. Sin embargo, esta versión
será soportada oficialmente hasta que se libere Sinatra 1.3.0.  RDoc y
CoffeeScript no son soportadas por esta versión de Ruby. 1.8.6 contiene
una falla importante de pérdida de memoria en su implementación de Hash,
que afecta a las versiones de Sinatra anteriores a 1.1.1.  La versión
actual evita explícitamente esta falla a expensas de una disminución del
rendimiento.  Por último, Rack &gt;= 1.2 dejó de soportar 1.8.6, por lo
que vas a tener que usar alguna versión 1.1.x.</p>
</dd><dt> Ruby 1.8.7 </dt>
<dd>
<p>1.8.7 es soportado completamente.  Sin embargo, si no hay nada que te lo
prohíba, te recomendamos que usés 1.9.2 o cambies a JRuby o Rubinius.</p>
</dd><dt> Ruby 1.9.2 </dt>
<dd>
<p>1.9.2 es soportado y recomendado.  Tené en cuenta que Radius y Markaby no
son compatibles con 1.9 actualmente.  Además, no usés 1.9.2p0, porque
produce fallos de segmentación cuando se utiliza Sinatra.</p>
</dd><dt> Rubinius </dt>
<dd>
<p>Rubinius es soportado oficialmente (Rubinius &gt;= 1.2.2), con la
excepción de las plantillas Textile.</p>
</dd><dt> JRuby </dt>
<dd>
<p>JRuby es soportado oficialmente (JRuby &gt;= 1.5.6).  No se conocen
problemas con librerías de plantillas de terceras partes.  Sin embargo, si
elegís usar JRuby, deberías examinar sus Rack handlers porque el servidor
web Thin no es soportado actualmente.</p>
</dd></dl>

<p>Siempre le prestamos atención a las nuevas versiones de Ruby.</p>

<p>Las siguientes implementaciones de Ruby no se encuentran soportadas
oficialmente.  De cualquier manera, pueden ejecutar Sinatra:</p>
<ul><li>
<p>Versiones anteriores de JRuby y Rubinius</p>
</li><li>
<p>MacRuby</p>
</li><li>
<p>Maglev</p>
</li><li>
<p>IronRuby</p>
</li><li>
<p>Ruby 1.9.0 y 1.9.1</p>
</li></ul>

<p>No estar soportada oficialmente, significa que si las cosas solamente se
rompen ahí y no en una plataforma soportada, asumimos que no es nuestro
problema sino el suyo.</p>

<p>Sinatra debería funcionar en cualquier sistema operativo soportado por la
implementación de Ruby elegida.</p>

<a name='A%20la%20Vanguardia'></a>
<h2>A la Vanguardia</h2>

<p>Si querés usar el código de Sinatra más reciente, sentite libre de
ejecutar tu aplicación sobre la rama master, en general es bastante
estable.</p>

<p>También liberamos prereleases de vez en cuando, así, podés hacer</p>

<pre>gem install sinatra --pre</pre>

<p>Para obtener algunas de las últimas características.</p>

<a name='Con%20Bundler'></a>
<h3>Con Bundler</h3>

<p>Esta es la manera recomendada para ejecutar tu aplicación sobre la última
versión de Sinatra usando <a href="http://gembundler.com/">Bundler</a>.</p>

<p>Primero, instalá bundler si no lo hiciste todavía:</p>

<pre>gem install bundler</pre>

<p>Después, en el directorio de tu proyecto, creá un archivo
<tt>Gemfile</tt>:</p>

<pre>source :rubygems
gem 'sinatra', :git =&gt; &quot;git://github.com/sinatra/sinatra.git&quot;

# otras dependencias
gem 'haml'                    # por ejemplo, si usás haml
gem 'activerecord', '~&gt; 3.0'  # quizás también necesités ActiveRecord 3.x</pre>

<p>Tené en cuenta que tenés que listar todas las dependencias directas de tu
aplicación. No es necesario listar las dependencias de Sinatra (Rack y
Tilt) porque Bundler las agrega directamente.</p>

<p>Ahora podés arrancar tu aplicación así:</p>

<pre>bundle exec ruby miapp.rb</pre>

<a name='Con%20Git'></a>
<h3>Con Git</h3>

<p>Cloná el repositorio localmente y ejecutá tu aplicación, asegurándote
que el directorio <tt>sinatra/lib</tt> esté en el <tt>$LOAD_PATH</tt>:</p>

<pre>cd miapp
git clone git://github.com/sinatra/sinatra.git
ruby -Isinatra/lib miapp.rb</pre>

<p>Para actualizar el código fuente de Sinatra en el futuro:</p>

<pre>cd miapp/sinatra
git pull</pre>

<a name='Instalaci%C3%B3n%20Global'></a>
<h3>Instalación Global</h3>

<p>Podés construir la gem vos mismo:</p>

<pre>git clone git://github.com/sinatra/sinatra.git
cd sinatra
rake sinatra.gemspec
rake install</pre>

<p>Si instalás tus gems como root, el último paso debería ser</p>

<pre>sudo rake install</pre>

<a name='Lecturas%20Recomendadas'></a>
<h2>Lecturas Recomendadas</h2>
<ul><li>
<p><a href="http://www.sinatrarb.com/">Sito web del proyecto</a> -
Documentación adicional, noticias, y enlaces a otros recursos.</p>
</li><li>
<p><a href="http://www.sinatrarb.com/contributing">Contribuyendo</a> -
¿Encontraste un error?. ¿Necesitás ayuda?. ¿Tenés un parche?.</p>
</li><li>
<p><a href="http://github.com/sinatra/sinatra/issues">Seguimiento de
problemas</a></p>
</li><li>
<p><a href="http://twitter.com/sinatra">Twitter</a></p>
</li><li>
<p><a href="http://groups.google.com/group/sinatrarb/topics">Lista de
Correo</a></p>
</li><li>
<p><a href="irc://chat.freenode.net/#sinatra">IRC: #sinatra</a> en <a
href="http://freenode.net">freenode.net</a></p>
</li></ul>
