<div class='toc'>
	<ol class='level-1'>
		<li><a href='#Rutas'>Rutas</a></li>
		<li><a href='#Condiciones'>Condiciones</a></li>
		<ol class='level-2'>
			<li><a href='#Valores%20de%20Retorno'>Valores de Retorno</a></li>
			<li><a href='#Comparadores%20de%20Rutas%20Personalizados'>Comparadores de Rutas Personalizados</a></li>
			<li><a href='#Archivos%20Est&aacute;ticos'>Archivos Est&aacute;ticos</a></li>
			<li><a href='#Vistas%20/%20Plantillas'>Vistas / Plantillas</a></li>
			<li><a href='#Lenguajes%20de%20Plantillas%20Disponibles'>Lenguajes de Plantillas Disponibles</a></li>
			<li><a href='#Plantillas%20Haml'>Plantillas Haml</a></li>
			<li><a href='#Plantillas%20Erb'>Plantillas Erb</a></li>
			<li><a href='#Plantillas%20Builder'>Plantillas Builder</a></li>
			<li><a href='#Plantillas%20Nokogiri'>Plantillas Nokogiri</a></li>
			<li><a href='#Plantillas%20Sass'>Plantillas Sass</a></li>
			<li><a href='#Plantillas%20SCSS'>Plantillas SCSS</a></li>
			<li><a href='#Plantillas%20Less'>Plantillas Less</a></li>
			<li><a href='#Plantillas%20Liquid'>Plantillas Liquid</a></li>
			<li><a href='#Plantillas%20Markdown'>Plantillas Markdown</a></li>
			<li><a href='#Plantillas%20Textile'>Plantillas Textile</a></li>
			<li><a href='#Plantillas%20RDoc'>Plantillas RDoc</a></li>
			<li><a href='#Plantillas%20Radius'>Plantillas Radius</a></li>
			<li><a href='#Plantillas%20Markaby'>Plantillas Markaby</a></li>
			<li><a href='#Plantillas%20RABL'>Plantillas RABL</a></li>
			<li><a href='#Plantillas%20Slim'>Plantillas Slim</a></li>
			<li><a href='#Plantillas%20Creole'>Plantillas Creole</a></li>
			<li><a href='#Plantillas%20CoffeeScript'>Plantillas CoffeeScript</a></li>
			<li><a href='#Plantillas%20Stylus'>Plantillas Stylus</a></li>
			<li><a href='#Plantillas%20Yajl'>Plantillas Yajl</a></li>
			<li><a href='#Plantillas%20WLang'>Plantillas WLang</a></li>
			<li><a href='#Plantillas%20Embebidas'>Plantillas Embebidas</a></li>
			<li><a href='#Accediendo%20a%20Variables%20en%20Plantillas'>Accediendo a Variables en Plantillas</a></li>
			<li><a href='#Plantillas%20Inline'>Plantillas Inline</a></li>
			<li><a href='#Plantillas%20Nombradas'>Plantillas Nombradas</a></li>
			<li><a href='#Asociando%20Extensiones%20de%20Archivo'>Asociando Extensiones de Archivo</a></li>
			<li><a href='#Agregando%20Tu%20Propio%20Motor%20de%20Renderizado'>Agregando Tu Propio Motor de Renderizado</a></li>
		</ol>
		<li><a href='#Filtros'>Filtros</a></li>
		<li><a href='#Ayudantes'>Ayudantes</a></li>
		<ol class='level-2'>
			<li><a href='#Usando%20Sesiones'>Usando Sesiones</a></li>
			<li><a href='#Interrupci&oacute;n'>Interrupci&oacute;n</a></li>
			<li><a href='#Paso'>Paso</a></li>
			<li><a href='#Ejecutando%20Otra%20Ruta'>Ejecutando Otra Ruta</a></li>
			<li><a href='#Asignando%20el%20C&oacute;digo%20de%20Estado,%20los%20Encabezados%20y%20el%20Cuerpo%20de%20una%20Respuesta'>Asignando el C&oacute;digo de Estado, los Encabezados y el Cuerpo de una Respuesta</a></li>
			<li><a href='#Streaming%20De%20Respuestas'>Streaming De Respuestas</a></li>
			<li><a href='#Log%20(Registro)'>Log (Registro)</a></li>
			<li><a href='#Tipos%20Mime'>Tipos Mime</a></li>
			<li><a href='#Generando%20URLs'>Generando URLs</a></li>
			<li><a href='#Redirecci&oacute;n%20del%20Navegador'>Redirecci&oacute;n del Navegador</a></li>
			<li><a href='#Cache%20Control'>Cache Control</a></li>
			<li><a href='#Enviando%20Archivos'>Enviando Archivos</a></li>
			<li><a href='#Accediendo%20al%20objeto%20de%20la%20petici&oacute;n'>Accediendo al objeto de la petici&oacute;n</a></li>
			<li><a href='#Archivos%20Adjuntos'>Archivos Adjuntos</a></li>
			<li><a href='#Fecha%20y%20Hora'>Fecha y Hora</a></li>
			<li><a href='#Buscando%20los%20Archivos%20de%20las%20Plantillas'>Buscando los Archivos de las Plantillas</a></li>
		</ol>
		<li><a href='#Configuraci&oacute;n'>Configuraci&oacute;n</a></li>
		<ol class='level-2'>
			<li><a href='#Configurando%20la%20Protecci&oacute;n%20de%20Ataques'>Configurando la Protecci&oacute;n de Ataques</a></li>
			<li><a href='#Configuraciones%20Disponibles'>Configuraciones Disponibles</a></li>
		</ol>
		<li><a href='#Entornos'>Entornos</a></li>
		<li><a href='#Manejo%20de%20Errores'>Manejo de Errores</a></li>
		<ol class='level-2'>
			<li><a href='#Error'>Error</a></li>
		</ol>
		<li><a href='#Rack%20Middleware'>Rack Middleware</a></li>
		<li><a href='#Pruebas'>Pruebas</a></li>
		<li><a href='#Sinatra::Base%20-%20Middleware,%20Librer&iacute;as,%20y%20Aplicaciones%20Modulares'>Sinatra::Base - Middleware, Librer&iacute;as, y Aplicaciones Modulares</a></li>
		<ol class='level-2'>
			<li><a href='#Estilo%20Modular%20vs.%20Cl&aacute;sico'>Estilo Modular vs. Cl&aacute;sico</a></li>
			<li><a href='#Sirviendo%20una%20Aplicaci&oacute;n%20Modular'>Sirviendo una Aplicaci&oacute;n Modular</a></li>
			<li><a href='#Usando%20una%20Aplicaci&oacute;n%20Cl&aacute;sica%20con%20un%20Archivo%20config.ru'>Usando una Aplicaci&oacute;n Cl&aacute;sica con un Archivo config.ru</a></li>
			<li><a href='#&iquest;Cu&aacute;ndo%20Usar%20config.ru?'>&iquest;Cu&aacute;ndo Usar config.ru?</a></li>
			<li><a href='#Utilizando%20Sinatra%20como%20Middleware'>Utilizando Sinatra como Middleware</a></li>
			<li><a href='#Creaci&oacute;n%20Din&aacute;mica%20de%20Aplicaciones'>Creaci&oacute;n Din&aacute;mica de Aplicaciones</a></li>
		</ol>
		<li><a href='#&Aacute;mbitos%20y%20Ligaduras'>&Aacute;mbitos y Ligaduras</a></li>
		<ol class='level-2'>
			<li><a href='#&Aacute;mbito%20de%20Aplicaci&oacute;n/Clase'>&Aacute;mbito de Aplicaci&oacute;n/Clase</a></li>
			<li><a href='#&Aacute;mbito%20de%20Petici&oacute;n/Instancia'>&Aacute;mbito de Petici&oacute;n/Instancia</a></li>
			<li><a href='#&Aacute;mbito%20de%20Delegaci&oacute;n'>&Aacute;mbito de Delegaci&oacute;n</a></li>
		</ol>
		<li><a href='#L&iacute;nea%20de%20Comandos'>L&iacute;nea de Comandos</a></li>
		<li><a href='#Versiones%20de%20Ruby%20Soportadas'>Versiones de Ruby Soportadas</a></li>
		<li><a href='#A%20la%20Vanguardia'>A la Vanguardia</a></li>
		<ol class='level-2'>
			<li><a href='#Con%20Bundler'>Con Bundler</a></li>
			<li><a href='#Con%20Git'>Con Git</a></li>
			<li><a href='#Instalaci&oacute;n%20Global'>Instalaci&oacute;n Global</a></li>
		</ol>
		<li><a href='#Versionado'>Versionado</a></li>
		<li><a href='#Lecturas%20Recomendadas'>Lecturas Recomendadas</a></li>
	</ol>
</div>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>

<p><em>Atenci&oacute;n: Este documento es una traducci&oacute;n de la versi&oacute;n en ingl&eacute;s y puede estar desactualizado.</em></p>

<p>Sinatra es un
<a href="http://es.wikipedia.org/wiki/Lenguaje_espec%C3%ADfico_del_dominio">DSL</a> para
crear aplicaciones web r&aacute;pidamente en Ruby con un m&iacute;nimo esfuerzo:</p>

<pre><code class="ruby"># miapp.rb
require 'sinatra'

get '/' do
  'Hola mundo!'
end
</code></pre>

<p>Instal&aacute; la gem y ejecut&aacute; la aplicaci&oacute;n con:</p>

<pre><code class="shell">gem install sinatra
ruby miapp.rb
</code></pre>

<p>Pod&eacute;s verla en: http://localhost:4567</p>

<p>Es recomendable adem&aacute;s ejecutar <code>gem install thin</code>, ya que Sinatra lo va
a utilizar cuando est&eacute; disponible.</p>

<a name='Rutas'></a>
<h2>Rutas</h2>

<p>En Sinatra, una ruta est&aacute; compuesta por un m&eacute;todo HTTP y un patr&oacute;n de una URL.
Cada ruta se asocia con un bloque:</p>

<pre><code class="ruby">get '/' do
  .. mostrar algo ..
end

post '/' do
  .. crear algo ..
end

put '/' do
  .. reemplazar algo ..
end

patch '/' do
  .. modificar algo ..
end

delete '/' do
  .. aniquilar algo ..
end

options '/' do
  .. informar algo ..
end
</code></pre>

<p>Las rutas son comparadas en el orden en el que son definidas. La primer ruta
que coincide con la petici&oacute;n es invocada.</p>

<p>Los patrones de las rutas pueden incluir par&aacute;metros nombrados, accesibles a
trav&eacute;s de el hash <code>params</code>:</p>

<pre><code class="ruby">get '/hola/:nombre' do
  # coincide con "GET /hola/foo" y "GET /hola/bar"
  # params[:nombre] es 'foo' o 'bar'
  "Hola #{params[:nombre]}!"
end
</code></pre>

<p>Tambi&eacute;n pod&eacute;s acceder a los par&aacute;metros nombrados usando par&aacute;metros de bloque:</p>

<pre><code class="ruby">get '/hola/:nombre' do |n|
  "Hola #{n}!"
end
</code></pre>

<p>Los patrones de ruta tambi&eacute;n pueden incluir par&aacute;metros splat (o wildcard),
accesibles a trav&eacute;s del arreglo <code>params[:splat]</code>:</p>

<pre><code class="ruby">get '/decir/*/al/*' do
  # coincide con /decir/hola/al/mundo
  params[:splat] # =&gt; ["hola", "mundo"]
end

get '/descargar/*.*' do
  # coincide con /descargar/path/al/archivo.xml
  params[:splat] # =&gt; ["path/al/archivo", "xml"]
end
</code></pre>

<p>O, con par&aacute;metros de bloque:</p>

<pre><code class="ruby">get '/descargar/*.*' do |path, ext|
  [path, ext] # =&gt; ["path/al/archivo", "xml"]
end
</code></pre>

<p>Rutas con Expresiones Regulares:</p>

<pre><code class="ruby">get %r{/hola/([\w]+)} do
  "Hola, #{params[:captures].first}!"
end
</code></pre>

<p>O con un par&aacute;metro de bloque:</p>

<pre><code class="ruby">get %r{/hola/([\w]+)} do |c|
  "Hola, #{c}!"
end
</code></pre>

<p>Los patrones de ruta pueden contener par&aacute;metros opcionales:</p>

<pre><code class="ruby">get '/posts.?:formato?' do
  # coincide con "GET /posts" y adem&aacute;s admite cualquier extensi&oacute;n, por
  # ejemplo, "GET /posts.json", "GET /posts.xml", etc.
end
</code></pre>

<p>A prop&oacute;sito, a menos que desactiv&eacute;s la protecci&oacute;n para el ataque <em>path
traversal</em> (ver m&aacute;s abajo), el path de la petici&oacute;n puede ser modificado
antes de que se compare con los de tus rutas.</p>

<a name='Condiciones'></a>
<h2>Condiciones</h2>

<p>Las rutas pueden incluir una variedad de condiciones de selecci&oacute;n, como por
ejemplo el user agent:</p>

<pre><code class="ruby">get '/foo', :agent =&gt; /Songbird (\d\.\d)[\d\/]*?/ do
  "Est&aacute;s usando la versi&oacute;n de Songbird #{params[:agent][0]}"
end

get '/foo' do
  # Coincide con browsers que no sean songbird
end
</code></pre>

<p>Otras condiciones disponibles son <code>host_name</code> y <code>provides</code>:</p>

<pre><code class="ruby">get '/', :host_name =&gt; /^admin\./ do
  "&Aacute;rea de Administraci&oacute;n, Acceso denegado!"
end

get '/', :provides =&gt; 'html' do
  haml :index
end

get '/', :provides =&gt; ['rss', 'atom', 'xml'] do
  builder :feed
end
</code></pre>

<p>Pod&eacute;s definir tus propias condiciones f&aacute;cilmente:</p>

<pre><code class="ruby">set(:probabilidad) { |valor| condition { rand &lt;= valor } }

get '/gana_un_auto', :probabilidad =&gt; 0.1 do
  "Ganaste!"
end

get '/gana_un_auto' do
  "Lo siento, perdiste."
end
</code></pre>

<p>Si tu condici&oacute;n acepta m&aacute;s de un argumento, pod&eacute;s pasarle un arreglo. Al
definir la condici&oacute;n puede resultarte conveniente utilizar el operador splat en
la lista de par&aacute;metros:</p>

<pre><code class="ruby">set(:autorizar) do |*roles|   # &lt;- mir&aacute; el splat
  condition do
    unless sesion_iniciada? &amp;&amp; roles.any? {|rol| usuario_actual.tiene_rol? rol }
      redirect "/iniciar_sesion/", 303
    end
  end
end

get "/mi/cuenta/", :autorizar =&gt; [:usuario, :administrador] do
  "Detalles de mi cuenta"
end

get "/solo/administradores/", :autorizar =&gt; :administrador do
  "&Uacute;nicamente para administradores!"
end
</code></pre>

<a name='Valores%20de%20Retorno'></a>
<h3>Valores de Retorno</h3>

<p>El valor de retorno de un bloque de ruta determina al menos el cuerpo de la
respuesta que se le pasa al cliente HTTP o al siguiente middleware en la pila
de Rack. Lo m&aacute;s com&uacute;n es que sea un string, como en los ejemplos anteriores.
Sin embargo, otros valor tambi&eacute;n son aceptados.</p>

<p>Pod&eacute;s devolver cualquier objeto que sea una respuesta Rack v&aacute;lida, un objeto
que represente el cuerpo de una respuesta Rack o un c&oacute;digo de estado HTTP:</p>

<p>De esa manera podemos, por ejemplo, implementar f&aacute;cilmente un streaming:</p>

<pre><code class="ruby">class Stream
  def each
    100.times { |i| yield "#{i}\n" }
  end
end

get('/') { Stream.new }
</code></pre>

<a name='Comparadores%20de%20Rutas%20Personalizados'></a>
<h3>Comparadores de Rutas Personalizados</h3>

<p>Como se mostr&oacute; anteriormente, Sinatra permite utilizar Strings y expresiones
regulares para definir las rutas. Sin embargo, la cosa no termina ah&iacute;. Pod&eacute;s
definir tus propios comparadores muy f&aacute;cilmente:</p>

<pre><code class="ruby">class PattronCualquieraMenos
  Match = Struct.new(:captures)

  def initialize(excepto)
    @excepto  = excepto
    @capturas = Match.new([])
  end

  def match(str)
    @capturas unless @excepto === str
  end
end

def cualquiera_menos(patron)
  PatronCualquieraMenos.new(patron)
end

get cualquiera_menos("/index") do
  # ...
end
</code></pre>

<p>Ten&eacute; en cuenta que el ejemplo anterior es un poco rebuscado. Un resultado
similar puede conseguirse m&aacute;s sencillamente:</p>

<pre><code class="ruby">get // do
  pass if request.path_info == "/index"
  # ...
end
</code></pre>

<p>O, usando un lookahead negativo:</p>

<pre><code class="ruby">get %r{^(?!/index$)} do
  # ...
end
</code></pre>

<a name='Archivos%20Est&aacute;ticos'></a>
<h3>Archivos Est&aacute;ticos</h3>

<p>Los archivos est&aacute;ticos son servidos desde el directorio p&uacute;blico
<code>./public</code>. Pod&eacute;s especificar una ubicaci&oacute;n diferente ajustando la
opci&oacute;n <code>:public_folder</code>:</p>

<pre><code class="ruby">set :public_folder, File.dirname(__FILE__) + '/estaticos'
</code></pre>

<p>Not&aacute; que el nombre del directorio p&uacute;blico no est&aacute; incluido en la URL. Por
ejemplo, el archivo <code>./public/css/style.css</code> se accede a trav&eacute;s de
<code>http://ejemplo.com/css/style.css</code>.</p>

<p>Us&aacute; la configuraci&oacute;n <code>:static_cache_control</code> para agregar el encabezado
<code>Cache-Control</code> (ver la secci&oacute;n de configuraci&oacute;n para m&aacute;s detalles).</p>

<a name='Vistas%20/%20Plantillas'></a>
<h3>Vistas / Plantillas</h3>

<p>Cada lenguaje de plantilla se expone a trav&eacute;s de un m&eacute;todo de renderizado que
lleva su nombre. Estos m&eacute;todos simplemente devuelven un string:</p>

<pre><code class="ruby">get '/' do
  erb :index
end
</code></pre>

<p>Renderiza <code>views/index.erb</code>.</p>

<p>En lugar del nombre de la plantilla pod&eacute;s proporcionar directamente el
contenido de la misma:</p>

<pre><code class="ruby">get '/' do
  codigo = "&lt;%= Time.now %&gt;"
  erb codigo
end
</code></pre>

<p>Los m&eacute;todos de renderizado, aceptan adem&aacute;s un segundo argumento, el hash de
opciones:</p>

<pre><code class="ruby">get '/' do
  erb :index, :layout =&gt; :post
end
</code></pre>

<p>Renderiza <code>views/index.erb</code> embebido en <code>views/post.erb</code> (por
defecto, la plantilla <code>:index</code> es embebida en <code>views/layout.erb</code> siempre y
cuando este &uacute;ltimo archivo exista).</p>

<p>Cualquier opci&oacute;n que Sinatra no entienda le ser&aacute; pasada al motor de renderizado
de la plantilla:</p>

<pre><code class="ruby">get '/' do
  haml :index, :format =&gt; :html5
end
</code></pre>

<p>Adem&aacute;s pod&eacute;s definir las opciones para un lenguaje de plantillas de forma
general:</p>

<pre><code class="ruby">set :haml, :format =&gt; :html5

get '/' do
  haml :index
end
</code></pre>

<p>Las opciones pasadas al m&eacute;todo de renderizado tienen precedencia sobre las
definidas mediante <code>set</code>.</p>

<p>Opciones disponibles:</p>

<dl>
<dt>locals</dt>
  <dd>
    Lista de variables locales pasadas al documento. Resultan muy &uacute;tiles cuando
    se combinan con parciales.
    Ejemplo: <tt>erb "", :locals =&gt; {:foo =&gt; "bar"}</tt>
  </dd>

  <dt>default_encoding</dt>
  <dd>
    Encoding utilizado cuando el de un string es dudoso. Por defecto toma el
    valor de <tt>settings.default_encoding</tt>.
  </dd>

  <dt>views</dt>
  <dd>
    Directorio desde donde se cargan las vistas. Por defecto toma el valor de
    <tt>settings.views</tt>.
  </dd>

  <dt>layout</dt>
  <dd>
    Si es <tt>true</tt> o <tt>false</tt> indica que se debe usar, o n&oacute;, un layout,
    respectivamente. Tambi&eacute;n puede ser un s&iacute;mbolo que especifique qu&eacute; plantilla
    usar. Ejemplo: <tt>erb :index, :layout =&gt; !request.xhr?</tt>
  </dd>

  <dt>content_type</dt>
  <dd>
    Content-Type que produce la plantilla. El valor por defecto depende de cada
    lenguaje de plantillas.
  </dd>

  <dt>scope</dt>
  <dd>
    &Aacute;mbito en el que se renderiza la plantilla. Por defecto utiliza la instancia
    de la aplicaci&oacute;n. Ten&eacute; en cuenta que si cambi&aacute;s esta opci&oacute;n las variables de
    instancia y los helpers van a dejar de estar disponibles.
  </dd>

  <dt>layout_engine</dt>
  <dd>
    Motor de renderizado de plantillas que usa para el layout. Resulta
    conveniente para lenguajes que no soportan layouts. Por defecto toma el valor
    del motor usado para renderizar la plantilla.
    Ejemplo: <tt>set :rdoc, :layout_engine =&gt; :erb</tt>
  </dd>

  <dd>
    Se asume que las plantillas est&aacute;n ubicadas directamente bajo el directorio
    <tt>./views</tt>. Para usar un directorio de vistas diferente:
    <tt>set :views, settings.root + '/plantillas'</tt>
  </dd>

  <dd>
    Es importante acordarse que siempre ten&eacute;s que referenciar a las plantillas con
    s&iacute;mbolos, incluso cuando se encuentran en un subdirectorio (en este caso
    ten&eacute;s que usar: <tt>'subdir/plantilla'</tt>). Ten&eacute;s que usar un s&iacute;mbolo porque los
    m&eacute;todos de renderizaci&oacute;n van a renderizar directamente cualquier string que se
    les pase como argumento.
  </dd>
</dl>
<a name='Lenguajes%20de%20Plantillas%20Disponibles'></a>
<h3>Lenguajes de Plantillas Disponibles</h3>

<p>Algunos lenguajes tienen varias implementaciones. Para especificar que
implementaci&oacute;n usar (y para ser thread-safe), deber&iacute;as requerirla antes de
usarla:</p>

<pre><code class="ruby">require 'rdiscount' # o require 'bluecloth'
get('/') { markdown :index }
</code></pre>

<a name='Plantillas%20Haml'></a>
<h3>Plantillas Haml</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="http://haml.info/" title="haml">haml</a></td>
  </tr>
<tr>
<td>Expresiones de Archivo</td>
    <td><tt>.haml</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>haml :index, :format =&gt; :html5</tt></td>
  </tr>
</table>
<a name='Plantillas%20Erb'></a>
<h3>Plantillas Erb</h3>

<table>
<tr>
<td>Dependencias</td>
    <td>
      <a href="http://www.kuwata-lab.com/erubis/" title="erubis">erubis</a>
      o erb (incluida en Ruby)
    </td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td>
<tt>.erb</tt>, <tt>.rhtml</tt> o <tt>.erubis</tt> (solamente con Erubis)</td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>
<a name='Plantillas%20Builder'></a>
<h3>Plantillas Builder</h3>

<table>
<tr>
<td>Dependencias</td>
    <td>
      <a href="http://builder.rubyforge.org/" title="builder">builder</a>
    </td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.builder</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>builder { |xml| xml.em "hola" }</tt></td>
  </tr>
</table>
<p>Adem&aacute;s, acepta un bloque con la definici&oacute;n de la plantilla (ver el ejemplo).</p>

<a name='Plantillas%20Nokogiri'></a>
<h3>Plantillas Nokogiri</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="http://nokogiri.org/" title="nokogiri">nokogiri</a></td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>nokogiri { |xml| xml.em "hola" }</tt></td>
  </tr>
</table>
<p>Adem&aacute;s, acepta un bloque con la definici&oacute;n de la plantilla (ver el ejemplo).</p>

<a name='Plantillas%20Sass'></a>
<h3>Plantillas Sass</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.sass</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>sass :stylesheet, :style =&gt; :expanded</tt></td>
  </tr>
</table>
<a name='Plantillas%20SCSS'></a>
<h3>Plantillas SCSS</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.scss</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>scss :stylesheet, :style =&gt; :expanded</tt></td>
  </tr>
</table>
<a name='Plantillas%20Less'></a>
<h3>Plantillas Less</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="http://www.lesscss.org/" title="less">less</a></td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.less</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>less :stylesheet</tt></td>
  </tr>
</table>
<a name='Plantillas%20Liquid'></a>
<h3>Plantillas Liquid</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="http://www.liquidmarkup.org/" title="liquid">liquid</a></td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.liquid</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>liquid :index, :locals =&gt; { :clave =&gt; 'valor' }</tt></td>
  </tr>
</table>
<p>Como no vas a poder llamar a m&eacute;todos de Ruby (excepto por <code>yield</code>) desde una
plantilla Liquid, casi siempre vas a querer pasarle locales.</p>

<a name='Plantillas%20Markdown'></a>
<h3>Plantillas Markdown</h3>

<table>
<tr>
<td>Dependencias</td>
    <td>
      <a href="https://github.com/rtomayko/rdiscount" title="RDiscount">RDiscount</a>,
      <a href="https://github.com/vmg/redcarpet" title="RedCarpet">RedCarpet</a>,
      <a href="http://deveiate.org/projects/BlueCloth" title="BlueCloth">BlueCloth</a>,
      <a href="http://kramdown.rubyforge.org/" title="kramdown">kramdown</a> o
      <a href="http://maruku.rubyforge.org/" title="maruku">maruku</a>
    </td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td>
<tt>.markdown</tt>, <tt>.mkd</tt> y <tt>.md</tt>
</td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>markdown :index, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>
<p>No es posible llamar m&eacute;todos desde markdown, ni pasarle locales. Por lo tanto,
generalmente vas a usarlo en combinaci&oacute;n con otro motor de renderizado:</p>

<pre><code class="ruby">erb :resumen, :locals =&gt; { :texto =&gt; markdown(:introduccion) }
</code></pre>

<p>Ten&eacute; en cuenta que tambi&eacute;n pod&eacute;s llamar al m&eacute;todo <code>markdown</code> desde otras
plantillas:</p>

<pre><code class="ruby">%h1 Hola Desde Haml!
%p= markdown(:saludos)
</code></pre>

<p>Como no pod&eacute;s utilizar Ruby desde Markdown, no pod&eacute;s usar layouts escritos en
Markdown. De todos modos, es posible usar un motor de renderizado para el
layout distinto al de la plantilla pasando la opci&oacute;n <code>:layout_engine</code>.</p>

<a name='Plantillas%20Textile'></a>
<h3>Plantillas Textile</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="http://redcloth.org/" title="RedCloth">RedCloth</a></td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.textile</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>textile :index, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>
<p>No es posible llamar m&eacute;todos desde textile, ni pasarle locales. Por lo tanto,
generalmente vas a usarlo en combinaci&oacute;n con otro motor de renderizado:</p>

<pre><code class="ruby">erb :resumen, :locals =&gt; { :texto =&gt; textile(:introduccion) }
</code></pre>

<p>Ten&eacute; en cuenta que tambi&eacute;n pod&eacute;s llamar al m&eacute;todo <code>textile</code> desde otras
plantillas:</p>

<pre><code class="ruby">%h1 Hola Desde Haml!
%p= textile(:saludos)
</code></pre>

<p>Como no pod&eacute;s utilizar Ruby desde Textile, no pod&eacute;s usar layouts escritos en
Textile. De todos modos, es posible usar un motor de renderizado para el
layout distinto al de la plantilla pasando la opci&oacute;n <code>:layout_engine</code>.</p>

<a name='Plantillas%20RDoc'></a>
<h3>Plantillas RDoc</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="http://rdoc.rubyforge.org/" title="RDoc">RDoc</a></td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.rdoc</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>rdoc :README, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>
<p>No es posible llamar m&eacute;todos desde rdoc, ni pasarle locales. Por lo tanto,
generalmente vas a usarlo en combinaci&oacute;n con otro motor de renderizado:</p>

<pre><code class="ruby">erb :resumen, :locals =&gt; { :texto =&gt; rdoc(:introduccion) }
</code></pre>

<p>Ten&eacute; en cuenta que tambi&eacute;n pod&eacute;s llamar al m&eacute;todo <code>rdoc</code> desde otras
plantillas:</p>

<pre><code class="ruby">%h1 Hola Desde Haml!
%p= rdoc(:saludos)
</code></pre>

<p>Como no pod&eacute;s utilizar Ruby desde RDoc, no pod&eacute;s usar layouts escritos en RDoc.
De todos modos, es posible usar un motor de renderizado para el layout distinto
al de la plantilla pasando la opci&oacute;n <code>:layout_engine</code>.</p>

<a name='Plantillas%20Radius'></a>
<h3>Plantillas Radius</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="http://radius.rubyforge.org/" title="Radius">Radius</a></td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.radius</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>radius :index, :locals =&gt; { :clave =&gt; 'valor' }</tt></td>
  </tr>
</table>
<p>Como no vas a poder llamar a m&eacute;todos de Ruby (excepto por <code>yield</code>) desde una
plantilla Radius, casi siempre vas a querer pasarle locales.</p>

<a name='Plantillas%20Markaby'></a>
<h3>Plantillas Markaby</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="http://markaby.github.com/" title="Markaby">Markaby</a></td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.mab</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>markaby { h1 "Bienvenido!" }</tt></td>
  </tr>
</table>
<p>Adem&aacute;s, acepta un bloque con la definici&oacute;n de la plantilla (ver el ejemplo).</p>

<a name='Plantillas%20RABL'></a>
<h3>Plantillas RABL</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="https://github.com/nesquena/rabl" title="Rabl">Rabl</a></td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.rabl</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>
<a name='Plantillas%20Slim'></a>
<h3>Plantillas Slim</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="http://slim-lang.com/" title="Slim Lang">Slim Lang</a></td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.slim</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>
<a name='Plantillas%20Creole'></a>
<h3>Plantillas Creole</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="https://github.com/minad/creole" title="Creole">Creole</a></td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.creole</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>creole :wiki, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>
<p>No es posible llamar m&eacute;todos desde creole, ni pasarle locales. Por lo tanto,
generalmente vas a usarlo en combinaci&oacute;n con otro motor de renderizado:</p>

<pre><code class="ruby">erb :resumen, :locals =&gt; { :texto =&gt; cerole(:introduccion) }
</code></pre>

<p>Ten&eacute; en cuenta que tambi&eacute;n pod&eacute;s llamar al m&eacute;todo <code>creole</code> desde otras
plantillas:</p>

<pre><code class="ruby">%h1 Hola Desde Haml!
%p= creole(:saludos)
</code></pre>

<p>Como no pod&eacute;s utilizar Ruby desde Creole, no pod&eacute;s usar layouts escritos en
Creloe. De todos modos, es posible usar un motor de renderizado para el layout
distinto al de la plantilla pasando la opci&oacute;n <code>:layout_engine</code>.</p>

<a name='Plantillas%20CoffeeScript'></a>
<h3>Plantillas CoffeeScript</h3>

<table>
<tr>
<td>Dependencias</td>
    <td>
      <a href="https://github.com/josh/ruby-coffee-script" title="Ruby CoffeeScript">
        CoffeeScript
      </a> y un
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        mecanismo para ejecutar javascript
      </a>
    </td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.coffee</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>
<a name='Plantillas%20Stylus'></a>
<h3>Plantillas Stylus</h3>

<table>
<tr>
<td>Dependencias</td>
    <td>
      <a href="https://github.com/lucasmazza/ruby-stylus" title="Ruby Stylus">
        Stylus
      </a> y un
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        mecanismo para ejecutar javascript
      </a>
    </td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.styl</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>stylus :index</tt></td>
  </tr>
</table>
<a name='Plantillas%20Yajl'></a>
<h3>Plantillas Yajl</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="https://github.com/brianmario/yajl-ruby" title="yajl-ruby">yajl-ruby</a></td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.yajl</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td>
      <tt>
        yajl :index,
             :locals =&gt; { :key =&gt; 'qux' },
             :callback =&gt; 'present',
             :variable =&gt; 'resource'
      </tt>
    </td>
  </tr>
</table>
<p>El contenido de La plantilla se eval&uacute;a como c&oacute;digo Ruby, y la variable <code>json</code> es convertida a JSON mediante <code>#to_json</code>.</p>

<pre><code class="ruby">json = { :foo =&gt; 'bar' }
json[:baz] = key
</code></pre>

<p>Las opciones <code>:callback</code> y <code>:variable</code> se pueden utilizar para decorar el objeto renderizado:</p>

<pre><code class="ruby">var resource = {"foo":"bar","baz":"qux"}; present(resource);
</code></pre>

<a name='Plantillas%20WLang'></a>
<h3>Plantillas WLang</h3>

<table>
<tr>
<td>Dependencias</td>
    <td><a href="https://github.com/blambeau/wlang/" title="wlang">wlang</a></td>
  </tr>
<tr>
<td>Extensiones de Archivo</td>
    <td><tt>.wlang</tt></td>
  </tr>
<tr>
<td>Ejemplo</td>
    <td><tt>wlang :index, :locals =&gt; { :clave =&gt; 'valor' }</tt></td>
  </tr>
</table>
<p>Como no vas a poder llamar a m&eacute;todos de Ruby (excepto por <code>yield</code>) desde una
plantilla WLang, casi siempre vas a querer pasarle locales.</p>

<a name='Plantillas%20Embebidas'></a>
<h3>Plantillas Embebidas</h3>

<pre><code class="ruby">get '/' do
  haml '%div.titulo Hola Mundo'
end
</code></pre>

<p>Renderiza el template embebido en el string.</p>

<a name='Accediendo%20a%20Variables%20en%20Plantillas'></a>
<h3>Accediendo a Variables en Plantillas</h3>

<p>Las plantillas son evaluadas dentro del mismo contexto que los manejadores de
ruta. Las variables de instancia asignadas en los manejadores de ruta son
accesibles directamente por las plantillas:</p>

<pre><code class="ruby">get '/:id' do
  @foo = Foo.find(params[:id])
  haml '%h1= @foo.nombre'
end
</code></pre>

<p>O es posible especificar un Hash de variables locales expl&iacute;citamente:</p>

<pre><code class="ruby">get '/:id' do
  foo = Foo.find(params[:id])
  haml '%h1= bar.nombre', :locals =&gt; { :bar =&gt; foo }
end
</code></pre>

<p>Esto es usado t&iacute;picamente cuando se renderizan plantillas como parciales desde
adentro de otras plantillas.</p>

<a name='Plantillas%20Inline'></a>
<h3>Plantillas Inline</h3>

<p>Las plantillas pueden ser definidas al final del archivo fuente:</p>

<pre><code class="ruby">require 'rubygems'
require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.titulo Hola mundo!!!!!
</code></pre>

<p>NOTA: &uacute;nicamente las plantillas inline definidas en el archivo fuente que
requiere sinatra son cargadas autom&aacute;ticamente. Llam&aacute; <code>enable
:inline_templates</code> expl&iacute;citamente si ten&eacute;s plantillas inline en otros
archivos fuente.</p>

<a name='Plantillas%20Nombradas'></a>
<h3>Plantillas Nombradas</h3>

<p>Las plantillas tambi&eacute;n pueden ser definidas usando el m&eacute;todo top-level
<code>template</code>:</p>

<pre><code class="ruby">template :layout do
  "%html\n  =yield\n"
end

template :index do
  '%div.titulo Hola Mundo!'
end

get '/' do
  haml :index
end
</code></pre>

<p>Si existe una plantilla con el nombre "layout", va a ser usada cada vez que
una plantilla es renderizada. Pod&eacute;s desactivar los layouts individualmente
pasando <code>:layout =&gt; false</code> o globalmente con
<code>set :haml, :layout =&gt; false</code>:</p>

<pre><code class="ruby">get '/' do
  haml :index, :layout =&gt; !request.xhr?
end
</code></pre>

<a name='Asociando%20Extensiones%20de%20Archivo'></a>
<h3>Asociando Extensiones de Archivo</h3>

<p>Para asociar una extensi&oacute;n de archivo con un motor de renderizado, us&aacute;
<code>Tilt.register</code>. Por ejemplo, si quer&eacute;s usar la extensi&oacute;n <code>tt</code> para
las plantillas Textile, pod&eacute;s hacer lo siguiente:</p>

<pre><code class="ruby">Tilt.register :tt, Tilt[:textile]
</code></pre>

<a name='Agregando%20Tu%20Propio%20Motor%20de%20Renderizado'></a>
<h3>Agregando Tu Propio Motor de Renderizado</h3>

<p>Primero, registr&aacute; tu motor con Tilt, y despu&eacute;s, cre&aacute; tu m&eacute;todo de renderizado:</p>

<pre><code class="ruby">Tilt.register :mipg, MiMotorParaPlantillaGenial

helpers do
  def mypg(*args) render(:mypg, *args) end
end

get '/' do
  mypg :index
end
</code></pre>

<p>Renderiza <code>./views/index.mypg</code>. Mir&aacute; https://github.com/rtomayko/tilt
para aprender m&aacute;s de Tilt.</p>

<a name='Filtros'></a>
<h2>Filtros</h2>

<p>Los filtros <code>before</code> son evaluados antes de cada petici&oacute;n dentro del mismo
contexto que las rutas. Pueden modificar la petici&oacute;n y la respuesta. Las
variables de instancia asignadas en los filtros son accesibles por las rutas y
las plantillas:</p>

<pre><code class="ruby">before do
  @nota = 'Hey!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @nota #=&gt; 'Hey!'
  params[:splat] #=&gt; 'bar/baz'
end
</code></pre>

<p>Los filtros <code>after</code> son evaluados despu&eacute;s de cada petici&oacute;n dentro del mismo
contexto y tambi&eacute;n pueden modificar la petici&oacute;n y la respuesta. Las variables
de instancia asignadas en los filtros <code>before</code> y en las rutas son accesibles por
los filtros <code>after</code>:</p>

<pre><code class="ruby">after do
  puts response.status
end
</code></pre>

<p>Nota: A menos que us&eacute;s el m&eacute;todo <code>body</code> en lugar de simplemente devolver un
string desde una ruta, el cuerpo de la respuesta no va a estar disponible en
un filtro after, debido a que todav&iacute;a no se ha generado.</p>

<p>Los filtros aceptan un patr&oacute;n opcional, que cuando est&aacute; presente causa que los
mismos sean evaluados &uacute;nicamente si el path de la petici&oacute;n coincide con ese
patr&oacute;n:</p>

<pre><code class="ruby">before '/protegido/*' do
  autenticar!
end

after '/crear/:slug' do |slug|
  session[:ultimo_slug] = slug
end
</code></pre>

<p>Al igual que las rutas, los filtros tambi&eacute;n pueden aceptar condiciones:</p>

<pre><code class="ruby">before :agent =&gt; /Songbird/ do
  # ...
end

after '/blog/*', :host_name =&gt; 'ejemplo.com' do
  # ...
end
</code></pre>

<a name='Ayudantes'></a>
<h2>Ayudantes</h2>

<p>Us&aacute; el m&eacute;todo top-level <em>helpers</em> para definir m&eacute;todos ayudantes que
pueden ser utilizados dentro de los manejadores de rutas y las plantillas:</p>

<pre><code class="ruby">helpers do
  def bar(nombre)
    "#{nombre}bar"
  end
end

get '/:nombre' do
  bar(params[:nombre])
end
</code></pre>

<p>Por cuestiones organizativas, puede resultar conveniente organizar los m&eacute;todos
ayudantes en distintos m&oacute;dulos:</p>

<pre><code class="ruby">module FooUtils
  def foo(nombre) "#{nombre}foo" end
end

module BarUtils
  def bar(nombre) "#{nombre}bar" end
end

helpers FooUtils, BarUtils
</code></pre>

<p>El efecto de utilizar <em>helpers</em> de esta manera es el mismo que resulta de
incluir los m&oacute;dulos en la clase de la aplicaci&oacute;n.</p>

<a name='Usando%20Sesiones'></a>
<h3>Usando Sesiones</h3>

<p>Una sesi&oacute;n es usada para mantener el estado a trav&eacute;s de distintas peticiones.
Cuando est&aacute;n activadas, ten&eacute;s un hash de sesi&oacute;n para cada sesi&oacute;n de usuario:</p>

<pre><code class="ruby">enable :sessions

get '/' do
  "valor = " &lt;&lt; session[:valor].inspect
end

get '/:valor' do
  session[:valor] = params[:valor]
end
</code></pre>

<p>Ten&eacute; en cuenta que <code>enable :sessions</code> guarda todos los datos en una
cookie, lo que no es siempre deseable (guardar muchos datos va a incrementar
tu tr&aacute;fico, por citar un ejemplo). Pod&eacute;s usar cualquier middleware Rack para
manejar sesiones, de la misma manera que usar&iacute;as cualquier otro middleware,
pero con la salvedad de que <em>no</em> ten&eacute;s que llamar a <code>enable :sessions</code>:</p>

<pre><code class="ruby">use Rack::Session::Pool, :expire_after =&gt; 2592000

get '/' do
  "valor = " &lt;&lt; session[:valor].inspect
end

get '/:valor' do
  session[:valor] = params[:valor]
end
</code></pre>

<p>Para incrementar la seguridad, los datos de la sesi&oacute;n almacenados en
la cookie son firmados con un secreto de sesi&oacute;n. Este secreto, es
generado aleatoriamente por Sinatra. De cualquier manera, hay que
tener en cuenta que cada vez que inicies la aplicaci&oacute;n se va a generar
uno nuevo. As&iacute;, si quer&eacute;s que todas las instancias de tu aplicaci&oacute;n
compartan un &uacute;nico secreto, ten&eacute;s que definirlo vos:</p>

<pre><code class="ruby">set :session_secret, 'super secreto'
</code></pre>

<p>Si necesit&aacute;s una configuraci&oacute;n m&aacute;s espec&iacute;fica, <code>sessions</code> acepta un
Hash con opciones:</p>

<pre><code class="ruby">set :sessions, :domain =&gt; 'foo.com'
</code></pre>

<a name='Interrupci&oacute;n'></a>
<h3>Interrupci&oacute;n</h3>

<p>Para detener inmediatamente una petici&oacute;n dentro de un filtro o una ruta us&aacute;:</p>

<pre><code class="ruby">halt
</code></pre>

<p>Tambi&eacute;n pod&eacute;s especificar el estado:</p>

<pre><code class="ruby">halt 410
</code></pre>

<p>O el cuerpo:</p>

<pre><code class="ruby">halt 'esto va a ser el cuerpo'
</code></pre>

<p>O los dos:</p>

<pre><code class="ruby">halt 401, 'sal&iacute; de ac&aacute;!'
</code></pre>

<p>Con cabeceras:</p>

<pre><code class="ruby">halt 402, { 'Content-Type' =&gt; 'text/plain' }, 'venganza'
</code></pre>

<p>Obviamente, es posible utilizar <code>halt</code> con una plantilla:</p>

<pre><code class="ruby">halt erb(:error)
</code></pre>

<a name='Paso'></a>
<h3>Paso</h3>

<p>Una ruta puede pasarle el procesamiento a la siguiente ruta que coincida con
la petici&oacute;n usando <code>pass</code>:</p>

<pre><code class="ruby">get '/adivina/:quien' do
  pass unless params[:quien] == 'Franco'
  'Adivinaste!'
end

get '/adivina/*' do
  'Erraste!'
end
</code></pre>

<p>Se sale inmediatamente del bloque de la ruta y se le pasa el control a la
siguiente ruta que coincida. Si no coincide ninguna ruta, se devuelve un 404.</p>

<a name='Ejecutando%20Otra%20Ruta'></a>
<h3>Ejecutando Otra Ruta</h3>

<p>Cuando quer&eacute;s obtener el resultado de la llamada a una ruta, <code>pass</code> no te va a
servir. Para lograr esto, pod&eacute;s usar <code>call</code>:</p>

<pre><code class="ruby">get '/foo' do
  status, headers, body = call env.merge("PATH_INFO" =&gt; '/bar')
  [status, headers, body.map(&amp;:upcase)]
end

get '/bar' do
  "bar"
end
</code></pre>

<p>Not&aacute; que en el ejemplo anterior, es conveniente mover <code>"bar"</code> a un
helper, y llamarlo desde <code>/foo</code> y <code>/bar</code>. As&iacute;, vas a simplificar
las pruebas y a mejorar el rendimiento.</p>

<p>Si quer&eacute;s que la petici&oacute;n se env&iacute;e a la misma instancia de la aplicaci&oacute;n en
lugar de a otra, us&aacute; <code>call!</code> en lugar de <code>call</code>.</p>

<p>En la especificaci&oacute;n de Rack pod&eacute;s encontrar m&aacute;s informaci&oacute;n sobre
<code>call</code>.</p>

<a name='Asignando%20el%20C&oacute;digo%20de%20Estado,%20los%20Encabezados%20y%20el%20Cuerpo%20de%20una%20Respuesta'></a>
<h3>Asignando el C&oacute;digo de Estado, los Encabezados y el Cuerpo de una Respuesta</h3>

<p>Es posible, y se recomienda, asignar el c&oacute;digo de estado y el cuerpo de una
respuesta con el valor de retorno de una ruta. De cualquier manera, en varios
escenarios, puede que sea conveniente asignar el cuerpo en un punto arbitrario
del flujo de ejecuci&oacute;n con el m&eacute;todo <code>body</code>. A partir de ah&iacute;, pod&eacute;s usar ese
mismo m&eacute;todo para acceder al cuerpo de la respuesta:</p>

<pre><code class="ruby">get '/foo' do
  body "bar"
end

after do
  puts body
end
</code></pre>

<p>Tambi&eacute;n es posible pasarle un bloque a <code>body</code>, que ser&aacute; ejecutado por el Rack
handler (pod&eacute;s usar esto para implementar streaming, mir&aacute; "Valores de retorno").</p>

<p>De manera similar, tambi&eacute;n pod&eacute;s asignar el c&oacute;digo de estado y encabezados:</p>

<pre><code class="ruby">get '/foo' do
  status 418
  headers \
    "Allow"   =&gt; "BREW, POST, GET, PROPFIND, WHEN",
    "Refresh" =&gt; "Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"
  body "I'm a tea pot!"
end
</code></pre>

<p>Tambi&eacute;n, al igual que <code>body</code>, tanto <code>status</code> como <code>headers</code> pueden utilizarse
para obtener sus valores cuando no se les pasa argumentos.</p>

<a name='Streaming%20De%20Respuestas'></a>
<h3>Streaming De Respuestas</h3>

<p>A veces vas a querer empezar a enviar la respuesta a pesar de que todav&iacute;a no
terminaste de generar su cuerpo. Tambi&eacute;n es posible que, en algunos casos,
quieras seguir enviando informaci&oacute;n hasta que el cliente cierre la conexi&oacute;n.
Cuando esto ocurra, el <code>stream</code> helper te va a ser de gran ayuda:</p>

<pre><code class="ruby">get '/' do
  stream do |out|
    out &lt;&lt; "Esto va a ser legen -\n"
    sleep 0.5
    out &lt;&lt; " (esperalo) \n"
    sleep 1
    out &lt;&lt; "- dario!\n"
  end
end
</code></pre>

<p>Pod&eacute;s implementar APIs de streaming,
<a href="http://dev.w3.org/html5/eventsource/">Server-Sent Events</a> y puede ser usado
como base para <a href="http://es.wikipedia.org/wiki/WebSockets">WebSockets</a>. Tambi&eacute;n
puede ser usado para incrementar el throughput si solo una parte del contenido
depende de un recurso lento.</p>

<p>Hay que tener en cuenta que el comportamiento del streaming, especialmente el
n&uacute;mero de peticiones concurrentes, depende del servidor web utilizado para
servir la aplicaci&oacute;n. Puede que algunos servidores, como es el caso de
WEBRick, no soporten streaming directamente, as&iacute; el cuerpo de la respuesta ser&aacute;
enviado completamente de una vez cuando el bloque pasado a <code>stream</code> finalice su
ejecuci&oacute;n. Si est&aacute;s usando Shotgun, el streaming no va a funcionar.</p>

<p>Cuando se pasa <code>keep_open</code> como par&aacute;metro, no se va a enviar el mensaje
<code>close</code> al objeto de stream. Queda en vos cerrarlo en el punto de ejecuci&oacute;n
que quieras. Nuevamente, hay que tener en cuenta que este comportamiento es
posible solo en servidores que soporten eventos, como Thin o Rainbows. El
resto de los servidores van a cerrar el stream de todos modos:</p>

<pre><code class="ruby">set :server, :thin
conexiones = []

get '/' do
  # mantenemos abierto el stream
  stream(:keep_open) { |salida| conexiones &lt;&lt; salida }
end

post '/' do
  # escribimos a todos los streams abiertos
  conexiones.each { |salida| salida &lt;&lt; params[:mensaje] &lt;&lt; "\n" }
  "mensaje enviado"
end
</code></pre>

<a name='Log%20(Registro)'></a>
<h3>Log (Registro)</h3>

<p>En el &aacute;mbito de la petici&oacute;n, el helper <code>logger</code> (registrador) expone
una instancia de <code>Logger</code>:</p>

<pre><code class="ruby">get '/' do
  logger.info "cargando datos"
  # ...
end
</code></pre>

<p>Este logger tiene en cuenta la configuraci&oacute;n de logueo de tu Rack
handler. Si el logueo est&aacute; desactivado, este m&eacute;todo va a devolver un
objeto que se comporta como un logger pero que en realidad no hace
nada. As&iacute;, no vas a tener que preocuparte por esta situaci&oacute;n.</p>

<p>Ten&eacute; en cuenta que el logueo est&aacute; habilitado por defecto &uacute;nicamente
para <code>Sinatra::Application</code>. Si heredaste de
<code>Sinatra::Base</code>, probablemente quieras habilitarlo manualmente:</p>

<pre><code class="ruby">class MiApp &lt; Sinatra::Base
  configure :production, :development do
    enable :logging
  end
end
</code></pre>

<p>Para evitar que se inicialice cualquier middleware de logging, configur&aacute;
<code>logging</code> a <code>nil</code>. Ten&eacute; en cuenta que, cuando hagas esto, <code>logger</code> va a
devolver <code>nil</code>. Un caso com&uacute;n es cuando quer&eacute;s usar tu propio logger. Sinatra
va a usar lo que encuentre en <code>env['rack.logger']</code>.</p>

<a name='Tipos%20Mime'></a>
<h3>Tipos Mime</h3>

<p>Cuando us&aacute;s <code>send_file</code> o archivos est&aacute;ticos tal vez tengas tipos mime
que Sinatra no entiende. Us&aacute; <code>mime_type</code> para registrarlos a trav&eacute;s de la
extensi&oacute;n de archivo:</p>

<pre><code class="ruby">configure do
  mime_type :foo, 'text/foo'
end
</code></pre>

<p>Tambi&eacute;n lo pod&eacute;s usar con el ayudante <code>content_type</code>:</p>

<pre><code class="ruby">get '/' do
  content_type :foo
  "foo foo foo"
end
</code></pre>

<a name='Generando%20URLs'></a>
<h3>Generando URLs</h3>

<p>Para generar URLs deber&iacute;as usar el m&eacute;todo <code>url</code>. Por ejemplo, en Haml:</p>

<pre><code class="ruby">%a{:href =&gt; url('/foo')} foo
</code></pre>

<p>Tiene en cuenta proxies inversos y encaminadores de Rack, si est&aacute;n presentes.</p>

<p>Este m&eacute;todo tambi&eacute;n puede invocarse mediante su alias <code>to</code>  (mir&aacute; un ejemplo
a continuaci&oacute;n).</p>

<a name='Redirecci&oacute;n%20del%20Navegador'></a>
<h3>Redirecci&oacute;n del Navegador</h3>

<p>Pod&eacute;s redireccionar al navegador con el m&eacute;todo <code>redirect</code>:</p>

<pre><code class="ruby">get '/foo' do
  redirect to('/bar')
end
</code></pre>

<p>Cualquier par&aacute;metro adicional se utiliza de la misma manera que los argumentos
pasados a <code>halt</code>:</p>

<pre><code class="ruby">redirect to('/bar'), 303
redirect 'http://google.com', 'te confundiste de lugar, compa&ntilde;ero'
</code></pre>

<p>Tambi&eacute;n pod&eacute;s redireccionar f&aacute;cilmente de vuelta hacia la p&aacute;gina desde donde
vino el usuario con <code>redirect back</code>:</p>

<pre><code class="ruby">get '/foo' do
  "&lt;a href='/bar'&gt;hacer algo&lt;/a&gt;"
end

get '/bar' do
  hacer_algo
  redirect back
end
</code></pre>

<p>Para pasar argumentos con una redirecci&oacute;n, pod&eacute;s agregarlos a la cadena de
b&uacute;squeda:</p>

<pre><code class="ruby">redirect to('/bar?suma=42')
</code></pre>

<p>O usar una sesi&oacute;n:</p>

<pre><code class="ruby">enable :sessions

get '/foo' do
  session[:secreto] = 'foo'
  redirect to('/bar')
end

get '/bar' do
  session[:secreto]
end
</code></pre>

<a name='Cache%20Control'></a>
<h3>Cache Control</h3>

<p>Asignar tus encabezados correctamente es el cimiento para realizar un cacheo
HTTP correcto.</p>

<p>Pod&eacute;s asignar el encabezado Cache-Control f&aacute;cilmente:</p>

<pre><code class="ruby">get '/' do
  cache_control :public
  "cachealo!"
end
</code></pre>

<p>Pro tip: configurar el cacheo en un filtro <code>before</code>:</p>

<pre><code class="ruby">before do
  cache_control :public, :must_revalidate, :max_age =&gt; 60
end
</code></pre>

<p>Si est&aacute;s usando el helper <code>expires</code> para definir el encabezado correspondiente,
<code>Cache-Control</code> se va a definir autom&aacute;ticamente:</p>

<pre><code class="ruby">before do
  expires 500, :public, :must_revalidate
end
</code></pre>

<p>Para usar cach&eacute;s adecuadamente, deber&iacute;as considerar usar <code>etag</code> o
<code>last_modified</code>. Es recomendable que llames a estos helpers <em>antes</em> de hacer
cualquier trabajo pesado, ya que van a enviar la respuesta inmediatamente si
el cliente ya tiene la versi&oacute;n actual en su cach&eacute;:</p>

<pre><code class="ruby">get '/articulo/:id' do
  @articulo = Articulo.find params[:id]
  last_modified @articulo.updated_at
  etag @articulo.sha1
  erb :articulo
end
</code></pre>

<p>Tambi&eacute;n es posible usar una
<a href="http://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation">weak ETag</a>:</p>

<pre><code class="ruby">etag @articulo.sha1, :weak
</code></pre>

<p>Estos helpers no van a cachear nada por vos, sino que van a facilitar la
informaci&oacute;n necesaria para poder hacerlo. Si est&aacute;s buscando soluciones r&aacute;pidas
de cacheo con proxys inversos, mir&aacute;
<a href="https://github.com/rtomayko/rack-cache">rack-cache</a>:</p>

<pre><code class="ruby">require "rack/cache"
require "sinatra"

use Rack::Cache

get '/' do
  cache_control :public, :max_age =&gt; 36000
  sleep 5
  "hola"
end
</code></pre>

<p>Us&aacute; la configuraci&oacute;n <code>:static_cache_control</code> para agregar el encabezado
<code>Cache-Control</code> a archivos est&aacute;ticos (ver la secci&oacute;n de configuraci&oacute;n
para m&aacute;s detalles).</p>

<p>De acuerdo con la RFC 2616 tu aplicaci&oacute;n deber&iacute;a comportarse diferente si a las
cabeceras If-Match o If-None-Match se le asigna el valor <code>*</code> cuando el
recurso solicitado ya existe. Sinatra asume para peticiones seguras (como get)
e idempotentes (como put) que el recurso existe, mientras que para el resto
(como post), que no. Podes cambiar este comportamiento con la opci&oacute;n
<code>:new_resource</code>:</p>

<pre><code class="ruby">get '/crear' do
  etag '', :new_resource =&gt; true
  Articulo.create
  erb :nuevo_articulo
end
</code></pre>

<p>Si quer&eacute;s seguir usando una weak ETag, indicalo con la opci&oacute;n <code>:kind</code>:</p>

<pre><code class="ruby">etag '', :new_resource =&gt; true, :kind =&gt; :weak
</code></pre>

<a name='Enviando%20Archivos'></a>
<h3>Enviando Archivos</h3>

<p>Para enviar archivos, pod&eacute;s usar el m&eacute;todo <code>send_file</code>:</p>

<pre><code class="ruby">get '/' do
  send_file 'foo.png'
end
</code></pre>

<p>Adem&aacute;s acepta un par de opciones:</p>

<pre><code class="ruby">send_file 'foo.png', :type =&gt; :jpg
</code></pre>

<p>Estas opciones son:</p>

<p>[filename]
  nombre del archivo devuelto, por defecto es el nombre real del archivo.</p>

<p>[last_modified]
  valor para el encabezado Last-Modified, por defecto toma el mtime del archivo.</p>

<p>[type]
  el content type que se va a utilizar, si no est&aacute; presente se intenta adivinar
  a partir de la extensi&oacute;n del archivo.</p>

<p>[disposition]
  se utiliza para el encabezado Content-Disposition, y puede tomar alguno de los
  siguientes valores: <code>nil</code> (por defecto), <code>:attachment</code> e
  <code>:inline</code></p>

<p>[length]
  encabezado Content-Length, por defecto toma el tama&ntilde;o del archivo.</p>

<p>[status]
  c&oacute;digo de estado devuelto. Resulta &uacute;til al enviar un archivo est&aacute;tico como una
  p&aacute;gina de error.</p>

<p>Si el Rack handler lo soporta, se intentar&aacute; no transmitir directamente desde el
proceso de Ruby. Si us&aacute;s este m&eacute;todo, Sinatra se va a encargar autom&aacute;ticamente
peticiones de rango.</p>

<a name='Accediendo%20al%20objeto%20de%20la%20petici&oacute;n'></a>
<h3>Accediendo al objeto de la petici&oacute;n</h3>

<p>El objeto de la petici&oacute;n entrante puede ser accedido desde el nivel de la
petici&oacute;n (filtros, rutas y manejadores de errores) a trav&eacute;s del m&eacute;todo
<code>request</code>:</p>

<pre><code class="ruby"># app corriendo en http://ejemplo.com/ejemplo
get '/foo' do
  t = %w[text/css text/html application/javascript]
  request.accept              # ['text/html', '*/*']
  request.accept? 'text/xml'  # true
  request.preferred_type(t)   # 'text/html'
  request.body                # cuerpo de la petici&oacute;n enviado por el cliente (ver m&aacute;s abajo)
  request.scheme              # "http"
  request.script_name         # "/ejemplo"
  request.path_info           # "/foo"
  request.port                # 80
  request.request_method      # "GET"
  request.query_string        # ""
  request.content_length      # longitud de request.body
  request.media_type          # tipo de medio de request.body
  request.host                # "ejemplo.com"
  request.get?                # true (hay m&eacute;todos an&aacute;logos para los otros verbos)
  request.form_data?          # false
  request["UNA_CABECERA"]     # valor de la cabecera UNA_CABECERA
  request.referrer            # la referencia del cliente o '/'
  request.user_agent          # user agent (usado por la condici&oacute;n :agent)
  request.cookies             # hash de las cookies del browser
  request.xhr?                # es una petici&oacute;n ajax?
  request.url                 # "http://ejemplo.com/ejemplo/foo"
  request.path                # "/ejemplo/foo"
  request.ip                  # direcci&oacute;n IP del cliente
  request.secure?             # false (ser&iacute;a true sobre ssl)
  request.forwarded?          # true (si se est&aacute; corriendo atr&aacute;s de un proxy inverso)
  requuest.env                # hash de entorno directamente entregado por Rack
end
</code></pre>

<p>Algunas opciones, como <code>script_name</code> o <code>path_info</code> pueden
tambi&eacute;n ser escritas:</p>

<pre><code class="ruby">before { request.path_info = "/" }

get "/" do
  "todas las peticiones llegan ac&aacute;"
end
</code></pre>

<p>El objeto <code>request.body</code> es una instancia de IO o StringIO:</p>

<pre><code class="ruby">post "/api" do
  request.body.rewind  # en caso de que alguien ya lo haya le&iacute;do
  datos = JSON.parse request.body.read
  "Hola #{datos['nombre']}!"
end
</code></pre>

<a name='Archivos%20Adjuntos'></a>
<h3>Archivos Adjuntos</h3>

<p>Pod&eacute;s usar el m&eacute;todo helper <code>attachment</code> para indicarle al navegador que
almacene la respuesta en el disco en lugar de mostrarla en pantalla:</p>

<pre><code class="ruby">get '/' do
  attachment
  "guardalo!"
end
</code></pre>

<p>Tambi&eacute;n pod&eacute;s pasarle un nombre de archivo:</p>

<pre><code class="ruby">get '/' do
  attachment "info.txt"
  "guardalo!"
end
</code></pre>

<a name='Fecha%20y%20Hora'></a>
<h3>Fecha y Hora</h3>

<p>Sinatra pone a tu disposici&oacute;n el helper <code>time_for</code>, que genera un objeto <code>Time</code>
a partir del valor que recibe como argumento. Este valor puede ser un
<code>String</code>, pero tambi&eacute;n es capaz de convertir objetos <code>DateTime</code>, <code>Date</code> y de
otras clases similares:</p>

<pre><code class="ruby">get '/' do
  pass if Time.now &gt; time_for('Dec 23, 2012')
  "todav&iacute;a hay tiempo"
end
</code></pre>

<p>Este m&eacute;todo es usado internamente por m&eacute;todos como <code>expires</code> y <code>last_modified</code>,
entre otros. Por lo tanto, es posible extender el comportamiento de estos
m&eacute;todos sobreescribiendo <code>time_for</code> en tu aplicaci&oacute;n:</p>

<pre><code class="ruby">helpers do
  def time_for(value)
    case value
    when :ayer then Time.now - 24*60*60
    when :ma&ntilde;ana then Time.now + 24*60*60
    else super
    end
  end
end

get '/' do
  last_modified :ayer
  expires :ma&ntilde;ana
  "hola"
end
</code></pre>

<a name='Buscando%20los%20Archivos%20de%20las%20Plantillas'></a>
<h3>Buscando los Archivos de las Plantillas</h3>

<p>El helper <code>find_template</code> se utiliza para encontrar los archivos de las
plantillas que se van a renderizar:</p>

<pre><code class="ruby">find_template settings.views, 'foo', Tilt[:haml] do |archivo|
  puts "podr&iacute;a ser #{archivo}"
end
</code></pre>

<p>Si bien esto no es muy &uacute;til, lo interesante es que pod&eacute;s sobreescribir este
m&eacute;todo, y as&iacute; enganchar tu propio mecanismo de b&uacute;squeda. Por ejemplo, para
poder utilizar m&aacute;s de un directorio de vistas:</p>

<pre><code class="ruby">set :views, ['vistas', 'plantillas']

helpers do
  def find_template(views, name, engine, &amp;block)
    Array(views).each { |v| super(v, name, engine, &amp;block) }
  end
end
</code></pre>

<p>Otro ejemplo consiste en usar directorios diferentes para los distintos motores
de renderizado:</p>

<pre><code class="ruby">set :views, :sass =&gt; 'vistas/sass', :haml =&gt; 'plantillas', :defecto =&gt; 'vistas'

helpers do
  def find_template(views, name, engine, &amp;block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:defecto]
    super(folder, name, engine, &amp;block)
  end
end
</code></pre>

<p>&iexcl;Es muy f&aacute;cil convertir estos ejemplos en una extensi&oacute;n y compartirla!.</p>

<p>Not&aacute; que <code>find_template</code> no verifica si un archivo existe realmente, sino
que llama al bloque que recibe para cada path posible. Esto no representa un
problema de rendimiento debido a que <code>render</code> va a usar <code>break</code> ni bien
encuentre un archivo que exista. Adem&aacute;s, las ubicaciones de las plantillas (y
su contenido) se cachean cuando no est&aacute;s en el modo de desarrollo. Es bueno
tener en cuenta lo anteiror si escrib&iacute;s un m&eacute;todo medio loco.</p>

<a name='Configuraci&oacute;n'></a>
<h2>Configuraci&oacute;n</h2>

<p>Ejecutar una vez, en el inicio, en cualquier entorno:</p>

<pre><code class="ruby">configure do
  # asignando una opci&oacute;n
  set :opcion, 'valor'

  # asignando varias opciones
  set :a =&gt; 1, :b =&gt; 2

  # atajo para `set :opcion, true`
  enable :opcion

  # atajo para `set :opcion, false`
  disable :opcion

  # tambi&eacute;n pod&eacute;s tener configuraciones din&aacute;micas usando bloques
  set(:css_dir) { File.join(views, 'css') }
end
</code></pre>

<p>Ejecutar &uacute;nicamente cuando el entorno (la variable de entorno RACK_ENV) es
<code>:production</code>:</p>

<pre><code class="ruby">configure :production do
  ...
end
</code></pre>

<p>Ejecutar cuando el entorno es <code>:production</code> o <code>:test</code>:</p>

<pre><code class="ruby">configure :production, :test do
  ...
end
</code></pre>

<p>Pod&eacute;s acceder a estas opciones utilizando el m&eacute;todo <code>settings</code>:</p>

<pre><code class="ruby">configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # =&gt; true
  settings.foo  # =&gt; 'bar'
  ...
end
</code></pre>

<a name='Configurando%20la%20Protecci&oacute;n%20de%20Ataques'></a>
<h3>Configurando la Protecci&oacute;n de Ataques</h3>

<p>Sinatra usa <a href="https://github.com/rkh/rack-protection#readme">Rack::Protection</a>
para defender a tu aplicaci&oacute;n de los ataques m&aacute;s comunes. Si por alg&uacute;n motivo,
quer&eacute;s desactivar esta funcionalidad, pod&eacute;s hacerlo como se indica a
continuaci&oacute;n (ten&eacute; en cuenta que tu aplicaci&oacute;n va a quedar expuesta a un
mont&oacute;n de vulnerabilidades bien conocidas):</p>

<pre><code class="ruby">disable :protection
</code></pre>

<p>Tambi&eacute;n es posible desactivar una &uacute;nica capa de defensa:</p>

<pre><code class="ruby">set :protection, :except =&gt; :path_traversal
</code></pre>

<p>O varias:</p>

<pre><code class="ruby">set :protection, :except =&gt; [:path_traversal, :session_hijacking]
</code></pre>

<a name='Configuraciones%20Disponibles'></a>
<h3>Configuraciones Disponibles</h3>

<dl>
<dt>absolute_redirects</dt>
  <dd>
    Si est&aacute; deshabilitada, Sinatra va a permitir
    redirecciones relativas, sin embargo, como consecuencia
    de esto, va a dejar de cumplir con el RFC 2616 (HTTP
    1.1), que solamente permite redirecciones absolutas.

    Activalo si tu apliaci&oacute;n est&aacute; corriendo atr&aacute;s de un proxy
    inverso que no se ha configurado adecuadamente. Not&aacute; que
    el helper <tt>url</tt> va a seguir produciendo URLs absolutas, a
    menos que le pas&eacute;s <tt>false</tt> como segundo par&aacute;metro.

    Deshabilitada por defecto.
  </dd>

  <dt>add_charsets</dt>
  <dd>
    Tipos mime a los que el helper <tt>content_type</tt> les
    a&ntilde;ade autom&aacute;ticamente el charset.

    En general, no deber&iacute;as asignar directamente esta opci&oacute;n,
    sino a&ntilde;adirle los charsets que quieras:
    <tt>settings.add_charsets &lt;&lt; "application/foobar"</tt>
  </dd>

  <dt>app_file</dt>
  <dd>
    Path del archivo principal de la aplicaci&oacute;n, se utiliza
    para detectar la ra&iacute;z del proyecto, el directorio de las
    vistas y el p&uacute;blico, as&iacute; como las plantillas inline.
  </dd>

  <dt>bind</dt>
  <dd>
    Direcci&oacute;n IP que utilizar&aacute; el servidor integrado (por
    defecto: 0.0.0.0).
  </dd>

  <dt>default_encoding</dt>
  <dd>
    Encoding utilizado cuando el mismo se desconoce (por
    defecto <tt>"utf-8"</tt>).
  </dd>

  <dt>dump_errors</dt>
  <dd>
    Mostrar errores en el log.
  </dd>

  <dt>environment</dt>
  <dd>
    Entorno actual, por defecto toma el valor de
    <tt>ENV['RACK_ENV']</tt>, o <tt>"development"</tt> si no
    est&aacute; disponible.
  </dd>

  <dt>logging</dt>
  <dd>
    Define si se utiliza el logger.
  </dd>

  <dt>lock</dt>
  <dd>
    Coloca un lock alrededor de cada petici&oacute;n, procesando
    solamente una por proceso.

    Habilit&aacute; esta opci&oacute;n si tu aplicaci&oacute;n no es thread-safe.
    Se encuentra deshabilitada por defecto.
  </dd>

  <dt>method_override</dt>
  <dd>
    Utiliza el par&aacute;metro <tt>_method</tt> para permtir
    formularios put/delete en navegadores que no los
    soportan.
  </dd>

  <dt>port</dt>
  <dd>
    Puerto en el que escuchar&aacute; el servidor integrado.
  </dd>

  <dt>prefixed_redirects</dt>
  <dd>
    Define si inserta <tt>request.script_name</tt> en las
    redirecciones cuando no se proporciona un path absoluto.
    De esta manera, cuando est&aacute; habilitada,
    <tt>redirect '/foo'</tt> se comporta de la misma manera
    que <tt>redirect to('/foo')</tt>. Se encuentra
    deshabilitada por defecto.
  </dd>

  <dt>protection</dt>
  <dd>
    Define si deben activarse las protecciones para los
    ataques web m&aacute;s comunes. Para m&aacute;s detalles mir&aacute; la
    secci&oacute;n sobre la configuraci&oacute;n de protecci&oacute;n de ataques
    m&aacute;s arriba.
  </dd>

  <dt>public_dir</dt>
  <dd>
    Alias para <tt>public_folder</tt>, que se encuentra a
    continuaci&oacute;n.
  </dd>

  <dt>public_folder</dt>
  <dd>
    Path del directorio desde donde se sirven los archivos
    p&uacute;blicos. Solo se utiliza cuando se sirven archivos
    est&aacute;ticos (ver la opci&oacute;n <tt>static</tt>). Si no
    est&aacute; presente, se infiere del valor de la opci&oacute;n
    <tt>app_file</tt>.
  </dd>

  <dt>reload_templates</dt>
  <dd>
    Define si se recargan las plantillas entre peticiones.

    Se encuentra activado en el entorno de desarrollo.
  </dd>

  <dt>root</dt>
  <dd>
    Path del directorio ra&iacute;z del proyecto. Si no est&aacute;
    presente, se infiere del valor de la opci&oacute;n
    <tt>app_file</tt>.
  </dd>

  <dt>raise_errors</dt>
  <dd>
    Elevar excepciones (detiene la aplicaci&oacute;n). Se
    encuentra activada por defecto cuando el valor de
    <tt>environment</tt>  es <tt>"test"</tt>. En caso
    contrario estar&aacute; desactivada.
  </dd>

  <dt>run</dt>
  <dd>
    Cuando est&aacute; habilitada, Sinatra se va a encargar de
    iniciar el servidor web, no la habilit&eacute;s cuando est&eacute;s
    usando rackup o alg&uacute;n otro medio.
  </dd>

  <dt>running</dt>
  <dd>
    Indica si el servidor integrado est&aacute; ejecutandose, &iexcl;no
    cambi&eacute;s esta configuraci&oacute;n!.
  </dd>

  <dt>server</dt>
  <dd>
    Servidor, o lista de servidores, para usar como servidor
    integrado. Por defecto: <tt>['thin', 'mongrel', 'webrick']</tt>,
    el orden establece la prioridad.
  </dd>

  <dt>sessions</dt>
  <dd>
    Habilita el soporte de sesiones basadas en cookies a
    trav&eacute;s de <tt>Rack::Session::Cookie</tt>. Ver la
    secci&oacute;n 'Usando Sesiones' para m&aacute;s informaci&oacute;n.
  </dd>

  <dt>show_exceptions</dt>
  <dd>
    Muestra un stack trace en el navegador cuando ocurre una
    excepci&oacute;n. Se encuentra activada por defecto cuando el
    valor de <tt>environment</tt> es <tt>"development"</tt>.
    En caso contrario estar&aacute; desactivada.
  </dd>

  <dt>static</dt>
  <dd>
    Define si Sinatra debe encargarse de servir archivos
    est&aacute;ticos.

    Deshabilitala cuando us&eacute;s un servidor capaz de
    hacerlo por s&iacute; solo, porque mejorar&aacute; el
    rendimiento. Se encuentra habilitada por
    defecto en el estilo cl&aacute;sico y desactivado en el
    el modular.
  </dd>

  <dt>static_cache_control</dt>
  <dd>
    Cuando Sinatra est&aacute; sirviendo archivos est&aacute;ticos, y
    est&aacute; opci&oacute;n est&aacute; habilitada, les va a agregar encabezados
    <tt>Cache-Control</tt> a las respuestas. Para esto
    utiliza el helper <tt>cache_control</tt>. Se encuentra
    deshabilitada por defecto. Notar que es necesario
    utilizar un array cuando se asignan m&uacute;ltiples valores:
    <tt>set :static_cache_control, [:public, :max_age =&gt; 300]</tt>.
  </dd>

  <dt>views</dt>
  <dd>
    Path del directorio de las vistas. Si no est&aacute; presente,
    se infiere del valor de la opci&oacute;n <tt>app_file</tt>.
  </dd>
</dl>
<a name='Entornos'></a>
<h2>Entornos</h2>

<p>Existen tres entornos (<code>environments</code>) predefinidos: <code>development</code>,
<code>production</code> y <code>test</code>. El entorno por defecto es
<code>development</code> y tiene algunas particularidades:</p>

<ul>
<li>Se recargan las plantillas entre una petici&oacute;n y la siguiente, a diferencia
de <code>production</code> y <code>test</code>, donde se cachean.</li>
<li>Se instalan manejadores de errores <code>not_found</code> y <code>error</code>
especiales que muestran un stack trace en el navegador cuando son disparados.</li>
</ul>
<p>Para utilizar alguno de los otros entornos puede asignarse el valor
correspondiente a la variable de entorno <code>RACK_ENV</code>, o bien utilizar la opci&oacute;n
<code>-e</code> al ejecutar la aplicaci&oacute;n:</p>

<pre><code class="shell">ruby mi_app.rb -e &lt;ENTORNO&gt;
</code></pre>

<p>Los m&eacute;todos <code>development?</code>, <code>test?</code> y <code>production?</code> te permiten conocer el
entorno actual.</p>

<a name='Manejo%20de%20Errores'></a>
<h2>Manejo de Errores</h2>

<p>Los manejadores de errores se ejecutan dentro del mismo contexto que las rutas
y los filtros <code>before</code>, lo que significa que pod&eacute;s usar, por ejemplo,
<code>haml</code>, <code>erb</code>, <code>halt</code>, etc.</p>

<h3>No encontrado <em>(Not Found)</em>
</h3>

<p>Cuando se eleva una excepci&oacute;n <code>Sinatra::NotFound</code>, o el c&oacute;digo de
estado de la respuesta es 404, el manejador <code>not_found</code> es invocado:</p>

<pre><code class="ruby">not_found do
  'No existo'
end
</code></pre>

<a name='Error'></a>
<h3>Error</h3>

<p>El manejador <code>error</code> es invocado cada vez que una excepci&oacute;n es elevada
desde un bloque de ruta o un filtro. El objeto de la excepci&oacute;n se puede
obtener de la variable Rack <code>sinatra.error</code>:</p>

<pre><code class="ruby">error do
  'Disculp&aacute;, ocurri&oacute; un error horrible - ' + env['sinatra.error'].name
end
</code></pre>

<p>Errores personalizados:</p>

<pre><code class="ruby">error MiErrorPersonalizado do
  'Lo que pas&oacute; fue...' + env['sinatra.error'].message
end
</code></pre>

<p>Entonces, si pasa esto:</p>

<pre><code class="ruby">get '/' do
  raise MiErrorPersonalizado, 'algo malo'
end
</code></pre>

<p>Obten&eacute;s esto:</p>

<p>Lo que pas&oacute; fue... algo malo</p>

<p>Tambi&eacute;n, pod&eacute;s instalar un manejador de errores para un c&oacute;digo de estado:</p>

<pre><code class="ruby">error 403 do
  'Acceso prohibido'
end

get '/secreto' do
  403
end
</code></pre>

<p>O un rango:</p>

<pre><code class="ruby">error 400..510 do
  'Boom'
end
</code></pre>

<p>Sinatra instala manejadores <code>not_found</code> y <code>error</code> especiales
cuando se ejecuta dentro del entorno de desarrollo "development".</p>

<a name='Rack%20Middleware'></a>
<h2>Rack Middleware</h2>

<p>Sinatra corre sobre Rack[http://rack.rubyforge.org/], una interfaz minimalista
que es un est&aacute;ndar para frameworks webs escritos en Ruby. Una de las
capacidades m&aacute;s interesantes de Rack para los desarrolladores de aplicaciones
es el soporte de "middleware" -- componentes que se ubican entre el servidor y
tu aplicaci&oacute;n, supervisando y/o manipulando la petici&oacute;n/respuesta HTTP para
proporcionar varios tipos de funcionalidades comunes.</p>

<p>Sinatra hace muy sencillo construir tuber&iacute;as de Rack middleware a trav&eacute;s del
m&eacute;todo top-level <code>use</code>:</p>

<pre><code class="ruby">require 'sinatra'
require 'mi_middleware_personalizado'

use Rack::Lint
use MiMiddlewarePersonalizado

get '/hola' do
  'Hola Mundo'
end
</code></pre>

<p>Las sem&aacute;nticas de <code>use</code> son id&eacute;nticas a las definidas para el DSL
Rack::Builder<a href="m%C3%A1s%0Afrecuentemente%20usado%20desde%20archivos%20rackup">http://rack.rubyforge.org/doc/classes/Rack/Builder.html</a>. Por ejemplo, el m&eacute;todo <code>use</code>
acepta argumentos m&uacute;ltiples/variables as&iacute; como bloques:</p>

<pre><code class="ruby">use Rack::Auth::Basic do |nombre_de_usuario, password|
  nombre_de_usuario == 'admin' &amp;&amp; password == 'secreto'
end
</code></pre>

<p>Rack es distribuido con una variedad de middleware est&aacute;ndar para logging,
debugging, enrutamiento URL, autenticaci&oacute;n, y manejo de sesiones. Sinatra
usa muchos de estos componentes autom&aacute;ticamente de acuerdo a su configuraci&oacute;n
para que t&iacute;picamente no tengas que usarlas (con <code>use</code>) expl&iacute;citamente.</p>

<p>Pod&eacute;s encontrar middleware &uacute;til en
<a href="https://github.com/rack/rack/tree/master/lib/rack">rack</a>,
<a href="https://github.com/rack/rack-contrib#readme">rack-contrib</a>,
con <a href="http://coderack.org/">CodeRack</a> o en la
<a href="https://github.com/rack/rack/wiki/List-of-Middleware">Rack wiki</a>.</p>

<a name='Pruebas'></a>
<h2>Pruebas</h2>

<p>Las pruebas para las aplicaciones Sinatra pueden ser escritas utilizando
cualquier framework o librer&iacute;a de pruebas basada en Rack. Se recomienda usar
<a href="http://rdoc.info/github/brynary/rack-test/master/frames">Rack::Test</a>:</p>

<pre><code class="ruby">require 'mi_app_sinatra'
require 'test/unit'
require 'rack/test'

class MiAppTest &lt; Test::Unit::TestCase
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_mi_defecto
    get '/'
    assert_equal 'Hola Mundo!', last_response.body
  end

  def test_con_parametros
    get '/saludar', :name =&gt; 'Franco'
    assert_equal 'Hola Frank!', last_response.body
  end

  def test_con_entorno_rack
    get '/', {}, 'HTTP_USER_AGENT' =&gt; 'Songbird'
    assert_equal "Est&aacute;s usando Songbird!", last_response.body
  end
end
</code></pre>

<a name='Sinatra::Base%20-%20Middleware,%20Librer&iacute;as,%20y%20Aplicaciones%20Modulares'></a>
<h2>Sinatra::Base - Middleware, Librer&iacute;as, y Aplicaciones Modulares</h2>

<p>Definir tu aplicaci&oacute;n en el top-level funciona bien para micro-aplicaciones
pero trae inconvenientes considerables a la hora de construir componentes
reutilizables como Rack middleware, Rails metal, simple librer&iacute;as con un
componente de servidor, o incluso extensiones de Sinatra. El DSL de top-level
asume una configuraci&oacute;n apropiada para micro-aplicaciones (por ejemplo, un
&uacute;nico archivo de aplicaci&oacute;n, los directorios <code>./public</code> y
<code>./views</code>, logging, p&aacute;gina con detalles de excepci&oacute;n, etc.). Ah&iacute; es
donde <code>Sinatra::Base</code> entra en el juego:</p>

<pre><code class="ruby">require 'sinatra/base'

class MiApp &lt; Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Hola Mundo!'
  end
end
</code></pre>

<p>Las subclases de <code>Sinatra::Base</code> tienen disponibles exactamente los
mismos m&eacute;todos que los provistos por el DSL de top-level. La mayor&iacute;a de las
aplicaciones top-level se pueden convertir en componentes
<code>Sinatra::Base</code> con dos modificaciones:</p>

<ul>
<li>Tu archivo debe requerir <code>sinatra/base</code> en lugar de <code>sinatra</code>; de otra
manera, todos los m&eacute;todos del DSL de sinatra son importados dentro del
espacio de nombres principal.</li>
<li>Pon&eacute; las rutas, manejadores de errores, filtros y opciones de tu aplicaci&oacute;n
en una subclase de <code>Sinatra::Base</code>.</li>
</ul>
<p><code>Sinatra::Base</code> es una pizarra en blanco. La mayor&iacute;a de las opciones est&aacute;n
desactivadas por defecto, incluyendo el servidor incorporado. Mir&aacute;
<a href="http://sinatra.github.com/configuration.html">Opciones y Configuraciones</a>
para detalles sobre las opciones disponibles y su comportamiento.</p>

<a name='Estilo%20Modular%20vs.%20Cl&aacute;sico'></a>
<h3>Estilo Modular vs. Cl&aacute;sico</h3>

<p>Contrariamente a la creencia popular, no hay nada de malo con el estilo cl&aacute;sico.
Si se ajusta a tu aplicaci&oacute;n, no es necesario que la cambies a una modular.</p>

<p>Las desventaja de usar el estilo cl&aacute;sico en lugar del modular consiste en que
solamente pod&eacute;s tener una aplicaci&oacute;n Sinatra por proceso Ruby. Si ten&eacute;s
planificado usar m&aacute;s, cambi&aacute; al estilo modular. Al mismo tiempo, ten&eacute; en
cuenta que no hay ninguna raz&oacute;n por la cu&aacute;l no puedas mezclar los estilos
cl&aacute;sico y modular.</p>

<p>A continuaci&oacute;n se detallan las diferencias (sutiles) entre las configuraciones
de ambos estilos:</p>

<table>
<tr>
<td>Configuraci&oacute;n</td>
    <td>Cl&aacute;sica</td>
    <td>Modular</td>
  </tr>
<tr>
<td>app_file</td>
    <td>archivo que carga sinatra</td>
    <td>archivo con la subclase de Sinatra::Base</td>
  </tr>
<tr>
<td>run</td>
    <td>$0 == app_file</td>
    <td>false</td>
  </tr>
<tr>
<td>logging</td>
    <td>true</td>
    <td>false</td>
  </tr>
<tr>
<td>method_override</td>
    <td>true</td>
    <td>false</td>
  </tr>
<tr>
<td>inline_templates</td>
    <td>true</td>
    <td>false</td>
  </tr>
<tr>
<td>static</td>
    <td>true</td>
    <td>false</td>
  </tr>
</table>
<a name='Sirviendo%20una%20Aplicaci&oacute;n%20Modular'></a>
<h3>Sirviendo una Aplicaci&oacute;n Modular</h3>

<p>Las dos opciones m&aacute;s comunes para iniciar una aplicaci&oacute;n modular son, iniciarla
activamente con <code>run!</code>:</p>

<pre><code class="ruby"># mi_app.rb
require 'sinatra/base'

class MiApp &lt; Sinatra::Base
  # ... c&oacute;digo de la app  ...

  # iniciar el servidor si el archivo fue ejecutado directamente
  run! if app_file == $0
end
</code></pre>

<p>Iniciar con:</p>

<pre><code class="shell">ruby mi_app.rb
</code></pre>

<p>O, con un archivo <code>config.ru</code>, que permite usar cualquier handler Rack:</p>

<pre><code class="ruby"># config.ru
require './mi_app'
run MiApp
</code></pre>

<p>Despu&eacute;s ejecutar:</p>

<pre><code class="shell">rackup -p 4567
</code></pre>

<a name='Usando%20una%20Aplicaci&oacute;n%20Cl&aacute;sica%20con%20un%20Archivo%20config.ru'></a>
<h3>Usando una Aplicaci&oacute;n Cl&aacute;sica con un Archivo config.ru</h3>

<p>Escrib&iacute; el archivo de tu aplicaci&oacute;n:</p>

<pre><code class="ruby"># app.rb
require 'sinatra'

get '/' do
  'Hola mundo!'
end
</code></pre>

<p>Y el <code>config.ru</code> correspondiente:</p>

<pre><code class="ruby">require './app'
run Sinatra::Application
</code></pre>

<a name='&iquest;Cu&aacute;ndo%20Usar%20config.ru?'></a>
<h3>&iquest;Cu&aacute;ndo Usar config.ru?</h3>

<p>Indicadores de que probablemente quer&eacute;s usar <code>config.ru</code>:</p>

<ul>
<li>Quer&eacute;s realizar el deploy con un hanlder Rack distinto (Passenger, Unicorn,
Heroku, ...).</li>
<li>Quer&eacute;s usar m&aacute;s de una subclase de <code>Sinatra::Base</code>.</li>
<li>Quer&eacute;s usar Sinatra &uacute;nicamente para middleware, pero no como un endpoint.</li>
</ul>
<p><b>No hay necesidad de utilizar un archivo <code>config.ru</code> exclusivamente
porque ten&eacute;s una aplicaci&oacute;n modular, y no necesit&aacute;s una aplicaci&oacute;n modular para
iniciarla con <code>config.ru</code>.</b></p>

<a name='Utilizando%20Sinatra%20como%20Middleware'></a>
<h3>Utilizando Sinatra como Middleware</h3>

<p>Sinatra no solo es capaz de usar otro Rack middleware, sino que a su vez,
cualquier aplicaci&oacute;n Sinatra puede ser agregada delante de un endpoint Rack
como middleware. Este endpoint puede ser otra aplicaci&oacute;n Sinatra, o cualquier
aplicaci&oacute;n basada en Rack (Rails/Ramaze/Camping/...):</p>

<pre><code class="ruby">require 'sinatra/base'

class PantallaDeLogin &lt; Sinatra::Base
  enable :sessions

  get('/login') { haml :login }

  post('/login') do
    if params[:nombre] == 'admin' &amp;&amp; params[:password] == 'admin'
      session['nombre_de_usuario'] = params[:nombre]
    else
      redirect '/login'
    end
  end
end

class MiApp &lt; Sinatra::Base
  # el middleware se ejecutar&aacute; antes que los filtros
  use PantallaDeLogin

  before do
    unless session['nombre_de_usuario']
      halt "Acceso denegado, por favor &lt;a href='/login'&gt;inici&aacute; sesi&oacute;n&lt;/a&gt;."
    end
  end

  get('/') { "Hola #{session['nombre_de_usuario']}." }
end
</code></pre>

<a name='Creaci&oacute;n%20Din&aacute;mica%20de%20Aplicaciones'></a>
<h3>Creaci&oacute;n Din&aacute;mica de Aplicaciones</h3>

<p>Puede que en algunas ocasiones quieras crear nuevas aplicaciones en
tiempo de ejecuci&oacute;n sin tener que asignarlas a una constante. Para
esto ten&eacute;s <code>Sinatra.new</code>:</p>

<pre><code class="ruby">require 'sinatra/base'
mi_app = Sinatra.new { get('/') { "hola" } }
mi_app.run!
</code></pre>

<p>Acepta como argumento opcional una aplicaci&oacute;n desde la que se
heredar&aacute;:</p>

<pre><code class="ruby"># config.ru
require 'sinatra/base'

controller = Sinatra.new do
  enable :logging
  helpers MisHelpers
end

map('/a') do
  run Sinatra.new(controller) { get('/') { 'a' } }
end

map('/b') do
  run Sinatra.new(controller) { get('/') { 'b' } }
end
</code></pre>

<p>Construir aplicaciones de esta forma resulta especialmente &uacute;til para
testear extensiones Sinatra o para usar Sinatra en tus librer&iacute;as.</p>

<p>Por otro lado, hace extremadamente sencillo usar Sinatra como
middleware:</p>

<pre><code class="ruby">require 'sinatra/base'

use Sinatra do
  get('/') { ... }
end

run ProyectoRails::Application
</code></pre>

<a name='&Aacute;mbitos%20y%20Ligaduras'></a>
<h2>&Aacute;mbitos y Ligaduras</h2>

<p>El &aacute;mbito en el que te encontr&aacute;s determina que m&eacute;todos y variables est&aacute;n
disponibles.</p>

<a name='&Aacute;mbito%20de%20Aplicaci&oacute;n/Clase'></a>
<h3>&Aacute;mbito de Aplicaci&oacute;n/Clase</h3>

<p>Cada aplicaci&oacute;n Sinatra es una subclase de <code>Sinatra::Base</code>. Si est&aacute;s
usando el DSL de top-level (<code>require 'sinatra'</code>), entonces esta clase es
<code>Sinatra::Application</code>, de otra manera es la subclase que creaste
expl&iacute;citamente. Al nivel de la clase ten&eacute;s m&eacute;todos como <code>get</code> o <code>before</code>, pero
no pod&eacute;s acceder a los objetos <code>request</code> o <code>session</code>, ya que hay una &uacute;nica
clase de la aplicaci&oacute;n para todas las peticiones.</p>

<p>Las opciones creadas utilizando <code>set</code> son m&eacute;todos al nivel de la clase:</p>

<pre><code class="ruby">class MiApp &lt; Sinatra::Base
  # Ey, estoy en el &aacute;mbito de la aplicaci&oacute;n!
  set :foo, 42
  foo # =&gt; 42

  get '/foo' do
    # Hey, ya no estoy en el &aacute;mbito de la aplicaci&oacute;n!
  end
end
</code></pre>

<p>Ten&eacute;s la ligadura al &aacute;mbito de la aplicaci&oacute;n dentro de:</p>

<ul>
<li>El cuerpo de la clase de tu aplicaci&oacute;n</li>
<li>M&eacute;todos definidos por extensiones</li>
<li>El bloque pasado a <code>helpers</code>
</li>
<li>Procs/bloques usados como el valor para <code>set</code>
</li>
</ul>
<p>Este &aacute;mbito puede alcanzarse de las siguientes maneras:</p>

<ul>
<li>A trav&eacute;s del objeto pasado a los bloques de configuraci&oacute;n (<code>configure { |c| ...}</code>)</li>
<li>Llamando a <code>settings</code> desde dentro del &aacute;mbito de la petici&oacute;n</li>
</ul>
<a name='&Aacute;mbito%20de%20Petici&oacute;n/Instancia'></a>
<h3>&Aacute;mbito de Petici&oacute;n/Instancia</h3>

<p>Para cada petici&oacute;n entrante, una nueva instancia de la clase de tu aplicaci&oacute;n
es creada y todos los bloques de rutas son ejecutados en ese &aacute;mbito. Desde este
&aacute;mbito pod&eacute;s acceder a los objetos <code>request</code> y <code>session</code> o llamar a los m&eacute;todos
de renderizaci&oacute;n como <code>erb</code> o <code>haml</code>. Pod&eacute;s acceder al &aacute;mbito de la aplicaci&oacute;n
desde el &aacute;mbito de la petici&oacute;n utilizando <code>settings</code>:</p>

<pre><code class="ruby">class MiApp &lt; Sinatra::Base
  # Ey, estoy en el &aacute;mbito de la aplicaci&oacute;n!
  get '/definir_ruta/:nombre' do
    # &Aacute;mbito de petici&oacute;n para '/definir_ruta/:nombre'
    @valor = 42

    settings.get("/#{params[:nombre]}") do
      # &Aacute;mbito de petici&oacute;n para "/#{params[:nombre]}"
      @valor # =&gt; nil (no es la misma petici&oacute;n)
    end

    "Ruta definida!"
  end
end
</code></pre>

<p>Ten&eacute;s la ligadura al &aacute;mbito de la petici&oacute;n dentro de:</p>

<ul>
<li>bloques pasados a get/head/post/put/delete/options</li>
<li>filtros before/after</li>
<li>m&eacute;todos ayudantes</li>
<li>plantillas/vistas</li>
</ul>
<a name='&Aacute;mbito%20de%20Delegaci&oacute;n'></a>
<h3>&Aacute;mbito de Delegaci&oacute;n</h3>

<p>El &aacute;mbito de delegaci&oacute;n solo reenv&iacute;a m&eacute;todos al &aacute;mbito de clase. De cualquier
manera, no se comporta 100% como el &aacute;mbito de clase porque no ten&eacute;s la ligadura
de la clase: &uacute;nicamente m&eacute;todos marcados expl&iacute;citamente para delegaci&oacute;n est&aacute;n
disponibles y no compart&iacute;s variables/estado con el &aacute;mbito de clase (l&eacute;ase:
ten&eacute;s un <code>self</code> diferente). Pod&eacute;s agregar delegaciones de m&eacute;todo llamando a
<code>Sinatra::Delegator.delegate :nombre_del_metodo</code>.</p>

<p>Ten&eacute;s la ligadura al &aacute;mbito de delegaci&oacute;n dentro de:</p>

<ul>
<li>La ligadura del top-level, si hiciste <code>require "sinatra"</code>
</li>
<li>Un objeto extendido con el mixin <code>Sinatra::Delegator</code>
</li>
</ul>
<p>Pegale una mirada al c&oacute;digo: ac&aacute; est&aacute; el
<a href="https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/base.rb#L1609-1633">Sinatra::Delegator mixin</a>
que <a href="https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/main.rb#L28-30">extiende el objeto main</a>.</p>

<a name='L&iacute;nea%20de%20Comandos'></a>
<h2>L&iacute;nea de Comandos</h2>

<p>Las aplicaciones Sinatra pueden ser ejecutadas directamente:</p>

<pre><code class="shell">ruby miapp.rb [-h] [-x] [-e ENTORNO] [-p PUERTO] [-o HOST] [-s MANEJADOR]
</code></pre>

<p>Las opciones son:</p>

<pre><code>-h # ayuda
-p # asigna el puerto (4567 es usado por defecto)
-o # asigna el host (0.0.0.0 es usado por defecto)
-e # asigna el entorno (development es usado por defecto)
-s # especifica el servidor/manejador rack (thin es usado por defecto)
-x # activa el mutex lock (est&aacute; desactivado por defecto)
</code></pre>

<a name='Versiones%20de%20Ruby%20Soportadas'></a>
<h2>Versiones de Ruby Soportadas</h2>

<p>Las siguientes versiones de Ruby son soportadas oficialmente:</p>

<dl>
<dt>Ruby 1.8.7</dt>
  <dd>
    1.8.7 es soportado completamente. Sin embargo, si no hay nada que te lo
    proh&iacute;ba, te recomendamos que us&eacute;s 1.9.2 o cambies a JRuby o Rubinius. No se
    dejar&aacute; de dar soporte a 1.8.7 hasta Sinatra 2.0 y Ruby 2.0, aunque si se
    libera la versi&oacute;n 1.8.8 de Ruby las cosas podr&iacute;an llegar a cambiar. Sin
    embargo, que eso ocurra es muy poco probable, e incluso el caso de que lo
    haga, puede que se siga dando soporte a 1.8.7. <b>Hemos dejado de soportar
    Ruby 1.8.6.</b> Si quer&eacute;s ejecutar Sinatra sobre 1.8.6, pod&eacute;s utilizar la
    versi&oacute;n 1.2, pero ten&eacute; en cuenta que una vez que Sinatra 1.4.0 sea liberado,
    ya no se corregir&aacute;n errores por m&aacute;s que se reciban reportes de los mismos.
  </dd>

  <dt>Ruby 1.9.2</dt>
  <dd>
    1.9.2 es soportado y recomendado. No us&eacute;s 1.9.2p0, porque se producen fallos
    de segmentaci&oacute;n cuando se ejecuta Sinatra. El soporte se mantendr&aacute; al menos
    hasta que se libere la versi&oacute;n 1.9.4/2.0 de Ruby. El soporte para la &uacute;ltima
    versi&oacute;n de la serie 1.9 se mantendr&aacute; mientras lo haga el core team de Ruby.
  </dd>

  <dt>Ruby 1.9.3</dt>
  <dd>
    1.9.3 es soportado y recomendado. Ten&eacute; en cuenta que el cambio a 1.9.3 desde
    una versi&oacute;n anterior va a invalidar todas las sesiones.
  </dd>

  <dt>Rubinius</dt>
  <dd>
    Rubinius es soportado oficialmente (Rubinius &gt;= 1.2.4). Todo funciona
    correctamente, incluyendo los lenguajes de plantillas. La pr&oacute;xima versi&oacute;n,
    2.0, tambi&eacute;n es soportada, incluyendo el modo 1.9.
  </dd>

  <dt>JRuby</dt>
  <dd>
    JRuby es soportado oficialmente (JRuby &gt;= 1.6.7). No se conocen problemas
    con librer&iacute;as de plantillas de terceras partes. Sin embargo, si eleg&iacute;s usar
    JRuby, deber&iacute;as examinar sus Rack handlers porque el servidor web Thin no es
    soportado completamente. El soporte de JRuby para extensiones C se encuentra
    en una etapa experimental, sin embargo, de momento solamente RDiscount,
    Redcarpet, RedCloth y Yajl, as&iacute; como Thin y Mongrel se ven afectadas.
  </dd>
</dl>
<p>Siempre le prestamos atenci&oacute;n a las nuevas versiones de Ruby.</p>

<p>Las siguientes implementaciones de Ruby no se encuentran soportadas
oficialmente. De cualquier manera, pueden ejecutar Sinatra:</p>

<ul>
<li>Versiones anteriores de JRuby y Rubinius</li>
<li>Ruby Enterprise Edition</li>
<li>MacRuby, Maglev e IronRuby</li>
<li>Ruby 1.9.0 y 1.9.1 (pero no te recomendamos que los us&eacute;s)</li>
</ul>
<p>No estar soportada oficialmente, significa que si las cosas solamente se rompen
ah&iacute; y no en una plataforma soportada, asumimos que no es nuestro problema sino
el suyo.</p>

<p>Nuestro servidor CI tambi&eacute;n se ejecuta sobre ruby-head (que ser&aacute; la pr&oacute;xima
versi&oacute;n 2.0.0) y la rama 1.9.4. Como est&aacute;n en movimiento constante, no podemos
garantizar nada. De todas formas, pod&eacute;s contar con que tanto 1.9.4-p0 como
2.0.0-p0 sea soportadas.</p>

<p>Sinatra deber&iacute;a funcionar en cualquier sistema operativo soportado por la
implementaci&oacute;n de Ruby elegida.</p>

<p>En este momento, no vas a poder ejecutar Sinatra en Cardinal, SmallRuby,
BlueRuby o cualquier versi&oacute;n de Ruby anterior a 1.8.7.</p>

<a name='A%20la%20Vanguardia'></a>
<h2>A la Vanguardia</h2>

<p>Si quer&eacute;s usar el c&oacute;digo de Sinatra m&aacute;s reciente, sentite libre de ejecutar
tu aplicaci&oacute;n sobre la rama master, en general es bastante estable.</p>

<p>Tambi&eacute;n liberamos prereleases de vez en cuando, as&iacute;, pod&eacute;s hacer</p>

<pre><code class="shell">gem install sinatra --pre
</code></pre>

<p>Para obtener algunas de las &uacute;ltimas caracter&iacute;sticas.</p>

<a name='Con%20Bundler'></a>
<h3>Con Bundler</h3>

<p>Esta es la manera recomendada para ejecutar tu aplicaci&oacute;n sobre la &uacute;ltima
versi&oacute;n de Sinatra usando <a href="http://gembundler.com/">Bundler</a>.</p>

<p>Primero, instal&aacute; bundler si no lo hiciste todav&iacute;a:</p>

<pre><code class="shell">gem install bundler
</code></pre>

<p>Despu&eacute;s, en el directorio de tu proyecto, cre&aacute; un archivo <code>Gemfile</code>:</p>

<pre><code class="ruby">source :rubygems
gem 'sinatra', :git =&gt; "git://github.com/sinatra/sinatra.git"

# otras dependencias
gem 'haml'                    # por ejemplo, si us&aacute;s haml
gem 'activerecord', '~&gt; 3.0'  # quiz&aacute;s tambi&eacute;n necesit&eacute;s ActiveRecord 3.x
</code></pre>

<p>Ten&eacute; en cuenta que ten&eacute;s que listar todas las dependencias directas de tu
aplicaci&oacute;n. No es necesario listar las dependencias de Sinatra (Rack y Tilt)
porque Bundler las agrega directamente.</p>

<p>Ahora pod&eacute;s arrancar tu aplicaci&oacute;n as&iacute;:</p>

<pre><code class="shell">bundle exec ruby miapp.rb
</code></pre>

<a name='Con%20Git'></a>
<h3>Con Git</h3>

<p>Clon&aacute; el repositorio localmente y ejecut&aacute; tu aplicaci&oacute;n, asegur&aacute;ndote que el
directorio <code>sinatra/lib</code> est&eacute; en el <code>$LOAD_PATH</code>:</p>

<pre><code class="shell">cd miapp
git clone git://github.com/sinatra/sinatra.git
ruby -Isinatra/lib miapp.rb
</code></pre>

<p>Para actualizar el c&oacute;digo fuente de Sinatra en el futuro:</p>

<pre><code class="shell">cd miapp/sinatra
git pull
</code></pre>

<a name='Instalaci&oacute;n%20Global'></a>
<h3>Instalaci&oacute;n Global</h3>

<p>Pod&eacute;s construir la gem vos mismo:</p>

<pre><code class="shell">git clone git://github.com/sinatra/sinatra.git
cd sinatra
rake sinatra.gemspec
rake install
</code></pre>

<p>Si instal&aacute;s tus gems como root, el &uacute;ltimo paso deber&iacute;a ser</p>

<pre><code class="shell">sudo rake install
</code></pre>

<a name='Versionado'></a>
<h2>Versionado</h2>

<p>Sinatra utiliza el <a href="http://semver.org/">Versionado Sem&aacute;ntico</a>,
siguiendo las especificaciones SemVer y SemVerTag.</p>

<a name='Lecturas%20Recomendadas'></a>
<h2>Lecturas Recomendadas</h2>

<ul>
<li>
<a href="http://www.sinatrarb.com/">Sito web del proyecto</a> - Documentaci&oacute;n
adicional, noticias, y enlaces a otros recursos.</li>
<li>
<a href="http://www.sinatrarb.com/contributing">Contribuyendo</a> - &iquest;Encontraste un
error?. &iquest;Necesit&aacute;s ayuda?. &iquest;Ten&eacute;s un parche?.</li>
<li><a href="http://github.com/sinatra/sinatra/issues">Seguimiento de problemas</a></li>
<li><a href="http://twitter.com/sinatra">Twitter</a></li>
<li><a href="http://groups.google.com/group/sinatrarb/topics">Lista de Correo</a></li>
<li>
<a href="irc://chat.freenode.net/#sinatra">IRC: #sinatra</a> en http://freenode.net</li>
<li>
<a href="http://sinatra-book.gittr.com">Sinatra Book</a> Tutorial (en ingl&eacute;s).</li>
<li>
<a href="http://recipes.sinatrarb.com/">Sinatra Recipes</a> Recetas contribuidas
por la comunidad (en ingl&eacute;s).</li>
<li>Documentaci&oacute;n de la API para la
<a href="http://rubydoc.info/gems/sinatra">&uacute;ltima versi&oacute;n liberada</a> o para la
<a href="http://rubydoc.info/github/sinatra/sinatra">rama de desarrollo actual</a>
en http://rubydoc.info/</li>
<li><a href="http://travis-ci.org/sinatra/sinatra">Servidor de CI</a></li>
</ul>
</body></html>
