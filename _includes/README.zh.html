<div class='toc'>
	<ol class='level-1'>
		<li><a href='#%E7%9B%AE%E5%BD%95'>目录</a></li>
		<li><a href='#%E8%B7%AF%E7%94%B1'>路由</a></li>
		<ol class='level-2'>
			<li><a href='#%E6%9D%A1%E4%BB%B6'>条件</a></li>
			<li><a href='#%E8%BF%94%E5%9B%9E%E5%80%BC'>返回值</a></li>
			<li><a href='#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E5%99%A8'>自定义路由匹配器</a></li>
		</ol>
		<li><a href='#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6'>静态文件</a></li>
		<li><a href='#%E8%A7%86%E5%9B%BE%20/%20%E6%A8%A1%E6%9D%BF'>视图 / 模板</a></li>
		<ol class='level-2'>
			<li><a href='#%E5%AD%97%E9%9D%A2%E9%87%8F%E6%A8%A1%E6%9D%BF'>字面量模板</a></li>
			<li><a href='#%E5%8F%AF%E9%80%89%E7%9A%84%E6%A8%A1%E6%9D%BF%E8%AF%AD%E8%A8%80'>可选的模板语言</a></li>
			<ol class='level-3'>
				<li><a href='#Haml%20%E6%A8%A1%E6%9D%BF'>Haml 模板</a></li>
				<li><a href='#Erb%20%E6%A8%A1%E6%9D%BF'>Erb 模板</a></li>
				<li><a href='#Builder%20%E6%A8%A1%E6%9D%BF'>Builder 模板</a></li>
				<li><a href='#Nokogiri%20%E6%A8%A1%E6%9D%BF'>Nokogiri 模板</a></li>
				<li><a href='#Sass%20%E6%A8%A1%E6%9D%BF'>Sass 模板</a></li>
				<li><a href='#SCSS%20%E6%A8%A1%E6%9D%BF'>SCSS 模板</a></li>
				<li><a href='#Less%20%E6%A8%A1%E6%9D%BF'>Less 模板</a></li>
				<li><a href='#Liquid%20%E6%A8%A1%E6%9D%BF'>Liquid 模板</a></li>
				<li><a href='#Markdown%20%E6%A8%A1%E6%9D%BF'>Markdown 模板</a></li>
				<li><a href='#Textile%20%E6%A8%A1%E6%9D%BF'>Textile 模板</a></li>
				<li><a href='#RDoc%20%E6%A8%A1%E6%9D%BF'>RDoc 模板</a></li>
				<li><a href='#AsciiDoc%20%E6%A8%A1%E6%9D%BF'>AsciiDoc 模板</a></li>
				<li><a href='#Radius%20%E6%A8%A1%E6%9D%BF'>Radius 模板</a></li>
				<li><a href='#Markaby%20%E6%A8%A1%E6%9D%BF'>Markaby 模板</a></li>
				<li><a href='#RABL%20%E6%A8%A1%E6%9D%BF'>RABL 模板</a></li>
				<li><a href='#Slim%20%E6%A8%A1%E6%9D%BF'>Slim 模板</a></li>
				<li><a href='#Creole%20%E6%A8%A1%E6%9D%BF'>Creole 模板</a></li>
				<li><a href='#MediaWiki%20%E6%A8%A1%E6%9D%BF'>MediaWiki 模板</a></li>
				<li><a href='#CoffeeScript%20%E6%A8%A1%E6%9D%BF'>CoffeeScript 模板</a></li>
				<li><a href='#Stylus%20%E6%A8%A1%E6%9D%BF'>Stylus 模板</a></li>
				<li><a href='#Yajl%20%E6%A8%A1%E6%9D%BF'>Yajl 模板</a></li>
				<li><a href='#WLang%20%E6%A8%A1%E6%9D%BF'>WLang 模板</a></li>
			</ol>
			<li><a href='#%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F'>在模板中访问变量</a></li>
			<li><a href='#%E5%B8%A6%20%3Ccode%3Eyield%3C/code%3E%20%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%B5%8C%E5%A5%97%E5%B8%83%E5%B1%80'>带 <code>yield</code> 的模板和嵌套布局</a></li>
			<li><a href='#%E5%86%85%E8%81%94%E6%A8%A1%E6%9D%BF'>内联模板</a></li>
			<li><a href='#%E5%85%B7%E5%90%8D%E6%A8%A1%E6%9D%BF'>具名模板</a></li>
			<li><a href='#%E5%85%B3%E8%81%94%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D'>关联文件扩展名</a></li>
			<li><a href='#%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E'>添加自定义模板引擎</a></li>
			<li><a href='#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E6%9F%A5%E6%89%BE%E9%80%BB%E8%BE%91'>自定义模板查找逻辑</a></li>
		</ol>
		<li><a href='#%E8%BF%87%E6%BB%A4%E5%99%A8'>过滤器</a></li>
		<li><a href='#%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95'>辅助方法</a></li>
		<ol class='level-2'>
			<li><a href='#%E4%BD%BF%E7%94%A8%E4%BC%9A%E8%AF%9D'>使用会话</a></li>
			<li><a href='#%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82'>中断请求</a></li>
			<li><a href='#%E4%BC%A0%E9%80%92%E8%AF%B7%E6%B1%82'>传递请求</a></li>
			<li><a href='#%E8%A7%A6%E5%8F%91%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1'>触发另一个路由</a></li>
			<li><a href='#%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E4%B8%BB%E4%BD%93%E3%80%81%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8'>设置响应主体、状态码和响应首部</a></li>
			<li><a href='#%E5%93%8D%E5%BA%94%E7%9A%84%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93'>响应的流式传输</a></li>
			<li><a href='#%E6%97%A5%E5%BF%97'>日志</a></li>
			<li><a href='#%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B'>媒体类型</a></li>
			<li><a href='#%E7%94%9F%E6%88%90%20URL'>生成 URL</a></li>
			<li><a href='#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91'>浏览器重定向</a></li>
			<li><a href='#%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6'>缓存控制</a></li>
			<li><a href='#%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6'>发送文件</a></li>
			<li><a href='#%E8%AE%BF%E9%97%AE%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1'>访问请求对象</a></li>
			<li><a href='#%E9%99%84%E4%BB%B6'>附件</a></li>
			<li><a href='#%E5%A4%84%E7%90%86%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4'>处理日期和时间</a></li>
			<li><a href='#%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6'>查找模板文件</a></li>
		</ol>
		<li><a href='#%E9%85%8D%E7%BD%AE'>配置</a></li>
		<ol class='level-2'>
			<li><a href='#%E9%85%8D%E7%BD%AE%E6%94%BB%E5%87%BB%E9%98%B2%E6%8A%A4'>配置攻击防护</a></li>
			<li><a href='#%E5%8F%AF%E9%80%89%E7%9A%84%E8%AE%BE%E7%BD%AE'>可选的设置</a></li>
		</ol>
		<li><a href='#%E7%8E%AF%E5%A2%83'>环境</a></li>
		<li><a href='#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86'>错误处理</a></li>
		<ol class='level-2'>
			<li><a href='#%E6%9C%AA%E6%89%BE%E5%88%B0'>未找到</a></li>
			<li><a href='#%E9%94%99%E8%AF%AF'>错误</a></li>
		</ol>
		<li><a href='#Rack%20%E4%B8%AD%E9%97%B4%E4%BB%B6'>Rack 中间件</a></li>
		<li><a href='#%E6%B5%8B%E8%AF%95'>测试</a></li>
		<li><a href='#Sinatra::Base%20-%20%E4%B8%AD%E9%97%B4%E4%BB%B6%E3%80%81%E5%BA%93%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BA%94%E7%94%A8'>Sinatra::Base - 中间件、库和模块化应用</a></li>
		<ol class='level-2'>
			<li><a href='#%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A3%8E%E6%A0%BC%20vs.%20%E7%BB%8F%E5%85%B8%E9%A3%8E%E6%A0%BC'>模块化风格 vs. 经典风格</a></li>
			<li><a href='#%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BA%94%E7%94%A8'>运行一个模块化应用</a></li>
			<li><a href='#%E4%BD%BF%E7%94%A8%20config.ru%20%E8%BF%90%E8%A1%8C%E7%BB%8F%E5%85%B8%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%BA%94%E7%94%A8'>使用 config.ru 运行经典风格的应用</a></li>
			<li><a href='#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%20config.ru%EF%BC%9F'>何时使用 config.ru？</a></li>
			<li><a href='#%E6%8A%8A%20Sinatra%20%E5%BD%93%E4%BD%9C%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BD%BF%E7%94%A8'>把 Sinatra 当作中间件使用</a></li>
			<li><a href='#%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E5%BA%94%E7%94%A8'>创建动态应用</a></li>
		</ol>
		<li><a href='#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%BB%91%E5%AE%9A'>作用域和绑定</a></li>
		<ol class='level-2'>
			<li><a href='#%E5%BA%94%E7%94%A8/%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F'>应用/类作用域</a></li>
			<li><a href='#%E8%AF%B7%E6%B1%82/%E5%AE%9E%E4%BE%8B%E4%BD%9C%E7%94%A8%E5%9F%9F'>请求/实例作用域</a></li>
			<li><a href='#%E4%BB%A3%E7%90%86%E4%BD%9C%E7%94%A8%E5%9F%9F'>代理作用域</a></li>
		</ol>
		<li><a href='#%E5%91%BD%E4%BB%A4%E8%A1%8C'>命令行</a></li>
		<ol class='level-2'>
			<li><a href='#%E5%A4%9A%E7%BA%BF%E7%A8%8B'>多线程</a></li>
		</ol>
		<li><a href='#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6'>必要条件</a></li>
		<li><a href='#%E7%B4%A7%E8%B7%9F%E5%89%8D%E6%B2%BF'>紧跟前沿</a></li>
		<ol class='level-2'>
			<li><a href='#%E9%80%9A%E8%BF%87%20Bundler%20%E4%BD%BF%E7%94%A8%20Sinatra'>通过 Bundler 使用 Sinatra</a></li>
			<li><a href='#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E6%9C%AC%E5%9C%B0%E7%9A%84%20Sinatra'>使用自己本地的 Sinatra</a></li>
			<li><a href='#%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85'>全局安装</a></li>
		</ol>
		<li><a href='#%E7%89%88%E6%9C%AC'>版本</a></li>
		<li><a href='#%E6%9B%B4%E5%A4%9A%E8%B5%84%E6%96%99'>更多资料</a></li>
	</ol>
</div>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>

<p><em>注：本文档是英文版的翻译，内容更新有可能不及时。如有不一致的地方，请以英文版为准。</em></p>

<p>Sinatra 是一门基于
Ruby 的<a href="https://en.wikipedia.org/wiki/Domain-specific_language">领域专属语言</a>，致力于轻松、快速地创建网络应用：</p>

<pre><code class="language-ruby"># myapp.rb
require 'sinatra'

get '/' do
  'Hello world!'
end
</code></pre>

<p>安装 Sinatra 这个 gem：</p>

<pre><code class="language-shell">gem install sinatra
</code></pre>

<p>然后运行 myapp.rb 中的代码：</p>

<pre><code class="language-shell">ruby myapp.rb
</code></pre>

<p>在该地址查看： <a href="http://localhost:4567">http://localhost:4567</a></p>

<p>推荐运行 <code>gem install thin</code> 安装 Thin。这样，Sinatra 会优先选择 Thin 作为服务器。</p>

<a name='%E7%9B%AE%E5%BD%95'></a>
<h2>目录</h2>



<a name='%E8%B7%AF%E7%94%B1'></a>
<h2>路由</h2>

<p>在 Sinatra 中，一个路由分为两部分：HTTP 方法和 URL 匹配范式。每个路由都有一个要执行的代码块：</p>

<pre><code class="language-ruby">get '/' do
  .. 显示内容 ..
end

post '/' do
  .. 创建内容 ..
end

put '/' do
  .. 替换内容 ..
end

patch '/' do
  .. 修改内容 ..
end

delete '/' do
  .. 删除内容 ..
end

options '/' do
  .. 显示命令列表 ..
end

link '/' do
  .. 建立某种联系 ..
end

unlink '/' do
  .. 解除某种联系 ..
end
</code></pre>

<p>路由按照它们定义时的顺序进行匹配。第一个与请求匹配的路由会被调用。</p>

<p>路由范式可以包括具名参数，具名参数可以通过 <code>params</code> hash 访问：</p>

<pre><code class="language-ruby">get '/hello/:name' do
  # 匹配 "GET /hello/foo" 和 "GET /hello/bar"
  # params['name'] 的值是 'foo' 或者 'bar'
  "Hello #{params['name']}!"
end
</code></pre>

<p>也可以通过代码块参数访问具名参数：</p>

<pre><code class="language-ruby">get '/hello/:name' do |n|
  # 匹配 "GET /hello/foo" 和 "GET /hello/bar"
  # params['name'] 的值是 'foo' 或者 'bar'
  # n 存储 params['name'] 的值
  "Hello #{n}!"
end
</code></pre>

<p>路由范式也可以包含通配符参数， 参数值可以通过 <code>params['splat']</code> 数组访问。</p>

<pre><code class="language-ruby">get '/say/*/to/*' do
  # 匹配 "GET /say/hello/to/world"
  params['splat'] # =&gt; ["hello", "world"]
end

get '/download/*.*' do
  # 匹配 "GET /download/path/to/file.xml"
  params['splat'] # =&gt; ["path/to/file", "xml"]
end
</code></pre>

<p>或者通过代码块参数访问：</p>

<pre><code class="language-ruby">get '/download/*.*' do |path, ext|
  [path, ext] # =&gt; ["path/to/file", "xml"]
end
</code></pre>

<p>通过正则表达式匹配路由：</p>

<pre><code class="language-ruby">get /\/hello\/([\w]+)/ do
  "Hello, #{params['captures'].first}!"
end
</code></pre>

<p>或者使用代码块参数：</p>

<pre><code class="language-ruby">get %r{/hello/([\w]+)} do |c|
  # 匹配 "GET /meta/hello/world"、"GET /hello/world/1234" 等
  "Hello, #{c}!"
end
</code></pre>

<p>路由范式可以包含可选参数：</p>

<pre><code class="language-ruby">get '/posts/:format?' do
  # 匹配 "GET /posts/" 和任意扩展 "GET /posts/json"、"GET /posts/xml" 等
end
</code></pre>

<p>路由也可以使用查询参数：</p>

<pre><code class="language-ruby">get '/posts' do
  # 匹配 "GET /posts?title=foo&amp;author=bar"
  title = params['title']
  author = params['author']
  # 使用 title 和 author 变量；对于 /posts 路由来说，查询字符串是可选的
end
</code></pre>
<p>顺便一提，除非你禁用了路径遍历攻击防护（见下文），请求路径可能在匹配路由前发生改变。</p>

<a name='%E6%9D%A1%E4%BB%B6'></a>
<h3>条件</h3>

<p>路由可以包含各种匹配条件，比如 user agent：</p>

<pre><code class="language-ruby">get '/foo', :agent =&gt; /Songbird (\d\.\d)[\d\/]*?/ do
  "你正在使用 Songbird，版本是 #{params['agent'][0]}"
end

get '/foo' do
  # 匹配非 Songbird 浏览器
end
</code></pre>

<p>其它可以使用的条件有 <code>host_name</code> 和 <code>provides</code>：</p>

<pre><code class="language-ruby">get '/', :host_name =&gt; /^admin\./ do
  "管理员区域，无权进入！"
end

get '/', :provides =&gt; 'html' do
  haml :index
end

get '/', :provides =&gt; ['rss', 'atom', 'xml'] do
  builder :feed
end
</code></pre>

<p><code>provides</code> 会搜索请求的 Accept 首部字段。</p>

<p>也可以轻易地使用自定义条件：</p>

<pre><code class="language-ruby">set(:probability) { |value| condition { rand &lt;= value } }

get '/win_a_car', :probability =&gt; 0.1 do
  "You won!"
end

get '/win_a_car' do
  "Sorry, you lost."
end
</code></pre>

<p>对于一个需要提供多个值的条件，可以使用 splat：</p>

<pre><code class="language-ruby">set(:auth) do |*roles|   # &lt;- 注意此处使用了 splat
  condition do
    unless logged_in? &amp;&amp; roles.any? {|role| current_user.in_role? role }
      redirect "/login/", 303
    end
  end
end

get "/my/account/", :auth =&gt; [:user, :admin] do
  "Your Account Details"
end

get "/only/admin/", :auth =&gt; :admin do
  "Only admins are allowed here!"
end
</code></pre>

<a name='%E8%BF%94%E5%9B%9E%E5%80%BC'></a>
<h3>返回值</h3>

<p>路由代码块的返回值至少决定了返回给
HTTP 客户端的响应主体，或者至少决定了在
Rack 堆栈中的下一个中间件。大多数情况下，返回值是一个字符串，就像上面的例子中的一样。但是，其它类型的值也是可以接受的。</p>

<p>你可以返回任何对象，该对象要么是一个合理的 Rack 响应，要么是一个 Rack body 对象，要么是 HTTP 状态码：</p>

<ul>
  <li>一个包含三个元素的数组: <code>[状态 (Fixnum), 响应首部 (Hash), 响应主体 (可以响应 #each 方法)]</code>
</li>
  <li>一个包含两个元素的数组: <code>[状态 (Fixnum), 响应主体 (可以响应 #each 方法)]</code>
</li>
  <li>一个响应 <code>#each</code> 方法，只传回字符串的对象</li>
  <li>一个代表状态码的数字</li>
</ul>

<p>例如，我们可以轻松地实现流式传输：</p>

<pre><code class="language-ruby">class Stream
  def each
    100.times { |i| yield "#{i}\n" }
  end
end

get('/') { Stream.new }
</code></pre>

<p>也可以使用 <code>stream</code> 辅助方法（见下文描述）以减少样板代码并在路由中直接使用流式传输。</p>

<a name='%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E5%99%A8'></a>
<h3>自定义路由匹配器</h3>

<p>如上文所示，Sinatra
本身支持使用字符串和正则表达式作为路由匹配。但不限于此，你可以轻松地定义自己的匹配器：</p>

<pre><code class="language-ruby">class AllButPattern
  Match = Struct.new(:captures)

  def initialize(except)
    @except   = except
    @captures = Match.new([])
  end

  def match(str)
    @captures unless @except === str
  end
end

def all_but(pattern)
  AllButPattern.new(pattern)
end

get all_but("/index") do
  # ...
end
</code></pre>

<p>上面的例子可能太繁琐了， 因为它也可以用更简单的方式表述：</p>

<pre><code class="language-ruby">get // do
  pass if request.path_info == "/index"
  # ...
end
</code></pre>

<p>或者，使用消极向前查找:</p>

<pre><code class="language-ruby">get %r{(?!/index)} do
  # ...
end
</code></pre>

<a name='%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6'></a>
<h2>静态文件</h2>

<p>静态文件从 <code>./public</code> 目录提供服务。可以通过设置<code>:public_folder</code> 选项设定一个不同的位置：</p>

<pre><code class="language-ruby">set :public_folder, File.dirname(__FILE__) + '/static'
</code></pre>

<p>请注意 public 目录名并没有包含在 URL 中。文件 <code>./public/css/style.css</code> 可以通过
<code>http://example.com/css/style.css</code> 访问。</p>

<p>可以使用 <code>:static_cache_control</code> 设置（见下文）添加 <code>Cache-Control</code> 首部信息。</p>

<a name='%E8%A7%86%E5%9B%BE%20/%20%E6%A8%A1%E6%9D%BF'></a>
<h2>视图 / 模板</h2>

<p>每一门模板语言都将自身的渲染方法暴露给
Sinatra 调用。这些渲染方法只是简单地返回字符串。</p>

<pre><code class="language-ruby">get '/' do
  erb :index
end
</code></pre>

<p>这段代码会渲染 <code>views/index.erb</code> 文件。</p>

<p>除了模板文件名，也可以直接传入模板内容：</p>

<pre><code class="language-ruby">get '/' do
  code = "&lt;%= Time.now %&gt;"
  erb code
end
</code></pre>

<p>渲染方法接受第二个参数，即选项 hash：</p>

<pre><code class="language-ruby">get '/' do
  erb :index, :layout =&gt; :post
end
</code></pre>

<p>这段代码会将 <code>views/index.erb</code> 嵌入在 <code>views/post.erb</code>
布局中并一起渲染（<code>views/layout.erb</code> 是默认的布局，如果它存在的话）。</p>

<p>任何 Sinatra 不能理解的选项都会传递给模板引擎。</p>

<pre><code class="language-ruby">get '/' do
  haml :index, :format =&gt; :html5
end
</code></pre>

<p>也可以为每种模板语言设置通用的选项：</p>

<pre><code class="language-ruby">set :haml, :format =&gt; :html5

get '/' do
  haml :index
end
</code></pre>

<p>在渲染方法中传入的选项会覆盖通过 <code>set</code> 设置的通用选项。</p>

<p>可用的选项：</p>

<dl>
  <dt>locals</dt>
  <dd>
    传递给模板文档的 locals 对象列表。对于 partials
    很方便。例如：<tt>erb "&lt;%= foo %&gt;", :locals =&gt; {:foo =&gt; "bar"}</tt>
  </dd>

  <dt>default_encoding</dt>
  <dd>默认的字符编码。默认值为 <tt>settings.default_encoding</tt>。</dd>

  <dt>views</dt>
  <dd>存放模板文件的目录。默认为 <tt>settings.views</tt>。</dd>

  <dt>layout</dt>
  <dd>
    是否使用布局 (<tt>true</tt> 或 <tt>false</tt>)。
    如果使用一个符号类型的值，则是用于明确使用的模板。例如：
    <tt>erb :index, :layout =&gt; !request.xhr?</tt>
  </dd>

  <dt>content_type</dt>
  <dd>由模板生成的 Content-Type。默认值由模板语言决定。</dd>

  <dt>scope</dt>
  <dd>
    渲染模板时的作用域。默认值为应用类的实例对象。如果更改此项，实例变量和辅助方法将不可用。
  </dd>

  <dt>layout_engine</dt>
  <dd>
    渲染布局所使用的模板引擎。用于不支持布局的模板语言。默认值为模板所使用的引擎。例如：
    <tt>set :rdoc, :layout_engine =&gt; :erb</tt>
  </dd>

  <dt>layout_options</dt>
  <dd>
    渲染布局的特殊选项。例如：
    <tt>set :rdoc, :layout_options =&gt; { :views =&gt; 'views/layouts' }</tt>
  </dd>
</dl>

<p>Sinatra 假定模板文件直接位于 <code>./views</code> 目录。要使用不同的视图目录：</p>

<pre><code class="language-ruby">set :views, settings.root + '/templates'
</code></pre>

<p>需要牢记的一点是，你必须通过符号引用模板， 即使它们存放在子目录下
（在这种情况下，使用 <code>:'subdir/template'</code> 或 <code>'subdir/template'.to_sym</code>）。
如果你不使用符号，渲染方法会直接渲染你传入的任何字符串。</p>

<a name='%E5%AD%97%E9%9D%A2%E9%87%8F%E6%A8%A1%E6%9D%BF'></a>
<h3>字面量模板</h3>

<pre><code class="language-ruby">get '/' do
  haml '%div.title Hello World'
end
</code></pre>

<p>这段代码直接渲染模板字符串。</p>

<a name='%E5%8F%AF%E9%80%89%E7%9A%84%E6%A8%A1%E6%9D%BF%E8%AF%AD%E8%A8%80'></a>
<h3>可选的模板语言</h3>

<p>一些语言有多种实现。为了确定使用哪种实现（以及保证线程安全），你应该首先引入该实现：</p>

<pre><code class="language-ruby">require 'rdiscount' # 或 require 'bluecloth'
get('/') { markdown :index }
</code></pre>

<a name='Haml%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Haml 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://haml.info/" title="haml">haml</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.haml</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>haml :index, :format =&gt; :html5</tt></td>
  </tr>
</table>

<a name='Erb%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Erb 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td>
      <a href="http://www.kuwata-lab.com/erubis/" title="erubis">erubis</a>
      或 erb (Ruby 标准库中已经包含)
    </td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td>
<tt>.erb</tt>, <tt>.rhtml</tt> or <tt>.erubis</tt> (仅用于 Erubis)</td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>

<a name='Builder%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Builder 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td>
      <a href="https://github.com/jimweirich/builder" title="builder">builder</a>
    </td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.builder</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>builder { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

<p><code>builder</code> 渲染方法也接受一个代码块，用于内联模板（见例子）。</p>

<a name='Nokogiri%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Nokogiri 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://www.nokogiri.org/" title="nokogiri">nokogiri</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>nokogiri { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

<p><code>nokogiri</code> 渲染方法也接受一个代码块，用于内联模板（见例子）。</p>

<a name='Sass%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Sass 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.sass</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>sass :stylesheet, :style =&gt; :expanded</tt></td>
  </tr>
</table>

<a name='SCSS%20%E6%A8%A1%E6%9D%BF'></a>
<h4>SCSS 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.scss</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>scss :stylesheet, :style =&gt; :expanded</tt></td>
  </tr>
</table>

<a name='Less%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Less 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://lesscss.org/" title="less">less</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.less</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>less :stylesheet</tt></td>
  </tr>
</table>

<a name='Liquid%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Liquid 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://liquidmarkup.org/" title="liquid">liquid</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.liquid</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>liquid :index, :locals =&gt; { :key =&gt; 'value' }</tt></td>
  </tr>
</table>

<p>因为不能在 Liquid 模板中调用 Ruby 方法（除了 <code>yield</code>），你几乎总是需要传递 locals 对象给它。</p>

<a name='Markdown%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Markdown 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td>
      下列任一:
        <a href="https://github.com/davidfstr/rdiscount" title="RDiscount">RDiscount</a>,
        <a href="https://github.com/vmg/redcarpet" title="RedCarpet">RedCarpet</a>,
        <a href="http://deveiate.org/projects/BlueCloth" title="BlueCloth">BlueCloth</a>,
        <a href="http://kramdown.gettalong.org/" title="kramdown">kramdown</a>,
        <a href="https://github.com/bhollis/maruku" title="maruku">maruku</a>
    </td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td>
<tt>.markdown</tt>, <tt>.mkd</tt> and <tt>.md</tt>
</td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>markdown :index, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>不能在 markdown 中调用 Ruby 方法，也不能传递 locals 给它。
因此，你一般会结合其它的渲染引擎来使用它：</p>

<pre><code class="language-ruby">erb :overview, :locals =&gt; { :text =&gt; markdown(:introduction) }
</code></pre>

<p>请注意你也可以在其它模板中调用 markdown 方法：</p>

<pre><code class="language-ruby">%h1 Hello From Haml!
%p= markdown(:greetings)
</code></pre>

<p>因为不能在 Markdown 中使用 Ruby 语言，你不能使用 Markdown 书写的布局。
不过，使用其它渲染引擎作为模板的布局是可能的，这需要通过传入 <code>:layout_engine</code> 选项。</p>

<a name='Textile%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Textile 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://redcloth.org/" title="RedCloth">RedCloth</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.textile</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>textile :index, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>不能在 textile 中调用 Ruby 方法，也不能传递 locals 给它。
因此，你一般会结合其它的渲染引擎来使用它：</p>

<pre><code class="language-ruby">erb :overview, :locals =&gt; { :text =&gt; textile(:introduction) }
</code></pre>

<p>请注意你也可以在其他模板中调用 <code>textile</code> 方法：</p>

<pre><code class="language-ruby">%h1 Hello From Haml!
%p= textile(:greetings)
</code></pre>

<p>因为不能在 Textile 中调用 Ruby 方法，你不能用 Textile 书写布局。
不过，使用其它渲染引擎作为模版的布局是可能的，这需要通过传递 <code>:layout_engine</code> 选项。</p>

<a name='RDoc%20%E6%A8%A1%E6%9D%BF'></a>
<h4>RDoc 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://rdoc.sourceforge.net/" title="RDoc">RDoc</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.rdoc</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>rdoc :README, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>不能在 rdoc 中调用 Ruby 方法，也不能传递 locals 给它。
因此，你一般会结合其它的渲染引擎来使用它：</p>

<pre><code class="language-ruby">erb :overview, :locals =&gt; { :text =&gt; rdoc(:introduction) }
</code></pre>

<p>请注意你也可以在其他模板中调用 <code>rdoc</code> 方法：</p>

<pre><code class="language-ruby">%h1 Hello From Haml!
%p= rdoc(:greetings)
</code></pre>

<p>因为不能在 RDoc 中调用 Ruby 方法，你不能用 RDoc 书写布局。
不过，使用其它渲染引擎作为模版的布局是可能的，这需要通过传递 <code>:layout_engine</code> 选项。</p>

<a name='AsciiDoc%20%E6%A8%A1%E6%9D%BF'></a>
<h4>AsciiDoc 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://asciidoctor.org/" title="Asciidoctor">Asciidoctor</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td>
<tt>.asciidoc</tt>, <tt>.adoc</tt> and <tt>.ad</tt>
</td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>asciidoc :README, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>因为不能在 AsciiDoc 模板中直接调用 Ruby 方法，你几乎总是需要传递 locals 对象给它。</p>

<a name='Radius%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Radius 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="https://github.com/jlong/radius" title="Radius">Radius</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.radius</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>radius :index, :locals =&gt; { :key =&gt; 'value' }</tt></td>
  </tr>
</table>

<p>因为不能在 Radius 模板中直接调用 Ruby 方法，你几乎总是可以传递 locals 对象给它。</p>

<a name='Markaby%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Markaby 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://markaby.github.io/" title="Markaby">Markaby</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.mab</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>markaby { h1 "Welcome!" }</tt></td>
  </tr>
</table>

<p><code>markaby</code> 渲染方法也接受一个代码块，用于内联模板（见例子）。</p>

<a name='RABL%20%E6%A8%A1%E6%9D%BF'></a>
<h4>RABL 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="https://github.com/nesquena/rabl" title="Rabl">Rabl</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.rabl</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>

<a name='Slim%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Slim 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://slim-lang.com/" title="Slim Lang">Slim Lang</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.slim</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>

<a name='Creole%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Creole 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="https://github.com/minad/creole" title="Creole">Creole</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.creole</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>creole :wiki, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>不能在 creole 中调用 Ruby 方法，也不能传递 locals 对象给它。
因此你一般会结合其它的渲染引擎来使用它：</p>

<pre><code class="language-ruby">erb :overview, :locals =&gt; { :text =&gt; creole(:introduction) }
</code></pre>

<p>注意你也可以在其它模板内调用 <code>creole</code> 方法：</p>

<pre><code class="language-ruby">%h1 Hello From Haml!
%p= creole(:greetings)
</code></pre>

<p>因为不能在 Creole 模板文件内调用 Ruby 方法，你不能用 Creole 书写布局文件。
然而，使用其它渲染引擎作为模版的布局是可能的，这需要通过传递 <code>:layout_engine</code> 选项。</p>

<a name='MediaWiki%20%E6%A8%A1%E6%9D%BF'></a>
<h4>MediaWiki 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="https://github.com/nricciar/wikicloth" title="WikiCloth">WikiCloth</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td>
<tt>.mediawiki</tt> and <tt>.mw</tt>
</td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>mediawiki :wiki, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>在 MediaWiki 标记文件内不能调用 Ruby 方法，也不能传递 locals 对象给它。
因此你一般会结合其它的渲染引擎来使用它：</p>

<pre><code class="language-ruby">erb :overview, :locals =&gt; { :text =&gt; mediawiki(:introduction) }
</code></pre>

<p>注意你也可以在其它模板内调用 <code>mediawiki</code> 方法：</p>

<pre><code class="language-ruby">%h1 Hello From Haml!
%p= mediawiki(:greetings)
</code></pre>

<p>因为不能在 MediaWiki 文件内调用 Ruby 方法，你不能用 MediaWiki 书写布局文件。
然而，使用其它渲染引擎作为模版的布局是可能的，这需要通过传递 <code>:layout_engine</code> 选项。</p>

<a name='CoffeeScript%20%E6%A8%A1%E6%9D%BF'></a>
<h4>CoffeeScript 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td>
      <a href="https://github.com/josh/ruby-coffee-script" title="Ruby CoffeeScript">
        CoffeeScript
      </a> 以及一种
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        执行 JavaScript 的方式
      </a>
    </td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.coffee</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>

<a name='Stylus%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Stylus 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td>
      <a href="https://github.com/forgecrafted/ruby-stylus" title="Ruby Stylus">
        Stylus
      </a> 以及一种
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        执行 JavaScript 的方式
      </a>
    </td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.styl</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>stylus :index</tt></td>
  </tr>
</table>

<p>在使用 Stylus 模板之前，你需要先加载 <code>stylus</code> 和 <code>stylus/tilt</code>：</p>

<pre><code class="language-ruby">require 'sinatra'
require 'stylus'
require 'stylus/tilt'

get '/' do
  stylus :example
end
</code></pre>

<a name='Yajl%20%E6%A8%A1%E6%9D%BF'></a>
<h4>Yajl 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="https://github.com/brianmario/yajl-ruby" title="yajl-ruby">yajl-ruby</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.yajl</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td>
      <tt>
        yajl :index,
             :locals =&gt; { :key =&gt; 'qux' },
             :callback =&gt; 'present',
             :variable =&gt; 'resource'
      </tt>
    </td>
  </tr>
</table>

<p>模板文件的源码作为一个 Ruby 字符串被求值，得到的 json 变量是通过 <code>#to_json</code> 方法转换的：</p>

<pre><code class="language-ruby">json = { :foo =&gt; 'bar' }
json[:baz] = key
</code></pre>

<p>可以使用 <code>:callback</code> 和 <code>:variable</code> 选项装饰被渲染的对象：</p>

<pre><code class="language-javascript">var resource = {"foo":"bar","baz":"qux"};
present(resource);
</code></pre>

<a name='WLang%20%E6%A8%A1%E6%9D%BF'></a>
<h4>WLang 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="https://github.com/blambeau/wlang/" title="WLang">WLang</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.wlang</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>wlang :index, :locals =&gt; { :key =&gt; 'value' }</tt></td>
  </tr>
</table>

<p>因为在 WLang 中调用 Ruby 方法不符合语言习惯，你几乎总是需要传递 locals 给 WLang 木板。
然而，可以用 WLang 编写布局文件，也可以在 WLang 中使用 <code>yield</code> 方法。</p>

<a name='%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F'></a>
<h3>在模板中访问变量</h3>

<p>模板的求值发生在路由处理器内部的上下文中。模板可以直接访问路由处理器中设置的实例变量。</p>

<pre><code class="language-ruby">get '/:id' do
  @foo = Foo.find(params['id'])
  haml '%h1= @foo.name'
end
</code></pre>

<p>或者，也可以显式地指定一个由局部变量组成的 locals 哈希：</p>

<pre><code class="language-ruby">get '/:id' do
  foo = Foo.find(params['id'])
  haml '%h1= foo.name', :locals =&gt; { :foo =&gt; foo }
end
</code></pre>

<p>locals 哈希典型的使用情景是在别的模板中渲染 partials。</p>

<a name='%E5%B8%A6%20%3Ccode%3Eyield%3C/code%3E%20%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%B5%8C%E5%A5%97%E5%B8%83%E5%B1%80'></a>
<h3>带 <code>yield</code> 的模板和嵌套布局</h3>

<p>布局通常就是使用了 <code>yield</code> 方法的模板。
这样的布局文件可以通过上面描述的 <code>:template</code> 选项指定，也可以通过下面的代码块渲染：</p>

<pre><code class="language-ruby">erb :post, :layout =&gt; false do
  erb :index
end
</code></pre>

<p>这段代码几乎完全等同于 <code>erb :index, :layout =&gt; :post</code>。</p>

<p>向渲染方法传递代码块对于创建嵌套布局是最有用的：</p>

<pre><code class="language-ruby">erb :main_layout, :layout =&gt; false do
  erb :admin_layout do
    erb :user
  end
end
</code></pre>

<p>代码行数可以更少：</p>

<pre><code class="language-ruby">erb :admin_layout, :layout =&gt; :main_layout do
  erb :user
end
</code></pre>

<p>当前，以下的渲染方法接受一个代码块：<code>erb</code>、<code>haml</code>、<code>liquid</code>、<code>slim </code> 和 <code>wlang</code>。
通用的 <code>render</code> 方法也接受。</p>

<a name='%E5%86%85%E8%81%94%E6%A8%A1%E6%9D%BF'></a>
<h3>内联模板</h3>

<p>模板可以在源文件的末尾定义：</p>

<pre><code class="language-ruby">require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Hello world.
</code></pre>

<p>注意：在引入了 sinatra 的源文件中定义的内联模板会自动载入。
如果你在其他源文件中也有内联模板，需要显式调用 <code>enable :inline_templates</code>。</p>

<a name='%E5%85%B7%E5%90%8D%E6%A8%A1%E6%9D%BF'></a>
<h3>具名模板</h3>

<p>可以使用顶层 <code>template</code> 方法定义模板：</p>

<pre><code class="language-ruby">template :layout do
  "%html\n  =yield\n"
end

template :index do
  '%div.title Hello World!'
end

get '/' do
  haml :index
end
</code></pre>

<p>如果存在名为 “layout” 的模板，该模板会在每个模板渲染的时候作为布局使用。
你可以为渲染方法传送 <code>:layout =&gt; false</code> 来禁用该次渲染的布局，
也可以设置 <code>set :haml, :layout =&gt; false</code> 来默认禁用布局。</p>

<pre><code class="language-ruby">get '/' do
  haml :index, :layout =&gt; !request.xhr?
end
</code></pre>

<a name='%E5%85%B3%E8%81%94%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D'></a>
<h3>关联文件扩展名</h3>

<p>为了将一个文件扩展名到对应的模版引擎，要使用 <code>Tilt.register</code>。
比如，如果你喜欢使用 <code>tt</code> 作为 Textile 模版的扩展名，你可以这样做:</p>

<pre><code class="language-ruby">Tilt.register :tt, Tilt[:textile]
</code></pre>

<a name='%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E'></a>
<h3>添加自定义模板引擎</h3>

<p>首先，通过 Tilt 注册你自定义的引擎，然后创建一个渲染方法：</p>

<pre><code class="language-ruby">Tilt.register :myat, MyAwesomeTemplateEngine

helpers do
  def myat(*args) render(:myat, *args) end
end

get '/' do
  myat :index
end
</code></pre>

<p>这段代码将会渲染 <code>./views/index.myat</code> 文件。
查看 https://github.com/rtomayko/tilt 以了解更多关于 Tilt 的信息。</p>

<a name='%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E6%9F%A5%E6%89%BE%E9%80%BB%E8%BE%91'></a>
<h3>自定义模板查找逻辑</h3>

<p>要实现自定义的模板查找机制，你可以构建自己的 <code>#find_template</code> 方法：</p>

<pre><code class="language-ruby">configure do
  set :views, [ './views/a', './views/b' ]
end

def find_template(views, name, engine, &amp;block)
  Array(views).each do |v|
    super(v, name, engine, &amp;block)
  end
end
</code></pre>

<a name='%E8%BF%87%E6%BB%A4%E5%99%A8'></a>
<h2>过滤器</h2>

<p><code>before</code> 过滤器在每个请求之前调用，调用的上下文与请求的上下文相同，并且可以修改请求和响应。
在过滤器中设置的变量可以被路由和模板访问：</p>

<pre><code class="language-ruby">before do
  @note = 'Hi!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @note #=&gt; 'Hi!'
  params['splat'] #=&gt; 'bar/baz'
end
</code></pre>

<p><code>after</code> 过滤器在每个请求之后调用，调用上下文与请求的上下文相同，并且也会修改请求和响应。
在 <code>before</code> 过滤器和路由中设置的实例变量可以被 <code>after</code> 过滤器访问：</p>

<pre><code class="language-ruby">after do
  puts response.status
end
</code></pre>

<p>请注意：除非你显式使用 <code>body</code> 方法，而不是在路由中直接返回字符串，
响应主体在 <code>after</code> 过滤器是不可访问的， 因为它在之后才会生成。</p>

<p>过滤器可以可选地带有范式， 只有请求路径满足该范式时才会执行：</p>

<pre><code class="language-ruby">before '/protected/*' do
  authenticate!
end

after '/create/:slug' do |slug|
  session['last_slug'] = slug
end
</code></pre>

<p>和路由一样，过滤器也可以带有条件：</p>

<pre><code class="language-ruby">before :agent =&gt; /Songbird/ do
  # ...
end

after '/blog/*', :host_name =&gt; 'example.com' do
  # ...
end
</code></pre>

<a name='%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95'></a>
<h2>辅助方法</h2>

<p>使用顶层的 <code>helpers</code> 方法来定义辅助方法， 以便在路由处理器和模板中使用：</p>

<pre><code class="language-ruby">helpers do
  def bar(name)
    "#{name}bar"
  end
end

get '/:name' do
  bar(params['name'])
end
</code></pre>

<p>也可以在多个分散的模块中定义辅助方法：</p>

<pre><code class="language-ruby">module FooUtils
  def foo(name) "#{name}foo" end
end

module BarUtils
  def bar(name) "#{name}bar" end
end

helpers FooUtils, BarUtils
</code></pre>

<p>以上代码块与在应用类中包含模块等效。</p>

<a name='%E4%BD%BF%E7%94%A8%E4%BC%9A%E8%AF%9D'></a>
<h3>使用会话</h3>

<p>会话用于在请求之间保持状态。如果激活了会话，每一个用户会话都对应一个会话 hash：</p>

<pre><code class="language-ruby">enable :sessions

get '/' do
  "value = " &lt;&lt; session['value'].inspect
end

get '/:value' do
  session['value'] = params['value']
end
</code></pre>

<p>请注意 <code>enable :sessions</code> 实际将所有的数据保存在一个 cookie 中。
这可能并不总是你想要的（cookie 中存储大量的数据会增加你的流量）。
你可以使用任何 Rack session 中间件：要达到此目的，<strong>不要</strong>使用 <code>enable :sessions</code>，
而是按照自己的需要引入想使用的中间件：</p>

<pre><code class="language-ruby">use Rack::Session::Pool, :expire_after =&gt; 2592000

get '/' do
  "value = " &lt;&lt; session['value'].inspect
end

get '/:value' do
  session['value'] = params['value']
end
</code></pre>

<p>为提高安全性，cookie 中的会话数据会被一个会话密码保护。Sinatra 会为你生成一个随机的密码。
然而，每次启动应用时，该密码都会变化，你也可以自己设置该密码，以便所有的应用实例共享：</p>

<pre><code>set :session_secret, 'super secret'
</code></pre>

<p>如果你想进一步配置会话，可以在设置 <code>sessions</code> 时提供一个选项 hash 作为第二个参数：</p>

<pre><code>set :sessions, :domain =&gt; 'foo.com'
</code></pre>

<p>为了在 foo.com 的子域名间共享会话数据，可以在域名前添加一个 <em>.</em>：</p>

<pre><code class="language-ruby">set :sessions, :domain =&gt; '.foo.com'
</code></pre>

<a name='%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82'></a>
<h3>中断请求</h3>

<p>要想在过滤器或路由中立即中断一个请求：</p>

<pre><code class="language-ruby">halt
</code></pre>

<p>你也可以指定中断时的状态码：</p>

<pre><code class="language-ruby">halt 410
</code></pre>

<p>或者响应主体：</p>

<pre><code class="language-ruby">halt 'this will be the body'
</code></pre>

<p>或者同时指定两者：</p>

<pre><code class="language-ruby">halt 401, 'go away!'
</code></pre>

<p>也可以指定响应首部：</p>

<pre><code class="language-ruby">halt 402, {'Content-Type' =&gt; 'text/plain'}, 'revenge'
</code></pre>

<p>当然也可以使用模板：</p>

<pre><code>halt erb(:error)
</code></pre>

<a name='%E4%BC%A0%E9%80%92%E8%AF%B7%E6%B1%82'></a>
<h3>传递请求</h3>

<p>一个路由可以放弃对请求的处理并将处理让给下一个匹配的路由，这要通过 <code>pass</code> 实现：</p>

<pre><code class="language-ruby">get '/guess/:who' do
  pass unless params['who'] == 'Frank'
  'You got me!'
end

get '/guess/*' do
  'You missed!'
end
</code></pre>

<p>执行 <code>pass</code> 后，控制流从该路由代码块直接退出，并继续前进到下一个匹配的路由。
如果没有匹配的路由，将返回 404。</p>

<a name='%E8%A7%A6%E5%8F%91%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1'></a>
<h3>触发另一个路由</h3>

<p>有些时候，<code>pass</code> 并不是你想要的，你希望得到的是调用另一个路由的结果。
使用 <code>call</code> 就可以做到这一点:</p>

<pre><code class="language-ruby">get '/foo' do
  status, headers, body = call env.merge("PATH_INFO" =&gt; '/bar')
  [status, headers, body.map(&amp;:upcase)]
end

get '/bar' do
  "bar"
end
</code></pre>

<p>请注意在以上例子中，你只需简单地移动 <code>"bar"</code> 到一个被 <code>/foo</code> 和 <code>/bar</code> 同时使用的辅助方法中，
就可以简化测试和增加性能。</p>

<p>如果你希望请求发送到同一个应用，而不是应用副本，应使用 <code>call!</code> 而不是 <code>call</code>。</p>

<p>如果想更多了解关于 <code>call</code> 的信息，请查看 Rack 规范。</p>

<a name='%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E4%B8%BB%E4%BD%93%E3%80%81%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8'></a>
<h3>设置响应主体、状态码和响应首部</h3>

<p>推荐在路由代码块的返回值中设定状态码和响应主体。
但是，在某些场景下你可能想在别处设置响应主体，这时你可以使用 <code>body</code> 辅助方法。
设置之后，你可以在那以后使用该方法访问响应主体：</p>

<pre><code class="language-ruby">get '/foo' do
  body "bar"
end

after do
  puts body
end
</code></pre>

<p>也可以传递一个代码块给 <code>body</code> 方法，
它会被 Rack 处理器执行（这可以用来实现流式传输，参见“返回值”）。</p>

<p>与响应主体类似，你也可以设定状态码和响应首部：</p>

<pre><code class="language-ruby">get '/foo' do
  status 418
  headers \
    "Allow"   =&gt; "BREW, POST, GET, PROPFIND, WHEN",
    "Refresh" =&gt; "Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"
  body "I'm a tea pot!"
end
</code></pre>

<p>正如 <code>body</code> 方法，不带参数调用 <code>headers</code> 和 <code>status</code> 方法可以访问它们的当前值。</p>

<a name='%E5%93%8D%E5%BA%94%E7%9A%84%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93'></a>
<h3>响应的流式传输</h3>

<p>有时你可能想在完全生成响应主体前返回数据。
更极端的情况是，你希望在客户端关闭连接前一直发送数据。
为满足这些需求，可以使用 <code>stream</code> 辅助方法而不必重新造轮子：</p>

<pre><code class="language-ruby">get '/' do
  stream do |out|
    out &lt;&lt; "It's gonna be legen -\n"
    sleep 0.5
    out &lt;&lt; " (wait for it) \n"
    sleep 1
    out &lt;&lt; "- dary!\n"
  end
end
</code></pre>

<p><code>stream</code> 辅助方法允许你实现流式 API 和
<a href="https://w3c.github.io/eventsource/">服务器端发送事件</a>，
同时它也是实现 <a href="https://en.wikipedia.org/wiki/WebSocket">WebSockets</a> 的基础。
如果你应用的部分（不是全部）内容依赖于访问缓慢的资源，它也可以用来提高并发能力。</p>

<p>请注意流式传输，尤其是并发请求数，高度依赖于应用所使用的服务器。
一些服务器可能根本不支持流式传输。
如果服务器不支持，传递给 <code>stream</code> 方法的代码块执行完毕之后，响应主体会一次性地发送给客户端。
Shotgun 完全不支持流式传输。</p>

<p>如果 <code>:keep_open</code> 作为可选参数传递给 <code>stream</code> 方法，将不会在流对象上调用 <code>close</code> 方法，
这允许你在控制流的下游某处手动关闭。该参数只对事件驱动的服务器（如 Thin 和 Rainbows）生效。
其它服务器仍会关闭流式传输：</p>

<pre><code class="language-ruby"># 长轮询

set :server, :thin
connections = []

get '/subscribe' do
  # 在服务器端的事件中注册客户端
  stream(:keep_open) do |out|
    connections &lt;&lt; out
    # 清除关闭的连接
    connections.reject!(&amp;:closed?)
  end
end

post '/:message' do
  connections.each do |out|
    # 通知客户端有条新消息
    out &lt;&lt; params['message'] &lt;&lt; "\n"

    # 使客户端重新连接
    out.close
  end

  # 确认
  "message received"
end
</code></pre>

<a name='%E6%97%A5%E5%BF%97'></a>
<h3>日志</h3>

<p>在请求作用域下，<code>logger</code> 辅助方法会返回一个 <code>Logger</code> 类的实例：</p>

<pre><code class="language-ruby">get '/' do
  logger.info "loading data"
  # ...
end
</code></pre>

<p>该 <code>logger</code> 方法会自动参考 Rack 处理器的日志设置。
若日志被禁用，该方法会返回一个无关痛痒的对象，所以你完全不必担心这会影响路由和过滤器。</p>

<p>注意只有 <code>Sinatra::Application</code> 默认开启了日志，若你的应用继承自 <code>Sinatra::Base</code>，
很可能需要手动开启：</p>

<pre><code class="language-ruby">class MyApp &lt; Sinatra::Base
  configure :production, :development do
    enable :logging
  end
end
</code></pre>

<p>为避免使用任何与日志有关的中间件，需要将 <code>logging</code> 设置项设为 <code>nil</code>。
然而，在这种情况下，<code>logger</code> 辅助方法会返回 <code>nil</code>。
一种常见的使用场景是你想要使用自己的日志工具。
Sinatra 会使用 <code>env['rack.logger']</code> 的值作为日志工具，无论该值是什么。</p>

<a name='%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B'></a>
<h3>媒体类型</h3>

<p>使用 <code>send_file</code> 或者静态文件的时候，Sinatra 可能不会识别你的媒体类型。
使用 <code>mime_type</code> 通过文件扩展名来注册媒体类型：</p>

<pre><code class="language-ruby">mime_type :foo, 'text/foo'
</code></pre>

<p>你也可以使用 <code>content_type</code> 辅助方法：</p>

<pre><code class="language-ruby">get '/' do
  content_type :foo
  "foo foo foo"
end
</code></pre>

<a name='%E7%94%9F%E6%88%90%20URL'></a>
<h3>生成 URL</h3>

<p>为了生成 URL，你应当使用 <code>url</code> 辅助方法，例如，在 Haml 中：</p>

<pre><code class="language-ruby">%a{:href =&gt; url('/foo')} foo
</code></pre>

<p>如果使用了反向代理和 Rack 路由，生成 URL 的时候会考虑这些因素。</p>

<p>这个方法还有一个别名 <code>to</code> (见下面的例子)。</p>

<a name='%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91'></a>
<h3>浏览器重定向</h3>

<p>你可以通过 <code>redirect</code> 辅助方法触发浏览器重定向：</p>

<pre><code class="language-ruby">get '/foo' do
  redirect to('/bar')
end
</code></pre>

<p>其他参数的用法，与 <code>halt</code> 相同：</p>

<pre><code class="language-ruby">redirect to('/bar'), 303
redirect 'http://www.google.com/', 'wrong place, buddy'
</code></pre>

<p>用 <code>redirect back</code> 可以把用户重定向到原始页面：</p>

<pre><code class="language-ruby">get '/foo' do
  "&lt;a href='/bar'&gt;do something&lt;/a&gt;"
end

get '/bar' do
  do_something
  redirect back
end
</code></pre>

<p>如果想传递参数给 redirect，可以用查询字符串：</p>

<pre><code class="language-ruby">redirect to('/bar?sum=42')
</code></pre>

<p>或者使用会话：</p>

<pre><code class="language-ruby">enable :sessions

get '/foo' do
  session['secret'] = 'foo'
  redirect to('/bar')
end

get '/bar' do
  session['secret']
end
</code></pre>

<a name='%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6'></a>
<h3>缓存控制</h3>

<p>正确设置响应首部是合理利用 HTTP 缓存的基础。</p>

<p>可以这样设定 Cache-Control 首部字段：</p>

<pre><code class="language-ruby">get '/' do
  cache_control :public
  "cache it!"
end
</code></pre>

<p>核心提示: 应当在 <code>before</code> 过滤器中设定缓存。</p>

<pre><code class="language-ruby">before do
  cache_control :public, :must_revalidate, :max_age =&gt; 60
end
</code></pre>

<p>如果你使用 <code>expires</code> 辅助方法设定响应的响应首部， 会自动设定 <code>Cache-Control</code> 字段：</p>

<pre><code class="language-ruby">before do
  expires 500, :public, :must_revalidate
end
</code></pre>

<p>为了合理使用缓存，你应该考虑使用 <code>etag</code> 或 <code>last_modified</code> 方法。
推荐在执行繁重任务<em>之前</em>使用这些辅助方法，这样一来，
如果客户端在缓存中已经有相关内容，就会立即得到响应：</p>

<pre><code class="language-ruby">get '/article/:id' do
  @article = Article.find params['id']
  last_modified @article.updated_at
  etag @article.sha1
  erb :article
end
</code></pre>

<p>也可以使用 <a href="https://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation">weak ETag</a>：</p>

<pre><code class="language-ruby">etag @article.sha1, :weak
</code></pre>

<p>这些辅助方法并不会为你做任何缓存，而是将必要的信息发送给你的缓存。
如果你正在寻找快捷的反向代理缓存方案，可以尝试
<a href="https://github.com/rtomayko/rack-cache">rack-cache</a>：</p>

<pre><code class="language-ruby">require "rack/cache"
require "sinatra"

use Rack::Cache

get '/' do
  cache_control :public, :max_age =&gt; 36000
  sleep 5
  "hello"
end
</code></pre>

<p>使用 <code>:statis_cache_control</code> 设置（见下文）为静态文件添加 <code>Cache-Control</code> 首部字段。</p>

<p>根据 RFC 2616，如果 If-Match 或 If-None-Match 首部设置为 <code>*</code>，根据所请求的资源存在与否，
你的应用应当有不同的行为。
Sinatra 假设安全请求（如 GET）和幂等性请求（如 PUT）所访问的资源是已经存在的，
而其它请求（如 POST 请求）所访问的资源是新资源。
你可以通过传入 <code>:new_resource</code> 选项改变这一行为。</p>

<pre><code class="language-ruby">get '/create' do
  etag '', :new_resource =&gt; true
  Article.create
  erb :new_article
end
</code></pre>

<p>如果你仍想使用 weak ETag，可以传入一个 <code>:kind</code> 选项：</p>

<pre><code class="language-ruby">etag '', :new_resource =&gt; true, :kind =&gt; :weak
</code></pre>

<a name='%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6'></a>
<h3>发送文件</h3>

<p>为了将文件的内容作为响应返回，可以使用 <code>send_file</code> 辅助方法：</p>

<pre><code class="language-ruby">get '/' do
  send_file 'foo.png'
end
</code></pre>

<p>该辅助方法接受一些选项:</p>

<pre><code class="language-ruby">send_file 'foo.png', :type =&gt; :jpg
</code></pre>

<p>可用的选项有:</p>

<dl>
  <dt>filename</dt>
  <dd>响应中使用的文件名，默认是真实的文件名。</dd>

  <dt>last_modified</dt>
  <dd>Last-Modified 响应首部的值，默认是文件的 mtime （修改时间）。</dd>

  <dt>type</dt>
  <dd>Content-Type 响应首部的值，如果未指定，会根据文件扩展名猜测。</dd>

  <dt>disposition</dt>
  <dd>
    Content-Disposition 响应首部的值，
    可选的值有： <tt>nil</tt> (默认)、<tt>:attachment</tt> 和
    <tt>:inline</tt>
  </dd>

  <dt>length</dt>
  <dd>Content-Length 响应首部的值，默认是文件的大小。</dd>

  <dt>status</dt>
  <dd>
    将要返回的状态码。当以一个静态文件作为错误页面时，这很有用。

    如果 Rack 处理器支持的话，Ruby 进程也能使用除 streaming 以外的方法。
    如果你使用这个辅助方法， Sinatra会自动处理 range 请求。
  </dd>
</dl>

<a name='%E8%AE%BF%E9%97%AE%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1'></a>
<h3>访问请求对象</h3>

<p>传入的请求对象可以在请求层（过滤器、路由、错误处理器内部）通过 <code>request</code> 方法访问：</p>

<pre><code class="language-ruby"># 在 http://example.com/example 上运行的应用
get '/foo' do
  t = %w[text/css text/html application/javascript]
  request.accept              # ['text/html', '*/*']
  request.accept? 'text/xml'  # true
  request.preferred_type(t)   # 'text/html'
  request.body                # 客户端设定的请求主体（见下文）
  request.scheme              # "http"
  request.script_name         # "/example"
  request.path_info           # "/foo"
  request.port                # 80
  request.request_method      # "GET"
  request.query_string        # ""
  request.content_length      # request.body 的长度
  request.media_type          # request.body 的媒体类型
  request.host                # "example.com"
  request.get?                # true (其它动词也具有类似方法)
  request.form_data?          # false
  request["some_param"]       # some_param 参数的值。[] 是访问 params hash 的捷径
  request.referrer            # 客户端的 referrer 或者 '/'
  request.user_agent          # 用户代理 (:agent 条件使用该值)
  request.cookies             # 浏览器 cookies 哈希
  request.xhr?                # 这是否是 ajax 请求？
  request.url                 # "http://example.com/example/foo"
  request.path                # "/example/foo"
  request.ip                  # 客户端 IP 地址
  request.secure?             # false （如果是 ssl 则为 true）
  request.forwarded?          # true （如果是运行在反向代理之后）
  request.env                 # Rack 中使用的未处理的 env hash
end
</code></pre>

<p>一些选项，例如 <code>script_name</code> 或者 <code>path_info</code> 也是可写的：</p>

<pre><code class="language-ruby">before { request.path_info = "/" }

get "/" do
  "all requests end up here"
end
</code></pre>

<p><code>request.body</code> 是一个 IO 或者 StringIO 对象：</p>

<pre><code class="language-ruby">post "/api" do
  request.body.rewind  # 如果已经有人读了它
  data = JSON.parse request.body.read
  "Hello #{data['name']}!"
end
</code></pre>

<a name='%E9%99%84%E4%BB%B6'></a>
<h3>附件</h3>

<p>你可以使用 <code>attachment</code> 辅助方法来告诉浏览器响应应当被写入磁盘而不是在浏览器中显示。</p>

<pre><code class="language-ruby">get '/' do
  attachment
  "store it!"
end
</code></pre>

<p>你也可以传递给该方法一个文件名：</p>

<pre><code class="language-ruby">get '/' do
  attachment "info.txt"
  "store it!"
end
</code></pre>

<a name='%E5%A4%84%E7%90%86%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4'></a>
<h3>处理日期和时间</h3>

<p>Sinatra 提供了一个 <code>time_for</code> 辅助方法，其目的是根据给定的值生成 Time 对象。
该方法也能够转换 <code>DateTime</code>、<code>Date</code> 和类似的类：</p>

<pre><code class="language-ruby">get '/' do
  pass if Time.now &gt; time_for('Dec 23, 2012')
  "still time"
end
</code></pre>

<p><code>expires</code>、<code>last_modified</code> 和类似方法都在内部使用了该方法。
因此，通过在应用中重写 <code>time_for</code> 方法，你可以轻松地扩展这些方法的行为：</p>

<pre><code class="language-ruby">helpers do
  def time_for(value)
    case value
    when :yesterday then Time.now - 24*60*60
    when :tomorrow then Time.now + 24*60*60
    else super
    end
  end
end

get '/' do
  last_modified :yesterday
  expires :tomorrow
  "hello"
end
</code></pre>

<a name='%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6'></a>
<h3>查找模板文件</h3>

<p><code>find_template</code> 辅助方法用于在渲染时查找模板文件：</p>

<pre><code class="language-ruby">find_template settings.views, 'foo', Tilt[:haml] do |file|
  puts "could be #{file}"
end
</code></pre>

<p>这其实并不是很有用，除非你需要重载这个方法来实现你自己的查找机制。
比如，如果你想使用不只一个视图目录：</p>

<pre><code class="language-ruby">set :views, ['views', 'templates']

helpers do
  def find_template(views, name, engine, &amp;block)
    Array(views).each { |v| super(v, name, engine, &amp;block) }
  end
end
</code></pre>

<p>另一个例子是对不同的引擎使用不同的目录:</p>

<pre><code class="language-ruby">set :views, :sass =&gt; 'views/sass', :haml =&gt; 'templates', :default =&gt; 'views'

helpers do
  def find_template(views, name, engine, &amp;block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:default]
    super(folder, name, engine, &amp;block)
  end
end
</code></pre>

<p>你可以很容易地封装成一个扩展，然后与他人分享！</p>

<p>请注意 <code>find_template</code> 并不会检查文件是否存在，而是为任何可能的路径调用传入的代码块。
这并不会导致性能问题，因为 <code>render</code> 会在找到文件的时候马上使用 <code>break</code>。
同样的，模板的路径（和内容）会在 development 以外的模式下被缓存。
你应该时刻提醒自己这一点， 如果你真的想写一个非常疯狂的方法的话。</p>

<a name='%E9%85%8D%E7%BD%AE'></a>
<h2>配置</h2>

<p>在启动时运行一次，在任何环境下都是如此：</p>

<pre><code class="language-ruby">configure do
  # 设置一个选项
  set :option, 'value'

  # 设置多个选项
  set :a =&gt; 1, :b =&gt; 2

  # 等同于 `set :option, true`
  enable :option

  # 等同于 `set :option, false`
  disable :option

  # 也可以用代码块做动态设置
  set(:css_dir) { File.join(views, 'css') }
end
</code></pre>

<p>只有当环境 (<code>APP_ENV</code> 环境变量) 被设定为 <code>:production</code> 时才运行：</p>

<pre><code class="language-ruby">configure :production do
  ...
end
</code></pre>

<p>当环境被设定为 <code>:production</code> 或者 <code>:test</code> 时运行：</p>

<pre><code class="language-ruby">configure :production, :test do
  ...
end
</code></pre>

<p>你可以用 <code>settings</code> 访问这些配置项：</p>

<pre><code class="language-ruby">configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # =&gt; true
  settings.foo  # =&gt; 'bar'
  ...
end
</code></pre>

<a name='%E9%85%8D%E7%BD%AE%E6%94%BB%E5%87%BB%E9%98%B2%E6%8A%A4'></a>
<h3>配置攻击防护</h3>

<p>Sinatra 使用 <a href="https://github.com/sinatra/rack-protection#readme">Rack::Protection</a>
来抵御常见的攻击。你可以轻易地禁用该行为（但这会大大增加应用被攻击的概率）。</p>

<pre><code class="language-ruby">disable :protection
</code></pre>

<p>为了绕过某单层防护，可以设置 <code>protection</code> 为一个选项 hash：</p>

<pre><code class="language-ruby">set :protection, :except =&gt; :path_traversal
</code></pre>

<p>你可以传入一个数组，以禁用一系列防护措施：</p>

<pre><code class="language-ruby">set :protection, :except =&gt; [:path_traversal, :session_hijacking]
</code></pre>

<p>默认地，如果 <code>:sessions</code> 是启用的，Sinatra 只会使用基于会话的防护措施。
当然，有时你可能想根据自己的需要设置会话。
在这种情况下，你可以通过传入 <code>:session</code> 选项来开启基于会话的防护。</p>

<pre><code class="language-ruby">use Rack::Session::Pool
set :protection, :session =&gt; true
</code></pre>

<a name='%E5%8F%AF%E9%80%89%E7%9A%84%E8%AE%BE%E7%BD%AE'></a>
<h3>可选的设置</h3>

<dl>
  <dt>absolute_redirects</dt>
  <dd>
    如果被禁用，Sinatra 会允许使用相对路径重定向。
    然而这样的话，Sinatra 就不再遵守 RFC 2616 (HTTP 1.1), 该协议只允许绝对路径重定向。
  </dd>
  <dd>
    如果你的应用运行在一个未恰当设置的反向代理之后，你需要启用这个选项。
    注意 <tt>url</tt> 辅助方法仍然会生成绝对 URL，除非你传入<tt>false</tt> 作为第二参数。
  </dd>
  <dd>默认禁用。</dd>

  <dt>add_charset</dt>
  <dd>
    设置 <tt>content_type</tt> 辅助方法会自动为媒体类型加上字符集信息。
    你应该添加而不是覆盖这个选项:
    <tt>settings.add_charset &lt;&lt; "application/foobar"</tt>
  </dd>

  <dt>app_file</dt>
  <dd>
    主应用文件的路径，用来检测项目的根路径， views 和 public 文件夹和内联模板。
  </dd>

  <dt>bind</dt>
  <dd>
    绑定的 IP 地址 (默认: <tt>0.0.0.0</tt>，开发环境下为 <tt>localhost</tt>)。
    仅对于内置的服务器有用。
  </dd>

  <dt>default_encoding</dt>
  <dd>默认编码 (默认为 <tt>"utf-8"</tt>)。</dd>

  <dt>dump_errors</dt>
  <dd>在日志中显示错误。</dd>

  <dt>environment</dt>
  <dd>
    当前环境，默认是 <tt>ENV['APP_ENV']</tt>，
    或者 <tt>"development"</tt> (如果 ENV['APP_ENV'] 不可用)。
  </dd>

  <dt>logging</dt>
  <dd>使用 logger。</dd>

  <dt>lock</dt>
  <dd>对每一个请求放置一个锁，只使用进程并发处理请求。</dd>
  <dd>如果你的应用不是线程安全则需启动。默认禁用。</dd>

  <dt>method_override</dt>
  <dd>
    使用 <tt>_method</tt> 魔法，以允许在不支持的浏览器中在使用 put/delete 方法提交表单。
  </dd>

  <dt>port</dt>
  <dd>监听的端口号。只对内置服务器有用。</dd>

  <dt>prefixed_redirects</dt>
  <dd>
    如果没有使用绝对路径，是否添加 <tt>request.script_name</tt> 到重定向请求。
    如果添加，<tt>redirect '/foo'</tt> 会和 <tt>redirect to('/foo')</tt> 相同。
    默认禁用。
  </dd>

  <dt>protection</dt>
  <dd>是否启用网络攻击防护。参见上面的保护部分</dd>

  <dt>public_dir</dt>
  <dd>public_folder 的别名。见下文。</dd>

  <dt>public_folder</dt>
  <dd>
    public 文件存放的路径。只有启用了静态文件服务（见下文的 <tt>static</tt>）才会使用。
    如果未设置，默认从 <tt>app_file</tt> 推断。
  </dd>

  <dt>reload_templates</dt>
  <dd>
    是否每个请求都重新载入模板。在开发模式下开启。
  </dd>

  <dt>root</dt>
  <dd>到项目根目录的路径。默认从 <tt>app_file</tt> 设置推断。</dd>

  <dt>raise_errors</dt>
  <dd>
    抛出异常（会停止应用）。
    当 <tt>environment</tt> 设置为 <tt>"test"</tt> 时会默认开启，其它环境下默认禁用。
  </dd>

  <dt>run</dt>
  <dd>如果启用，Sinatra 会负责 web 服务器的启动。若使用 rackup 或其他方式则不要启用。</dd>

  <dt>running</dt>
  <dd>内置的服务器在运行吗？ 不要修改这个设置！</dd>

  <dt>server</dt>
  <dd>服务器，或用于内置服务器的服务器列表。顺序表明了优先级，默认顺序依赖 Ruby 实现。</dd>

  <dt>sessions</dt>
  <dd>
    使用 <tt>Rack::Session::Cookie</tt>，启用基于 cookie 的会话。
    查看“使用会话”部分以获得更多信息。
  </dd>

  <dt>show_exceptions</dt>
  <dd>
    当有异常发生时，在浏览器中显示一个 stack trace。
    当 <tt>environment</tt> 设置为 <tt>"development"</tt> 时，默认启用，
    否则默认禁用。
  </dd>
  <dd>
    也可以设置为 <tt>:after_handler</tt>，
    这会在浏览器中显示 stack trace 之前触发应用级别的错误处理。
  </dd>

  <dt>static</dt>
  <dd>决定 Sinatra 是否服务静态文件。</dd>
  <dd>当服务器能够自行服务静态文件时，会禁用。</dd>
  <dd>禁用会增强性能。</dd>
  <dd>在经典风格中默认启用，在模块化应用中默认禁用。</dd>

  <dt>static_cache_control</dt>
  <dd>
    当 Sinatra 提供静态文件服务时，设置此选项为响应添加 <tt>Cache-Control</tt> 首部。
    使用 <tt>cache_control</tt> 辅助方法。默认禁用。
  </dd>
  <dd>
    当设置多个值时使用数组：
    <tt>set :static_cache_control, [:public, :max_age =&gt; 300]</tt>
  </dd>

  <dt>threaded</dt>
  <dd>
    若设置为 <tt>true</tt>，会告诉 Thin 使用 <tt>EventMachine.defer</tt> 处理请求。
  </dd>

  <dt>traps</dt>
  <dd>Sinatra 是否应该处理系统信号。</dd>

  <dt>views</dt>
  <dd>views 文件夹的路径。若未设置则会根据 <tt>app_file</tt> 推断。</dd>

  <dt>x_cascade</dt>
  <dd>若没有路由匹配，是否设置 X-Cascade 首部。默认为 <tt>true</tt>。</dd>
</dl>

<a name='%E7%8E%AF%E5%A2%83'></a>
<h2>环境</h2>

<p>Sinatra 中有三种预先定义的环境：”development”、”production” 和 “test”。
环境可以通过 <code>APP_ENV</code> 环境变量设置。默认值为 “development”。
在开发环境下，每次请求都会重新加载所有模板，
特殊的 <code>not_found</code> 和 <code>error</code> 错误处理器会在浏览器中显示 stack trace。
在测试和生产环境下，模板默认会缓存。</p>

<p>在不同的环境下运行，设置 <code>APP_ENV</code> 环境变量：</p>

<pre><code class="language-shell">APP_ENV=production ruby my_app.rb
</code></pre>

<p>可以使用预定义的三种方法： <code>development?</code>、<code>test?</code> 和 <code>production?</code> 来检查当前环境：</p>

<pre><code class="language-ruby">get '/' do
  if settings.development?
    "development!"
  else
    "not development"
  end
end
</code></pre>

<a name='%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86'></a>
<h2>错误处理</h2>

<p>错误处理器在与路由和 before 过滤器相同的上下文中运行，
这意味着你可以使用许多好东西，比如 <code>haml</code>, <code>erb</code>, <code>halt</code>，等等。</p>

<a name='%E6%9C%AA%E6%89%BE%E5%88%B0'></a>
<h3>未找到</h3>

<p>当一个 <code>Sinatra::NotFound</code> 错误被抛出时，或者当响应的状态码是 404 时，
会调用 <code>not_found</code> 处理器：</p>

<pre><code class="language-ruby">not_found do
  'This is nowhere to be found.'
end
</code></pre>

<a name='%E9%94%99%E8%AF%AF'></a>
<h3>错误</h3>

<p>在任何路由代码块或过滤器抛出异常时，会调用 <code>error</code> 处理器。
但注意在开发环境下只有将 show exceptions 项设置为 <code>:after_handler</code> 时，才会生效。</p>

<pre><code class="language-ruby">set :show_exceptions, :after_handler
</code></pre>

<p>可以用 Rack 变量 <code>sinatra.error</code> 访问异常对象：</p>

<pre><code class="language-ruby">error do
  'Sorry there was a nasty error - ' + env['sinatra.error'].message
end
</code></pre>

<p>自定义错误：</p>

<pre><code class="language-ruby">error MyCustomError do
  'So what happened was...' + env['sinatra.error'].message
end
</code></pre>

<p>当下面的代码执行时：</p>

<pre><code class="language-ruby">get '/' do
  raise MyCustomError, 'something bad'
end
</code></pre>

<p>你会得到错误信息：</p>

<pre><code>So what happened was... something bad
</code></pre>

<p>或者，你也可以为状态码设置错误处理器：</p>

<pre><code class="language-ruby">error 403 do
  'Access forbidden'
end

get '/secret' do
  403
end
</code></pre>

<p>或者为某个范围内的状态码统一设置错误处理器：</p>

<pre><code class="language-ruby">error 400..510 do
  'Boom'
end
</code></pre>

<p>在开发环境下，Sinatra会使用特殊的 <code>not_found</code> 和 <code>error</code> 处理器，
以便在浏览器中显示美观的 stack traces 和额外的调试信息。</p>

<a name='Rack%20%E4%B8%AD%E9%97%B4%E4%BB%B6'></a>
<h2>Rack 中间件</h2>

<p>Sinatra 依赖 <a href="http://rack.github.io/">Rack</a>, 一个面向 Ruby 网络框架的最小化标准接口。
Rack 最有趣的功能之一是支持“中间件”——位于服务器和你的应用之间的组件，
它们监控或操作 HTTP 请求/响应以提供多种常用功能。</p>

<p>Sinatra 通过顶层的 <code>use</code> 方法，让建立 Rack 中间件管道异常简单：</p>

<pre><code class="language-ruby">require 'sinatra'
require 'my_custom_middleware'

use Rack::Lint
use MyCustomMiddleware

get '/hello' do
  'Hello World'
end
</code></pre>

<p><code>use</code> 的语义和在  <a href="http://www.rubydoc.info/github/rack/rack/master/Rack/Builder">Rack::Builder</a>
DSL (在 rackup 文件中最频繁使用)中定义的完全一样。例如，<code>use</code> 方法接受
多个/可变参数，以及代码块：</p>

<pre><code class="language-ruby">use Rack::Auth::Basic do |username, password|
  username == 'admin' &amp;&amp; password == 'secret'
end
</code></pre>

<p>Rack 拥有有多种标准中间件，用于日志、调试、URL 路由、认证和会话处理。
根据配置，Sinatra 可以自动使用这里面的许多组件，
所以你一般不需要显式地 <code>use</code> 它们。</p>

<p>你可以在 <a href="https://github.com/rack/rack/tree/master/lib/rack">rack</a>、
<a href="https://github.com/rack/rack-contrib#readm">rack-contrib</a> 或
<a href="https://github.com/rack/rack/wiki/List-of-Middleware">Rack wiki</a>
中找到有用的中间件。</p>

<a name='%E6%B5%8B%E8%AF%95'></a>
<h2>测试</h2>

<p>可以使用任何基于 Rack 的测试程序库或者框架来编写Sinatra的测试。
推荐使用 <a href="http://www.rubydoc.info/github/brynary/rack-test/master/frames">Rack::Test</a>：</p>

<pre><code class="language-ruby">require 'my_sinatra_app'
require 'minitest/autorun'
require 'rack/test'

class MyAppTest &lt; Minitest::Test
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_my_default
    get '/'
    assert_equal 'Hello World!', last_response.body
  end

  def test_with_params
    get '/meet', :name =&gt; 'Frank'
    assert_equal 'Hello Frank!', last_response.body
  end

  def test_with_rack_env
    get '/', {}, 'HTTP_USER_AGENT' =&gt; 'Songbird'
    assert_equal "You're using Songbird!", last_response.body
  end
end
</code></pre>

<p>注意：如果你使用 Sinatra 的模块化风格，应该用你应用的类名替代 <code>Sinatra::Application</code>。</p>

<a name='Sinatra::Base%20-%20%E4%B8%AD%E9%97%B4%E4%BB%B6%E3%80%81%E5%BA%93%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BA%94%E7%94%A8'></a>
<h2>Sinatra::Base - 中间件、库和模块化应用</h2>

<p>在顶层定义你的应用很适合微型项目，
但是在构建可复用的组件（如 Rack 中间件、Rails metal、带服务器组件的库或 Sinatra 扩展）时，
却有相当大的缺陷。
顶层 DSL 认为你采用的是微型应用风格的配置 (例如：唯一应用文件、
<code>./public</code> 和 <code>./views</code> 目录、日志、异常细节页面等）。
如果你的项目不采用微型应用风格，应该使用 <code>Sinatra::Base</code>：</p>

<pre><code class="language-ruby">require 'sinatra/base'

class MyApp &lt; Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Hello world!'
  end
end
</code></pre>

<p>Sinatra::Base 的子类可以使用的方法实际上就是顶层 DSL 中可以使用的方法。
大部分顶层应用可以通过两方面的改变转换为 Sinatra::Base 组件：</p>

<ul>
  <li>
    <p>你的文件应当引入 <code>sinatra/base</code> 而不是 <code>sinatra</code>；
否则，Sinatra 的所有 DSL 方法将会被导入主命名空间。</p>
  </li>
  <li>
    <p>把应用的路由、错误处理器、过滤器和选项放在一个 Sinatra::Base 的子类中。</p>
  </li>
</ul>

<p><code>Sinatra::Base</code> 是一个白板。大部分选项（包括内置的服务器）默认是禁用的。
可以参考<a href="http://www.sinatrarb.com/configuration.html">配置</a>
以查看可用选项的具体细节和它们的行为。如果你想让你的应用更像顶层定义的应用（即经典风格），
你可以继承 <code>Sinatra::Applicaiton</code>。</p>

<pre><code class="language-ruby">require 'sinatra/base'

class MyApp &lt; Sinatra::Application
  get '/' do
    'Hello world!'
  end
end
</code></pre>

<a name='%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A3%8E%E6%A0%BC%20vs.%20%E7%BB%8F%E5%85%B8%E9%A3%8E%E6%A0%BC'></a>
<h3>模块化风格 vs. 经典风格</h3>

<p>与通常的认识相反，经典风格并没有任何错误。
如果它适合你的应用，你不需要切换到模块化风格。</p>

<p>与模块化风格相比，经典风格的主要缺点在于，每个 Ruby 进程只能有一个 Sinatra 应用。
如果你计划使用多个 Sinatra 应用，应该切换到模块化风格。
你也完全可以混用模块化风格和经典风格。</p>

<p>如果从一种风格转换到另一种，你需要注意默认设置中的一些细微差别：</p>

<table>
  <tr>
    <th>设置</th>
    <th>经典风格</th>
    <th>模块化风格</th>
    <th>模块化风格</th>
  </tr>

  <tr>
    <td>app_file</td>
    <td>加载 sinatra 的文件</td>
    <td>继承 Sinatra::Base 的文件</td>
    <td>继承 Sinatra::Application 的文件</td>
  </tr>

  <tr>
    <td>run</td>
    <td>$0 == app_file</td>
    <td>false</td>
    <td>false</td>
  </tr>

  <tr>
    <td>logging</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>method_override</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>inline_templates</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>static</td>
    <td>true</td>
    <td>File.exist?(public_folder)</td>
    <td>true</td>
  </tr>
</table>

<a name='%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BA%94%E7%94%A8'></a>
<h3>运行一个模块化应用</h3>

<p>模块化应用的启动有两种常见方式，其中之一是使用 <code>run!</code> 方法主动启动:</p>

<pre><code class="language-ruby"># my_app.rb
require 'sinatra/base'

class MyApp &lt; Sinatra::Base
  # ... 这里是应用代码 ...

  # 如果直接执行该文件，那么启动服务器
  run! if app_file == $0
end
</code></pre>

<p>执行该文件就会启动服务器：</p>

<pre><code class="language-shell">ruby my_app.rb
</code></pre>

<p>另一种方式是使用 <code>config.ru</code> 文件，这种方式允许你使用任何 Rack 处理器：</p>

<pre><code class="language-ruby"># config.ru （用 rackup 启动）
require './my_app'
run MyApp
</code></pre>

<p>运行：</p>

<pre><code class="language-shell">rackup -p 4567
</code></pre>

<a name='%E4%BD%BF%E7%94%A8%20config.ru%20%E8%BF%90%E8%A1%8C%E7%BB%8F%E5%85%B8%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%BA%94%E7%94%A8'></a>
<h3>使用 config.ru 运行经典风格的应用</h3>

<p>编写你的应用:</p>

<pre><code class="language-ruby"># app.rb
require 'sinatra'

get '/' do
  'Hello world!'
end
</code></pre>

<p>添加相应的 <code>config.ru</code>：</p>

<pre><code class="language-ruby">require './app'
run Sinatra::Application
</code></pre>

<a name='%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%20config.ru%EF%BC%9F'></a>
<h3>何时使用 config.ru？</h3>

<p>下列情况，推荐使用 <code>config.ru</code>：</p>

<ul>
  <li>部署时使用不同的 Rack 处理器 (Passenger、Unicorn、Heroku 等)。</li>
  <li>使用多个 <code>Sinatra::Base</code> 的子类。</li>
  <li>把 Sinatra 当作中间件使用，而非端点。</li>
</ul>

<p><strong>你不必仅仅因为想使用模块化风格而切换到 <code>config.ru</code>，同样的，
你也不必仅仅因为要运行 <code>config.ru</code> 而切换到模块化风格。</strong></p>

<a name='%E6%8A%8A%20Sinatra%20%E5%BD%93%E4%BD%9C%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BD%BF%E7%94%A8'></a>
<h3>把 Sinatra 当作中间件使用</h3>

<p>Sinatra 可以使用其它 Rack 中间件，
反过来，任何 Sinatra 应用程序自身都可以被当作中间件，添加到任何 Rack 端点前面。
此端点可以是任何 Sinatra 应用，或任何基于 Rack 的应用程序 (Rails/Ramaze/Camping/…)：</p>

<pre><code class="language-ruby">require 'sinatra/base'

class LoginScreen &lt; Sinatra::Base
  enable :sessions

  get('/login') { haml :login }

  post('/login') do
    if params['name'] == 'admin' &amp;&amp; params['password'] == 'admin'
      session['user_name'] = params['name']
    else
      redirect '/login'
    end
  end
end

class MyApp &lt; Sinatra::Base
  # 中间件的执行发生在 before 过滤器之前
  use LoginScreen

  before do
    unless session['user_name']
      halt "Access denied, please &lt;a href='/login'&gt;login&lt;/a&gt;."
    end
  end

  get('/') { "Hello #{session['user_name']}." }
end
</code></pre>

<a name='%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E5%BA%94%E7%94%A8'></a>
<h3>创建动态应用</h3>

<p>有时你希望在运行时创建新应用，而不必把应用预先赋值给常量。这时可以使用 <code>Sinatra.new</code>：</p>

<pre><code class="language-ruby">require 'sinatra/base'
my_app = Sinatra.new { get('/') { "hi" } }
my_app.run!
</code></pre>

<p><code>Sinatra.new</code> 接受一个可选的参数，表示要继承的应用：</p>

<pre><code class="language-ruby"># config.ru (用 rackup 启动)
require 'sinatra/base'

controller = Sinatra.new do
  enable :logging
  helpers MyHelpers
end

map('/a') do
  run Sinatra.new(controller) { get('/') { 'a' } }
end

map('/b') do
  run Sinatra.new(controller) { get('/') { 'b' } }
end
</code></pre>

<p>当你测试 Sinatra 扩展或在自己的类库中使用 Sinatra 时，这非常有用。</p>

<p>这也让把 Sinatra 当作中间件使用变得极其容易：</p>

<pre><code class="language-ruby">require 'sinatra/base'

use Sinatra do
  get('/') { ... }
end

run RailsProject::Application
</code></pre>

<a name='%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%BB%91%E5%AE%9A'></a>
<h2>作用域和绑定</h2>

<p>当前作用域决定了可以使用的方法和变量。</p>

<a name='%E5%BA%94%E7%94%A8/%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F'></a>
<h3>应用/类作用域</h3>

<p>每个 Sinatra 应用都对应 <code>Sinatra::Base</code> 类的一个子类。
如果你在使用顶层 DSL (<code>require 'sinatra'</code>)，那么这个类就是 <code>Sinatra::Application</code>，
否则该类是你显式创建的子类。
在类层面，你可以使用 <code>get</code> 或 <code>before</code> 这样的方法，
但不能访问 <code>request</code> 或 <code>session</code> 对象, 因为对于所有的请求，只有单一的应用类。</p>

<p>通过 <code>set</code> 创建的选项是类方法：</p>

<pre><code class="language-ruby">class MyApp &lt; Sinatra::Base
  # 嘿，我在应用作用域！
  set :foo, 42
  foo # =&gt; 42

  get '/foo' do
    # 嘿，我已经不在应用作用域了！
  end
end
</code></pre>

<p>下列位置绑定的是应用作用域：</p>

<ul>
  <li>应用类内部</li>
  <li>通过扩展定义的方法内部</li>
  <li>传递给 <code>helpers</code> 方法的代码块内部</li>
  <li>作为 <code>set</code> 值的 procs/blocks 内部</li>
  <li>传递给 <code>Sinatra.new</code> 的代码块内部</li>
</ul>

<p>你可以这样访问变量域对象（应用类）：
* 通过传递给 configure 代码块的对象 (<code>configure { |c| ... }</code>)
* 在请求作用域中使用 <code>settings</code></p>

<a name='%E8%AF%B7%E6%B1%82/%E5%AE%9E%E4%BE%8B%E4%BD%9C%E7%94%A8%E5%9F%9F'></a>
<h3>请求/实例作用域</h3>

<p>对于每个请求，Sinatra 会创建应用类的一个新实例。所有的处理器代码块都在该实例对象的作用域中运行。
在该作用域中， 你可以访问 <code>request</code> 和 <code>session</code> 对象，
或调用渲染方法（如 <code>erb</code>、<code>haml</code>）。你可以在请求作用域中通过 <code>settings</code> 辅助方法
访问应用作用域：</p>

<pre><code class="language-ruby">class MyApp &lt; Sinatra::Base
  # 嘿，我在应用作用域!
  get '/define_route/:name' do
    # '/define_route/:name' 的请求作用域
    @value = 42

    settings.get("/#{params['name']}") do
      # "/#{params['name']}" 的请求作用域
      @value # =&gt; nil (并不是同一个请求)
    end

    "Route defined!"
  end
end
</code></pre>

<p>以下位置绑定的是请求作用域：</p>

<ul>
  <li>get、head、post、put、delete、options、patch、link 和 unlink 代码块内部</li>
  <li>before 和 after 过滤器内部</li>
  <li>辅助方法内部</li>
  <li>模板/视图内部</li>
</ul>

<a name='%E4%BB%A3%E7%90%86%E4%BD%9C%E7%94%A8%E5%9F%9F'></a>
<h3>代理作用域</h3>

<p>代理作用域只是把方法转送到类作用域。
然而，它与类作用域的行为并不完全相同, 因为你并不能在代理作用域获得类的绑定。
只有显式地标记为供代理使用的方法才是可用的，
而且你不能和类作用域共享变量/状态。(解释：你有了一个不同的 <code>self</code>)。
你可以通过调用 <code>Sinatra::Delegator.delegate :method_name</code> 显式地添加方法代理。</p>

<p>以下位置绑定的是代理变量域：
* 顶层绑定，如果你执行了 <code>require "sinatra"</code>
* 扩展了 <code>Sinatra::Delegator</code> 这一 mixin 的对象内部</p>

<p>自己在这里看一下源码：<a href="https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/base.rb#L1609-1633">Sinatra::Delegator
mixin</a>
已经
<a href="https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/main.rb#L28-30">被扩展进了 main 对象</a>。</p>

<a name='%E5%91%BD%E4%BB%A4%E8%A1%8C'></a>
<h2>命令行</h2>

<p>可以直接运行 Sinatra 应用：</p>

<pre><code class="language-shell">ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-o HOST] [-s HANDLER]
</code></pre>

<p>选项是：</p>

<pre><code>-h # 显示帮助
-p # 设置端口号 (默认是 4567)
-o # 设定主机名 (默认是 0.0.0.0)
-e # 设置环境 (默认是 development)
-s # 声明 rack 服务器/处理器 (默认是 thin)
-x # 打开互斥锁 (默认是 off)
</code></pre>

<a name='%E5%A4%9A%E7%BA%BF%E7%A8%8B'></a>
<h3>多线程</h3>

<p><em>根据 Konstantin 的 <a href="http://stackoverflow.com/questions/6278817/is-sinatra-multi-threaded/6282999#6282999)">这个 StackOverflow 答案</a> 改写</em></p>

<p>Sinatra 本身并不使用任何并发模型，而是将并发的任务留给底层的
Rack 处理器（服务器），如 Thin、Puma 或 WEBrick。Sinatra 本身是线程安全的，所以
Rack 处理器使用多线程并发模型并无任何问题。这意味着在启动服务器时，你必须指定特定
Rack 处理器的正确调用方法。
下面的例子展示了如何启动一个多线程的 Thin 服务器：</p>

<pre><code class="language-ruby"># app.rb

require 'sinatra/base'

class App &lt; Sinatra::Base
  get '/' do
    "Hello, World"
  end
end

App.run!

</code></pre>

<p>启动服务器的命令是：</p>

<pre><code class="language-shell">thin --threaded start
</code></pre>

<a name='%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6'></a>
<h2>必要条件</h2>

<p>以下 Ruby 版本受官方支持:</p>
<dl>
  <dt>Ruby 1.8.7</dt>
  <dd>
    Sinatra 完全支持 1.8.7，但是，除非必要，我们推荐你升级或者切换到
    JRuby 或 Rubinius。Sinatra 2.0 之前都不会取消对 1.8.7
    的支持。Ruby 1.8.6 目前已不受支持。
  </dd>

  <dt>Ruby 1.9.2</dt>
  <dd>
    Sinatra 完全支持 1.9.2。
    不要使用 1.9.2p0，它在运行 Sinatra 程序时会产生 segmentation faults 错误。
    至少在 Sinatra 1.5 发布之前，官方对 1.9.2 的支持仍会继续。
  </dd>

  <dt>Ruby 1.9.3</dt>
  <dd>
    Sinatra 完全支持并推荐使用 1.9.3。请注意从更早的版本迁移到 1.9.3 会使所有的会话失效。
    直到 Sinatra 2.0 发布之前，官方仍然会支持 1.9.3。
  </dd>

  <dt>Ruby 2.x</dt>
  <dd>
    Sinatra 完全支持并推荐使用 2.x。目前尚无停止支持 2.x 的计划。
  </dd>

  <dt>Rubinius</dt>
  <dd>
    Sinatra 官方支持 Rubinius (Rubinius &gt;= 2.x)。推荐 <tt>gem install puma</tt>。
  </dd>

  <dt>JRuby</dt>
  <dd>
    Sinatra 官方支持 JRuby 的最新稳定版本，但不推荐在 JRuby 上使用 C 扩展。
    推荐 <tt>gem install trinidad</tt>。
  </dd>
</dl>

<p>我们也在时刻关注新的 Ruby 版本。</p>

<p>以下 Ruby 实现不受 Sinatra 官方支持，但可以运行 Sinatra：</p>

<ul>
  <li>老版本 JRuby 和 Rubinius</li>
  <li>Ruby 企业版</li>
  <li>MacRuby、Maglev、IronRuby</li>
  <li>Ruby 1.9.0 和 1.9.1 （不推荐使用）</li>
</ul>

<p>不受官方支持的意思是，如果仅在不受支持的 Ruby 实现上发生错误，我们认为不是我们的问题，而是该实现的问题。</p>

<p>我们同时也针对 ruby-head （MRI 的未来版本）运行 CI，但由于 ruby-head 一直处在变化之中，
我们不能作任何保证。我们期望完全支持未来的 2.x 版本。</p>

<p>Sinatra 应该会运行在任何支持上述 Ruby 实现的操作系统上。</p>

<p>如果你使用 MacRuby，你应该 <code>gem install control_tower</code>。</p>

<p>Sinatra 目前不支持 Cardinal、SmallRuby、BlueRuby 或其它 1.8.7 之前的 Ruby 版本。</p>

<a name='%E7%B4%A7%E8%B7%9F%E5%89%8D%E6%B2%BF'></a>
<h2>紧跟前沿</h2>

<p>如果你想使用 Sinatra 的最新代码，请放心使用 master 分支来运行你的程序，它是相当稳定的。</p>

<p>我们也会不定期推出 prerelease gems，所以你也可以运行</p>

<pre><code class="language-shell">gem install sinatra --pre
</code></pre>

<p>来获得最新的特性。</p>

<a name='%E9%80%9A%E8%BF%87%20Bundler%20%E4%BD%BF%E7%94%A8%20Sinatra'></a>
<h3>通过 Bundler 使用 Sinatra</h3>

<p>如果你想在应用中使用最新的 Sinatra，推荐使用 <a href="http://bundler.io">Bundler</a>。</p>

<p>首先，安装 Bundler，如果你还没有安装的话：</p>

<pre><code class="language-shell">gem install bundler
</code></pre>

<p>然后，在你的项目目录下创建一个 <code>Gemfile</code>：</p>

<pre><code class="language-ruby">source 'https://rubygems.org'
gem 'sinatra', :github =&gt; "sinatra/sinatra"

# 其它依赖
gem 'haml'                    # 假如你使用 haml
gem 'activerecord', '~&gt; 3.0'  # 也许你还需要 ActiveRecord 3.x
</code></pre>

<p>请注意你必须在 <code>Gemfile</code> 中列出应用的所有依赖项。
然而， Sinatra 的直接依赖项 (Rack 和 Tilt) 则会被 Bundler 自动获取和添加。</p>

<p>现在你可以这样运行你的应用:</p>

<pre><code class="language-shell">bundle exec ruby myapp.rb
</code></pre>

<a name='%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E6%9C%AC%E5%9C%B0%E7%9A%84%20Sinatra'></a>
<h3>使用自己本地的 Sinatra</h3>

<p>创建一个本地克隆，并通过 <code>$LOAD_PATH</code> 里的 <code>sinatra/lib</code> 目录运行你的应用：</p>

<pre><code class="language-shell">cd myapp
git clone git://github.com/sinatra/sinatra.git
ruby -I sinatra/lib myapp.rb
</code></pre>

<p>为了在未来更新 Sinatra 源代码：</p>

<pre><code class="language-shell">cd myapp/sinatra
git pull
</code></pre>

<a name='%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85'></a>
<h3>全局安装</h3>

<p>你可以自行编译 Sinatra gem：</p>

<pre><code class="language-shell">git clone git://github.com/sinatra/sinatra.git
cd sinatra
rake sinatra.gemspec
rake install
</code></pre>

<p>如果你以 root 身份安装 gems，最后一步应该是：</p>

<pre><code class="language-shell">sudo rake install
</code></pre>

<a name='%E7%89%88%E6%9C%AC'></a>
<h2>版本</h2>

<p>Sinatra 遵循<a href="http://semver.org">语义化版本</a>，无论是 SemVer 还是 SemVerTag。</p>

<a name='%E6%9B%B4%E5%A4%9A%E8%B5%84%E6%96%99'></a>
<h2>更多资料</h2>

<ul>
  <li>
<a href="http://www.sinatrarb.com/">项目官网</a> - 更多文档、新闻和其它资源的链接。</li>
  <li>
<a href="http://www.sinatrarb.com/contributing">贡献</a> - 找到一个 bug？需要帮助？有了一个 patch？</li>
  <li><a href="https://github.com/sinatra/sinatra/issues">问题追踪</a></li>
  <li><a href="https://twitter.com/sinatra">Twitter</a></li>
  <li><a href="http://groups.google.com/group/sinatrarb/topics">邮件列表</a></li>
  <li>IRC: <a href="irc://chat.freenode.net/#sinatra">#sinatra</a> on http://freenode.net</li>
  <li>
<a href="https://sinatrarb.slack.com">Sinatra &amp; Friends</a> on Slack，点击
<a href="https://sinatra-slack.herokuapp.com/">这里</a> 获得邀请。</li>
  <li>
<a href="https://github.com/sinatra/sinatra-book/">Sinatra Book</a> Cookbook 教程</li>
  <li>
<a href="http://recipes.sinatrarb.com/">Sinatra Recipes</a> 社区贡献的实用技巧</li>
  <li>http://www.rubydoc.info/ 上<a href="http://www.rubydoc.info//gems/sinatra">最新版本</a>或<a href="http://www.rubydoc.info/github/sinatra/sinatra">当前 HEAD</a> 的 API 文档</li>
  <li><a href="https://travis-ci.org/sinatra/sinatra">CI 服务器</a></li>
</ul>
</body></html>
