<div class='toc'>
	<ol class='level-1'>
		<li><a href='#%E8%B7%AF%E7%94%B1'>路由</a></li>
		<ol class='level-2'>
			<li><a href='#%E6%9D%A1%E4%BB%B6'>条件</a></li>
			<li><a href='#%E8%BF%94%E5%9B%9E%E5%80%BC'>返回值</a></li>
			<li><a href='#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E5%99%A8'>自定义路由匹配器</a></li>
		</ol>
		<li><a href='#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6'>静态文件</a></li>
		<li><a href='#%E8%A7%86%E5%9B%BE%20/%20%E6%A8%A1%E6%9D%BF'>视图 / 模板</a></li>
		<ol class='level-2'>
			<li><a href='#Haml%E6%A8%A1%E6%9D%BF'>Haml模板</a></li>
			<li><a href='#Erb%E6%A8%A1%E6%9D%BF'>Erb模板</a></li>
			<li><a href='#Erubis'>Erubis</a></li>
			<li><a href='#Builder%20%E6%A8%A1%E6%9D%BF'>Builder 模板</a></li>
			<li><a href='#Nokogiri%20%E6%A8%A1%E6%9D%BF'>Nokogiri 模板</a></li>
			<li><a href='#Sass%20%E6%A8%A1%E6%9D%BF'>Sass 模板</a></li>
			<li><a href='#Scss%20%E6%A8%A1%E6%9D%BF'>Scss 模板</a></li>
			<li><a href='#Less%20%E6%A8%A1%E6%9D%BF'>Less 模板</a></li>
			<li><a href='#Liquid%20%E6%A8%A1%E6%9D%BF'>Liquid 模板</a></li>
			<li><a href='#Markdown%20%E6%A8%A1%E6%9D%BF'>Markdown 模板</a></li>
			<li><a href='#Textile%20%E6%A8%A1%E6%9D%BF'>Textile 模板</a></li>
			<li><a href='#RDoc%20%E6%A8%A1%E6%9D%BF'>RDoc 模板</a></li>
			<li><a href='#Radius%20%E6%A8%A1%E6%9D%BF'>Radius 模板</a></li>
			<li><a href='#Markaby%20%E6%A8%A1%E6%9D%BF'>Markaby 模板</a></li>
			<li><a href='#Slim%20%E6%A8%A1%E6%9D%BF'>Slim 模板</a></li>
			<li><a href='#Creole%20%E6%A8%A1%E6%9D%BF'>Creole 模板</a></li>
			<li><a href='#CoffeeScript%20%E6%A8%A1%E6%9D%BF'>CoffeeScript 模板</a></li>
			<li><a href='#%E5%B5%8C%E5%85%A5%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2'>嵌入模板字符串</a></li>
			<li><a href='#%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F'>在模板中访问变量</a></li>
			<li><a href='#%E5%86%85%E8%81%94%E6%A8%A1%E6%9D%BF'>内联模板</a></li>
			<li><a href='#%E5%85%B7%E5%90%8D%E6%A8%A1%E6%9D%BF'>具名模板</a></li>
			<li><a href='#%E5%85%B3%E8%81%94%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D'>关联文件扩展名</a></li>
			<li><a href='#%E6%B7%BB%E5%8A%A0%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E'>添加你自己的模版引擎</a></li>
		</ol>
		<li><a href='#%E8%BF%87%E6%BB%A4%E5%99%A8'>过滤器</a></li>
		<li><a href='#%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95'>辅助方法</a></li>
		<ol class='level-2'>
			<li><a href='#%E4%BD%BF%E7%94%A8%20Sessions'>使用 Sessions</a></li>
			<li><a href='#%E6%8C%82%E8%B5%B7'>挂起</a></li>
			<li><a href='#%E8%AE%A9%E8%B7%AF'>让路</a></li>
			<li><a href='#%E8%A7%A6%E5%8F%91%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1'>触发另一个路由</a></li>
			<li><a href='#%E8%AE%BE%E5%AE%9A%20%E6%B6%88%E6%81%AF%E4%BD%93%EF%BC%8C%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C%E6%B6%88%E6%81%AF%E5%A4%B4'>设定 消息体，状态码和消息头</a></li>
			<li><a href='#%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B'>媒体类型</a></li>
			<li><a href='#%E7%94%9F%E6%88%90%20URL'>生成 URL</a></li>
			<li><a href='#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91'>浏览器重定向</a></li>
			<li><a href='#%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6'>缓存控制</a></li>
			<li><a href='#%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6'>发送文件</a></li>
			<li><a href='#%E8%AE%BF%E9%97%AE%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1'>访问请求对象</a></li>
			<li><a href='#%E9%99%84%E4%BB%B6'>附件</a></li>
			<li><a href='#%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6'>查找模板文件</a></li>
		</ol>
		<li><a href='#%E9%85%8D%E7%BD%AE'>配置</a></li>
		<ol class='level-2'>
			<li><a href='#%E5%8F%AF%E9%80%89%E7%9A%84%E8%AE%BE%E7%BD%AE'>可选的设置</a></li>
		</ol>
		<li><a href='#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86'>错误处理</a></li>
		<ol class='level-2'>
			<li><a href='#%E6%9C%AA%E6%89%BE%E5%88%B0'>未找到</a></li>
			<li><a href='#%E9%94%99%E8%AF%AF'>错误</a></li>
		</ol>
		<li><a href='#Rack%20%E4%B8%AD%E9%97%B4%E4%BB%B6'>Rack 中间件</a></li>
		<li><a href='#%E6%B5%8B%E8%AF%95'>测试</a></li>
		<li><a href='#Sinatra::Base%20-%20%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%BA%93%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BA%94%E7%94%A8'>Sinatra::Base - 中间件，程序库和模块化应用</a></li>
		<ol class='level-2'>
			<li><a href='#%E6%A8%A1%E5%9D%97%E5%8C%96%20vs.%20%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%96%B9%E5%BC%8F'>模块化 vs. 传统的方式</a></li>
			<li><a href='#%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BA%94%E7%94%A8'>运行一个模块化应用</a></li>
			<li><a href='#%E4%BD%BF%E7%94%A8config.ru%E8%BF%90%E8%A1%8C%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8'>使用config.ru运行传统方式的应用</a></li>
			<li><a href='#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%20config.ru?'>什么时候用 config.ru?</a></li>
			<li><a href='#%E6%8A%8ASinatra%E5%BD%93%E6%88%90%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9D%A5%E4%BD%BF%E7%94%A8'>把Sinatra当成中间件来使用</a></li>
		</ol>
		<li><a href='#%E5%8F%98%E9%87%8F%E5%9F%9F%E5%92%8C%E7%BB%91%E5%AE%9A'>变量域和绑定</a></li>
		<ol class='level-2'>
			<li><a href='#%E5%BA%94%E7%94%A8/%E7%B1%BB%20%E5%8F%98%E9%87%8F%E5%9F%9F'>应用/类 变量域</a></li>
			<li><a href='#%E8%AF%B7%E6%B1%82/%E5%AE%9E%E4%BE%8B%20%E5%8F%98%E9%87%8F%E5%9F%9F'>请求/实例 变量域</a></li>
			<li><a href='#%E4%BB%A3%E7%90%86%E5%8F%98%E9%87%8F%E5%9F%9F'>代理变量域</a></li>
		</ol>
		<li><a href='#%E5%91%BD%E4%BB%A4%E8%A1%8C'>命令行</a></li>
		<li><a href='#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6'>必要条件</a></li>
		<li><a href='#%E7%B4%A7%E8%BF%BD%E5%89%8D%E6%B2%BF'>紧追前沿</a></li>
		<ol class='level-2'>
			<li><a href='#%E9%80%9A%E8%BF%87Bundler'>通过Bundler</a></li>
			<li><a href='#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84'>使用自己的</a></li>
			<li><a href='#%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85'>全局安装</a></li>
		</ol>
		<li><a href='#%E6%9B%B4%E5%A4%9A'>更多</a></li>
	</ol>
</div>



<p><em>注：本文档仅仅是英文版的翻译，会出现内容没有及时更新的情况发生。
如有不一致的地方，请以英文版为准。</em></p>

<p>Sinatra是一个基于Ruby语言，以最小精力为代价快速创建web应用为目的的DSL（
领域专属语言）：</p>

<pre># myapp.rb
require 'sinatra'

get '/' do
  'Hello world!'
end</pre>

<p>安装gem然后运行：</p>

<pre>gem install sinatra
ruby -rubygems myapp.rb</pre>

<p>在该地址查看： <a href="http://localhost:4567">localhost:4567</a></p>

<p>推荐同时运行<tt>gem install
thin</tt>，Sinatra会优先选择thin作为服务器。</p>

<a name='%E8%B7%AF%E7%94%B1'></a>
<h2>路由</h2>

<p>在Sinatra中，一个路由是一个HTTP方法与URL匹配范式的配对。
每个路由都与一个代码块关联：</p>

<pre>get '/' do
  .. 显示一些事物 ..
end

post '/' do
  .. 创建一些事物 ..
end

put '/' do
  .. 更新一些事物 ..
end

delete '/' do
  .. 消灭一些事物 ..
end

options '/' do
  .. 满足一些事物 ..
end</pre>

<p>路由按照它们被定义的顺序进行匹配。
第一个与请求匹配的路由会被调用。</p>

<p>路由范式可以包括具名参数，可通过<tt>params</tt>哈希表获得：</p>

<pre>get '/hello/:name' do
  # 匹配 &quot;GET /hello/foo&quot; 和 &quot;GET /hello/bar&quot;
  # params[:name] 的值是 'foo' 或者 'bar'
  &quot;Hello #{params[:name]}!&quot;
end</pre>

<p>你同样可以通过代码块参数获得具名参数：</p>

<pre>get '/hello/:name' do |n|
  &quot;Hello #{n}!&quot;
end</pre>

<p>路由范式也可以包含通配符参数，
可以通过<tt>params[:splat]</tt> 数组获得。</p>

<pre>get '/say/*/to/*' do
  # 匹配 /say/hello/to/world
  params[:splat] # =&gt; [&quot;hello&quot;, &quot;world&quot;]
end

get '/download/*.*' do
  # 匹配 /download/path/to/file.xml
  params[:splat] # =&gt; [&quot;path/to/file&quot;, &quot;xml&quot;]
end</pre>

<p>通过正则表达式匹配的路由：</p>

<pre>get %r{/hello/([\w]+)} do
  &quot;Hello, #{params[:captures].first}!&quot;
end</pre>

<p>或者使用代码块参数：</p>

<pre>get %r{/hello/([\w]+)} do |c|
  &quot;Hello, #{c}!&quot;
end</pre>

<a name='%E6%9D%A1%E4%BB%B6'></a>
<h3>条件</h3>

<p>路由也可以包含多样的匹配条件，比如user agent：</p>

<pre>get '/foo', :agent =&gt; /Songbird (\d\.\d)[\d\/]*?/ do
  &quot;你正在使用Songbird，版本是 #{params[:agent][0]}&quot;
end

get '/foo' do
  # 匹配除Songbird以外的浏览器
end</pre>

<p>其他可选的条件是 <tt>host_name</tt> 和 <tt>provides</tt>：</p>

<pre>get '/', :host_name =&gt; /^admin\./ do
  &quot;管理员区域，无权进入！&quot;
end

get '/', :provides =&gt; 'html' do
  haml :index
end

get '/', :provides =&gt; ['rss', 'atom', 'xml'] do
  builder :feed
end</pre>

<p>你也可以很轻松地定义自己的条件：</p>

<pre>set(:probability) { |value| condition { rand &lt;= value } }

get '/win_a_car', :probability =&gt; 0.1 do
  &quot;You won!&quot;
end

get '/win_a_car' do
  &quot;Sorry, you lost.&quot;
end</pre>

<a name='%E8%BF%94%E5%9B%9E%E5%80%BC'></a>
<h3>返回值</h3>

<p>路由代码块的返回值至少决定了返回给HTTP客户端的响应体，
或者至少决定了在Rack堆栈中的下一个中间件。
大多数情况下，将是一个字符串，就像上面的例子中的一样。
但是其他值也是可以接受的。</p>

<p>你可以返回任何对象，或者是一个合理的Rack响应， Rack
body对象或者HTTP状态码：</p>
<ul><li>
<p>一个包含三个元素的数组: <tt>[状态 (Fixnum), 头 (Hash),
响应体 (回应 #each)]</tt></p>
</li><li>
<p>一个包含两个元素的数组: <tt>[状态 (Fixnum), 响应体 (回应
#each)]</tt></p>
</li><li>
<p>一个能够回应 <tt>#each</tt> ，只传回字符串的对象</p>
</li><li>
<p>一个代表状态码的数字</p>
</li></ul>

<p>那样，我们可以轻松的实现例如流式传输的例子：</p>

<pre>class Stream
  def each
    100.times { |i| yield &quot;#{i}\n&quot; }
  end
end

get('/') { Stream.new }</pre>

<a name='%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E5%99%A8'></a>
<h3>自定义路由匹配器</h3>

<p>如上显示，Sinatra内置了对于使用字符串和正则表达式作为路由匹配的支持。
但是，它并没有只限于此。
你可以非常容易地定义你自己的匹配器:</p>

<pre>class AllButPattern
  Match = Struct.new(:captures)

  def initialize(except)
    @except   = except
    @captures = Match.new([])
  end

  def match(str)
    @captures unless @except === str
  end
end

def all_but(pattern)
  AllButPattern.new(pattern)
end

get all_but(&quot;/index&quot;) do
  # ...
end</pre>

<p>请注意上面的例子可能超工程了，
因为它也可以用更简单的方式表述:</p>

<pre>get // do
  pass if request.path_info == &quot;/index&quot;
  # ...
end</pre>

<p>或者，使用消极向前查找:</p>

<pre>get %r{^(?!/index$)} do
  # ...
end</pre>

<a name='%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6'></a>
<h2>静态文件</h2>

<p>静态文件是从 <tt>./public_folder</tt>
目录提供服务。你可以通过设置<tt>:public</tt>
选项设定一个不同的位置：</p>

<pre>set :public_folder, File.dirname(__FILE__) + '/static'</pre>

<p>请注意public目录名并没有被包含在URL之中。文件
<tt>./public/css/style.css</tt>是通过
<tt>http://example.com/css/style.css</tt>地址访问的。</p>

<a name='%E8%A7%86%E5%9B%BE%20/%20%E6%A8%A1%E6%9D%BF'></a>
<h2>视图 / 模板</h2>

<p>模板被假定直接位于<tt>./views</tt>目录。
要使用不同的视图目录：</p>

<pre>set :views, File.dirname(__FILE__) + '/templates'</pre>

<p>请记住一件非常重要的事情，你只可以通过符号引用模板，
即使它们在子目录下 （在这种情况下，使用
<tt>:'subdir/template'</tt>）。 你必须使用一个符号，
因为渲染方法会直接地渲染任何传入的字符串。</p>

<a name='Haml%E6%A8%A1%E6%9D%BF'></a>
<h3>Haml模板</h3>

<p>需要引入 <tt>haml</tt> gem/library以渲染 HAML 模板：</p>

<pre># 你需要在你的应用中引入 haml
require 'haml'

get '/' do
  haml :index
end</pre>

<p>渲染 <tt>./views/index.haml</tt>。</p>

<p><a
href="http://haml-lang.com/docs/yardoc/file.HAML_REFERENCE.html#options">Haml的选项</a>
可以通过Sinatra的配置全局设定， 参见 <a
href="http://www.sinatrarb.com/configuration.html">选项和配置</a>，
也可以个别的被覆盖。</p>

<pre>set :haml, {:format =&gt; :html5 } # 默认的Haml输出格式是 :xhtml

get '/' do
  haml :index, :haml_options =&gt; {:format =&gt; :html4 } # 被覆盖，变成:html4
end</pre>

<a name='Erb%E6%A8%A1%E6%9D%BF'></a>
<h3>Erb模板</h3>

<pre># 你需要在你的应用中引入 erb
require 'erb'

get '/' do
  erb :index
end</pre>

<p>渲染 <tt>./views/index.erb</tt></p>

<a name='Erubis'></a>
<h3>Erubis</h3>

<p>需要引入 <tt>erubis</tt> gem/library以渲染 erubis 模板：</p>

<pre># 你需要在你的应用中引入 erubis
require 'erubis'

get '/' do
  erubis :index
end</pre>

<p>渲染 <tt>./views/index.erubis</tt></p>

<p>使用Erubis代替Erb也是可能的:</p>

<pre>require 'erubis'
Tilt.register :erb, Tilt[:erubis]

get '/' do
  erb :index
end</pre>

<p>使用Erubis来渲染 <tt>./views/index.erb</tt>。</p>

<a name='Builder%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Builder 模板</h3>

<p>需要引入 <tt>builder</tt> gem/library 以渲染 builder templates：</p>

<pre># 需要在你的应用中引入builder
require 'builder'

get '/' do
  builder :index
end</pre>

<p>渲染 <tt>./views/index.builder</tt>。</p>

<a name='Nokogiri%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Nokogiri 模板</h3>

<p>需要引入 <tt>nokogiri</tt> gem/library 以渲染 nokogiri 模板：</p>

<pre># 需要在你的应用中引入 nokogiri
require 'nokogiri'

get '/' do
  nokogiri :index
end</pre>

<p>渲染 <tt>./views/index.nokogiri</tt>。</p>

<a name='Sass%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Sass 模板 </h3>

<p>需要引入 <tt>haml</tt> 或者 <tt>sass</tt> gem/library 以渲染 Sass
模板：</p>

<pre># 需要在你的应用中引入 haml 或者 sass 
require 'sass'

get '/stylesheet.css' do
  sass :stylesheet
end</pre>

<p>渲染 <tt>./views/stylesheet.sass</tt>。</p>

<p><a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Sass
的选项</a> 可以通过Sinatra选项全局设定， 参考 <a
href="http://www.sinatrarb.com/configuration.html">选项和配置（英文）</a>,
也可以在个体的基础上覆盖。</p>

<pre>set :sass, {:style =&gt; :compact } # 默认的 Sass 样式是 :nested

get '/stylesheet.css' do
  sass :stylesheet, :style =&gt; :expanded # 覆盖
end</pre>

<a name='Scss%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Scss 模板 </h3>

<p>需要引入 <tt>haml</tt> 或者 <tt>sass</tt> gem/library 来渲染 Scss
templates：</p>

<pre># 需要在你的应用中引入 haml 或者 sass
require 'sass'

get '/stylesheet.css' do
  scss :stylesheet
end</pre>

<p>渲染 <tt>./views/stylesheet.scss</tt>。</p>

<p><a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Scss的选项</a>
可以通过Sinatra选项全局设定， 参考 <a
href="http://www.sinatrarb.com/configuration.html">选项和配置（英文）</a>,
也可以在个体的基础上覆盖。</p>

<pre>set :scss, :style =&gt; :compact # default Scss style is :nested

get '/stylesheet.css' do
  scss :stylesheet, :style =&gt; :expanded # overridden
end</pre>

<a name='Less%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Less 模板 </h3>

<p>需要引入 <tt>less</tt> gem/library 以渲染 Less 模板：</p>

<pre># 需要在你的应用中引入 less
require 'less'

get '/stylesheet.css' do
  less :stylesheet
end</pre>

<p>渲染 <tt>./views/stylesheet.less</tt>。</p>

<a name='Liquid%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Liquid 模板 </h3>

<p>需要引入 <tt>liquid</tt> gem/library 来渲染 Liquid 模板：</p>

<pre># 需要在你的应用中引入 liquid
require 'liquid'

get '/' do
  liquid :index
end</pre>

<p>渲染 <tt>./views/index.liquid</tt>。</p>

<p>因为你不能在Liquid 模板中调用 Ruby 方法 (除了
<tt>yield</tt>) ， 你几乎总是需要传递locals给它：</p>

<pre>liquid :index, :locals =&gt; { :key =&gt; 'value' }</pre>

<a name='Markdown%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Markdown 模板</h3>

<p>需要引入 <tt>rdiscount</tt> gem/library 以渲染 Markdown 模板：</p>

<pre># 需要在你的应用中引入rdiscount
require &quot;rdiscount&quot;

get '/' do
  markdown :index
end</pre>

<p>渲染 <tt>./views/index.markdown</tt>  (<tt>md</tt> 和 <tt>mkd</tt>
也是合理的文件扩展名)。</p>

<p>在markdown中是不可以调用方法的，也不可以传递
locals给它。
你因此一般会结合其他的渲染引擎来使用它：</p>

<pre>erb :overview, :locals =&gt; { :text =&gt; markdown(:introduction) }</pre>

<p>请注意你也可以从其他模板中调用 markdown 方法：</p>

<pre>%h1 Hello From Haml!
%p= markdown(:greetings)</pre>

<p>既然你不能在Markdown中调用Ruby，你不能使用Markdown编写的布局。
不过，使用其他渲染引擎作为模版的布局是可能的，
通过传递<tt>:layout_engine</tt>选项:</p>

<pre>get '/' do
  markdown :index, :layout_engine =&gt; :erb
end</pre>

<p>这将会渲染 <tt>./views/index.md</tt> 并使用
<tt>./views/layout.erb</tt> 作为布局。</p>

<p>请记住你可以全局设定这个选项:</p>

<pre>set :markdown, :layout_engine =&gt; :haml, :layout =&gt; :post

get '/' do
  markdown :index
end</pre>

<p>这将会渲染 <tt>./views/index.markdown</tt> (和任何其他的
Markdown 模版) 并使用 <tt>./views/post.haml</tt> 作为布局.</p>

<p>也可能使用BlueCloth而不是RDiscount来解析Markdown文件:</p>

<pre>require 'bluecloth'

Tilt.register 'markdown', BlueClothTemplate
Tilt.register 'mkd',      BlueClothTemplate
Tilt.register 'md',       BlueClothTemplate

get '/' do
  markdown :index
end</pre>

<p>使用BlueCloth来渲染 <tt>./views/index.md</tt> 。</p>

<a name='Textile%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Textile 模板</h3>

<p>需要引入 <tt>RedCloth</tt> gem/library 以渲染 Textile 模板：</p>

<pre># 在你的应用中引入redcloth
require &quot;redcloth&quot;

get '/' do
  textile :index
end</pre>

<p>渲染 <tt>./views/index.textile</tt>。</p>

<p>在textile中是不可以调用方法的，也不可以传递
locals给它。
你因此一般会结合其他的渲染引擎来使用它：</p>

<pre>erb :overview, :locals =&gt; { :text =&gt; textile(:introduction) }</pre>

<p>请注意你也可以从其他模板中调用<tt>textile</tt>方法：</p>

<pre>%h1 Hello From Haml!
%p= textile(:greetings)</pre>

<p>既然你不能在Textile中调用Ruby，你不能使用Textile编写的布局。
不过，使用其他渲染引擎作为模版的布局是可能的，
通过传递<tt>:layout_engine</tt>选项:</p>

<pre>get '/' do
  textile :index, :layout_engine =&gt; :erb
end</pre>

<p>这将会渲染 <tt>./views/index.textile</tt> 并使用
<tt>./views/layout.erb</tt> 作为布局。</p>

<p>请记住你可以全局设定这个选项:</p>

<pre>set :textile, :layout_engine =&gt; :haml, :layout =&gt; :post

get '/' do
  textile :index
end</pre>

<p>这将会渲染 <tt>./views/index.textile</tt> (和任何其他的 Textile
模版) 并使用 <tt>./views/post.haml</tt> 作为布局.</p>

<a name='RDoc%20%E6%A8%A1%E6%9D%BF'></a>
<h3>RDoc 模板</h3>

<p>需要引入 <tt>RDoc</tt> gem/library 以渲染RDoc模板：</p>

<pre># 需要在你的应用中引入rdoc/markup/to_html
require &quot;rdoc&quot;
require &quot;rdoc/markup/to_html&quot;

get '/' do
  rdoc :index
end</pre>

<p>渲染 <tt>./views/index.rdoc</tt>。</p>

<p>在rdoc中是不可以调用方法的，也不可以传递locals给它。
你因此一般会结合其他的渲染引擎来使用它：</p>

<pre>erb :overview, :locals =&gt; { :text =&gt; rdoc(:introduction) }</pre>

<p>请注意你也可以从其他模板中调用<tt>rdoc</tt>方法：</p>

<pre>%h1 Hello From Haml!
%p= rdoc(:greetings)</pre>

<p>既然你不能在RDoc中调用Ruby，你不能使用RDoc编写的布局。
不过，使用其他渲染引擎作为模版的布局是可能的，
通过传递<tt>:layout_engine</tt>选项:</p>

<pre>get '/' do
  rdoc :index, :layout_engine =&gt; :erb
end</pre>

<p>这将会渲染 <tt>./views/index.rdoc</tt> 并使用
<tt>./views/layout.erb</tt> 作为布局。</p>

<p>请记住你可以全局设定这个选项:</p>

<pre>set :rdoc, :layout_engine =&gt; :haml, :layout =&gt; :post

get '/' do
  rdoc :index
end</pre>

<p>这将会渲染 <tt>./views/index.rdoc</tt> (和任何其他的 RDoc
模版) 并使用 <tt>./views/post.haml</tt> 作为布局.</p>

<a name='Radius%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Radius 模板</h3>

<p>需要引入 <tt>radius</tt> gem/library 以渲染 Radius 模板：</p>

<pre># 需要在你的应用中引入radius
require 'radius'

get '/' do
  radius :index
end</pre>

<p>渲染 <tt>./views/index.radius</tt>。</p>

<p>因为你不能在Radius 模板中调用 Ruby 方法 (除了
<tt>yield</tt>) ， 你几乎总是需要传递locals给它：</p>

<pre>radius :index, :locals =&gt; { :key =&gt; 'value' }</pre>

<a name='Markaby%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Markaby 模板 </h3>

<p>需要引入<tt>markaby</tt> gem/library以渲染Markaby模板：</p>

<pre>#需要在你的应用中引入 markaby
require 'markaby'

get '/' do
  markaby :index
end</pre>

<p>渲染 <tt>./views/index.mab</tt>。</p>

<p>你也可以使用嵌入的 Markaby:</p>

<pre>get '/' do
  markaby { h1 &quot;Welcome!&quot; }
end</pre>

<a name='Slim%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Slim 模板 </h3>

<p>需要引入 <tt>slim</tt> gem/library 来渲染 Slim 模板：</p>

<pre># 需要在你的应用中引入 slim
require 'slim'

get '/' do
  slim :index
end</pre>

<p>渲染 <tt>./views/index.slim</tt>。</p>

<a name='Creole%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Creole 模板 </h3>

<p>需要引入 <tt>creole</tt> gem/library 来渲染 Creole 模板：</p>

<pre># 需要在你的应用中引入 creole
require 'creole'

get '/' do
  creole :index
end</pre>

<p>渲染 <tt>./views/index.creole</tt>。</p>

<a name='CoffeeScript%20%E6%A8%A1%E6%9D%BF'></a>
<h3>CoffeeScript 模板</h3>

<p>需要引入 <tt>coffee-script</tt> gem/library
并至少满足下面条件一项 以执行Javascript:</p>
<ul><li>
<p><tt>node</tt> (来自 Node.js) 在你的路径中</p>
</li><li>
<p>你正在运行 OSX</p>
</li><li>
<p><tt>therubyracer</tt> gem/library</p>
</li></ul>

<p>请察看 <a
href="http://github.com/josh/ruby-coffee-script">github.com/josh/ruby-coffee-script</a>
获取更新的选项。</p>

<p>现在你可以渲染 CoffeeScript 模版了:</p>

<pre># 需要在你的应用中引入coffee-script
require 'coffee-script'

get '/application.js' do
  coffee :application
end</pre>

<p>渲染 <tt>./views/application.coffee</tt>。</p>

<a name='%E5%B5%8C%E5%85%A5%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2'></a>
<h3>嵌入模板字符串</h3>

<pre>get '/' do
  haml '%div.title Hello World'
end</pre>

<p>渲染嵌入模板字符串。</p>

<a name='%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F'></a>
<h3>在模板中访问变量</h3>

<p>模板和路由执行器在同样的上下文求值。
在路由执行器中赋值的实例变量可以直接被模板访问。</p>

<pre>get '/:id' do
  @foo = Foo.find(params[:id])
  haml '%h1= @foo.name'
end</pre>

<p>或者，显式地指定一个本地变量的哈希：</p>

<pre>get '/:id' do
  foo = Foo.find(params[:id])
  haml '%h1= foo.name', :locals =&gt; { :foo =&gt; foo }
end</pre>

<p>典型的使用情况是在别的模板中按照局部模板的方式来渲染。</p>

<a name='%E5%86%85%E8%81%94%E6%A8%A1%E6%9D%BF'></a>
<h3>内联模板</h3>

<p>模板可以在源文件的末尾定义：</p>

<pre>require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Hello world!!!!!</pre>

<p>注意：引入sinatra的源文件中定义的内联模板才能被自动载入。
如果你在其他源文件中有内联模板，
需要显式执行调用<tt>enable :inline_templates</tt>。</p>

<a name='%E5%85%B7%E5%90%8D%E6%A8%A1%E6%9D%BF'></a>
<h3>具名模板</h3>

<p>模板可以通过使用顶层 <tt>template</tt> 方法定义：</p>

<pre>template :layout do
  &quot;%html\n  =yield\n&quot;
end

template :index do
  '%div.title Hello World!'
end

get '/' do
  haml :index
end</pre>

<p>如果存在名为"layout"的模板，该模板会在每个模板渲染的时候被使用。
你可以单独地通过传送 <tt>:layout =&gt; false</tt>来禁用，
或者通过<tt>set :haml, :layout =&gt; false</tt>来禁用他们。</p>

<pre>get '/' do
  haml :index, :layout =&gt; !request.xhr?
end</pre>

<a name='%E5%85%B3%E8%81%94%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D'></a>
<h3>关联文件扩展名</h3>

<p>为了关联一个文件扩展名到一个模版引擎，使用
<tt>Tilt.register</tt>。比如，如果你喜欢使用 <tt>tt</tt>
作为Textile模版的扩展名，你可以这样做:</p>

<pre>Tilt.register :tt, Tilt[:textile]</pre>

<a name='%E6%B7%BB%E5%8A%A0%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E'></a>
<h3>添加你自己的模版引擎</h3>

<p>首先，通过Tilt注册你自己的引擎，然后创建一个渲染方法:</p>

<pre>Tilt.register :myat, MyAwesomeTemplateEngine

helpers do
  def myat(*args) render(:myat, *args) end
end

get '/' do
  myat :index
end</pre>

<p>渲染 <tt>./views/index.myat</tt>。察看 <a
href="https://github.com/rtomayko/tilt">github.com/rtomayko/tilt</a> 
来更多了解Tilt.</p>

<a name='%E8%BF%87%E6%BB%A4%E5%99%A8'></a>
<h2>过滤器</h2>

<p>前置过滤器在每个请求前，在请求的上下文环境中被执行，
而且可以修改请求和响应。
在过滤器中设定的实例变量可以被路由和模板访问：</p>

<pre>before do
  @note = 'Hi!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @note #=&gt; 'Hi!'
  params[:splat] #=&gt; 'bar/baz'
end</pre>

<p>后置过滤器在每个请求之后，在请求的上下文环境中执行，
而且可以修改请求和响应。
在前置过滤器和路由中设定的实例变量可以被后置过滤器访问：</p>

<pre>after do
  puts response.status
end</pre>

<p>请注意：除非你显式使用 <tt>body</tt>
方法，而不是在路由中直接返回字符串，
消息体在后置过滤器是不可用的，
因为它在之后才会生成。</p>

<p>过滤器可以可选地带有范式，
只有请求路径满足该范式时才会执行：</p>

<pre>before '/protected/*' do
  authenticate!
end

after '/create/:slug' do |slug|
  session[:last_slug] = slug
end</pre>

<p>和路由一样，过滤器也可以带有条件:</p>

<pre>before :agent =&gt; /Songbird/ do
  # ...
end

after '/blog/*', :host_name =&gt; 'example.com' do
  # ...
end</pre>

<a name='%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95'></a>
<h2>辅助方法</h2>

<p>使用顶层的 <tt>helpers</tt> 方法来定义辅助方法，
以便在路由处理器和模板中使用：</p>

<pre>helpers do
  def bar(name)
    &quot;#{name}bar&quot;
  end
end

get '/:name' do
  bar(params[:name])
end</pre>

<a name='%E4%BD%BF%E7%94%A8%20Sessions'></a>
<h3>使用 Sessions</h3>

<p>Session被用来在请求之间保持状态。如果被激活，每一个用户会话
对应有一个session哈希:</p>

<pre>enable :sessions

get '/' do
  &quot;value = &quot; &lt;&lt; session[:value].inspect
end

get '/:value' do
  session[:value] = params[:value]
end</pre>

<p>请注意 <tt>enable :sessions</tt>
实际上保存所有的数据在一个cookie之中。
这可能不会总是做你想要的（比如，保存大量的数据会增加你的流量）。
你可以使用任何的Rack session中间件，为了这么做，
*不要*调用 <tt>enable :sessions</tt>，而是
按照自己的需要引入你的中间件：</p>

<pre>use Rack::Session::Pool, :expire_after =&gt; 2592000

get '/' do
  &quot;value = &quot; &lt;&lt; session[:value].inspect
end

get '/:value' do
  session[:value] = params[:value]
end</pre>

<a name='%E6%8C%82%E8%B5%B7'></a>
<h3>挂起</h3>

<p>要想直接地停止请求，在过滤器或者路由中使用：</p>

<pre>halt</pre>

<p>你也可以指定挂起时的状态码：</p>

<pre>halt 410</pre>

<p>或者消息体：</p>

<pre>halt 'this will be the body'</pre>

<p>或者两者;</p>

<pre>halt 401, 'go away!'</pre>

<p>也可以带消息头：</p>

<pre>halt 402, {'Content-Type' =&gt; 'text/plain'}, 'revenge'</pre>

<a name='%E8%AE%A9%E8%B7%AF'></a>
<h3>让路</h3>

<p>一个路由可以放弃处理，将处理让给下一个匹配的路由，使用
<tt>pass</tt>：</p>

<pre>get '/guess/:who' do
  pass unless params[:who] == 'Frank'
  'You got me!'
end

get '/guess/*' do
  'You missed!'
end</pre>

<p>路由代码块被直接退出，控制流继续前进到下一个匹配的路由。
如果没有匹配的路由，将返回404。</p>

<a name='%E8%A7%A6%E5%8F%91%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1'></a>
<h3>触发另一个路由</h3>

<p>有些时候，<tt>pass</tt>
并不是你想要的，你希望得到的是另一个路由的结果
。简单的使用 <tt>call</tt> 可以做到这一点:</p>

<pre>get '/foo' do
  status, headers, body = call env.merge(&quot;PATH_INFO&quot; =&gt; '/bar')
  [status, headers, body.map(&amp;:upcase)]
end

get '/bar' do
  &quot;bar&quot;
end</pre>

<p>请注意在以上例子中，你可以更加简化测试并增加性能，只要简单的移动</p>

<pre>&lt;tt&gt;&quot;bar&quot;&lt;/tt&gt;到一个被&lt;tt&gt;/foo&lt;/tt&gt;</pre>

<p>和 <tt>/bar</tt>同时使用的helper。</p>

<p>如果你希望请求被发送到同一个应用，而不是副本，
使用 <tt>call!</tt> 而不是 <tt>call</tt>.</p>

<p>察看 Rack specification 如果你想更多了解 <tt>call</tt>.</p>

<a name='%E8%AE%BE%E5%AE%9A%20%E6%B6%88%E6%81%AF%E4%BD%93%EF%BC%8C%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C%E6%B6%88%E6%81%AF%E5%A4%B4'></a>
<h3>设定 消息体，状态码和消息头</h3>

<p>通过路由代码块的返回值来设定状态码和消息体不仅是可能的，而且是推荐的。
但是，在某些场景中你可能想在作业流程中的特定点上设置消息体。
你可以通过 <tt>body</tt> 辅助方法这么做。
如果你这样做了，
你可以在那以后使用该方法获得消息体:</p>

<pre>get '/foo' do
  body &quot;bar&quot;
end

after do
  puts body
end</pre>

<p>也可以传一个代码块给
<tt>body</tt>，它将会被Rack处理器执行（
这将可以被用来实现streaming，参见“返回值”）。</p>

<p>和消息体类似，你也可以设定状态码和消息头:</p>

<pre>get '/foo' do
  status 418
  headers \
    &quot;Allow&quot;   =&gt; &quot;BREW, POST, GET, PROPFIND, WHEN&quot;,
    &quot;Refresh&quot; =&gt; &quot;Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt&quot;
  body &quot;I'm a tea pot!&quot;
end</pre>

<p>如同 <tt>body</tt>, 不带参数的 <tt>headers</tt> 和 <tt>status</tt>
可以用来访问 他们你的当前值.</p>

<a name='%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B'></a>
<h3>媒体类型</h3>

<p>当使用 <tt>send_file</tt>
或者静态文件的场合，你的媒体类型可能
Sinatra并不理解。使用 <tt>mime_type</tt>
通过文件扩展名来注册它们：</p>

<pre>mime_type :foo, 'text/foo'</pre>

<p>你也可以通过 <tt>content_type</tt> 辅助方法使用：</p>

<pre>get '/' do
  content_type :foo
  &quot;foo foo foo&quot;
end</pre>

<a name='%E7%94%9F%E6%88%90%20URL'></a>
<h3>生成 URL</h3>

<p>为了生成URL，你需要使用 <tt>url</tt> 辅助方法，
例如，在Haml中:</p>

<pre>%a{:href =&gt; url('/foo')} foo</pre>

<p>它会根据反向代理和Rack路由，如果有的话，来计算生成的URL。</p>

<p>这个方法还有一个别名 <tt>to</tt> (见下面的例子).</p>

<a name='%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91'></a>
<h3>浏览器重定向</h3>

<p>你可以通过 <tt>redirect</tt> 辅助方法触发浏览器重定向:</p>

<pre>get '/foo' do
  redirect to('/bar')
end</pre>

<p>任何额外的参数都会被以 <tt>halt</tt>相同的方式来处理:</p>

<pre>redirect to('/bar'), 303
redirect 'http://google.com', 'wrong place, buddy'</pre>

<p>你可以方便的通过 <tt>redirect
back</tt>把用户重定向到来自的页面:</p>

<pre>get '/foo' do
  &quot;&lt;a href='/bar'&gt;do something&lt;/a&gt;&quot;
end

get '/bar' do
  do_something
  redirect back
end</pre>

<p>为了传递参数给redirect，或者加入query:</p>

<pre>redirect to('/bar?sum=42')</pre>

<p>或者使用session:</p>

<pre>enable :sessions

get '/foo' do
  session[:secret] = 'foo'
  redirect to('/bar')
end

get '/bar' do
  session[:secret]
end</pre>

<a name='%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6'></a>
<h3>缓存控制</h3>

<p>正确地设定消息头是恰当的HTTP缓存的基础。</p>

<p>你可以方便的设定 Cache-Control 消息头，像这样:</p>

<pre>get '/' do
  cache_control :public
  &quot;cache it!&quot;
end</pre>

<p>核心提示: 在前置过滤器中设定缓存.</p>

<pre>before do
  cache_control :public, :must_revalidate, :max_age =&gt; 60
end</pre>

<p>如果你正在用 <tt>expires</tt> 辅助方法设定对应的消息头
<tt>Cache-Control</tt> 会自动设定：</p>

<pre>before do
  expires 500, :public, :must_revalidate
end</pre>

<p>为了合适地使用缓存，你应该考虑使用 <tt>etag</tt> 和
<tt>last_modified</tt>方法。.
推荐在执行繁重任务*之前*使用这些helpers，
他们会立刻发送响应，如果客户端在缓存中已经有了当前版本。</p>

<pre>get '/article/:id' do
  @article = Article.find params[:id]
  last_modified @article.updated_at
  etag @article.sha1
  erb :article
end</pre>

<p>使用 <a
href="http://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation">weak
ETag</a> 也是有可能的:</p>

<pre>etag @article.sha1, :weak</pre>

<p>这些辅助方法并不会为你做任何缓存，而是将必要的信息传送给你的缓存
如果你在寻找缓存的快速解决方案，试试 <a
href="http://rtomayko.github.com/rack-cache/">rack-cache</a>:</p>

<pre>require &quot;rack/cache&quot;
require &quot;sinatra&quot;

use Rack::Cache

get '/' do
  cache_control :public, :max_age =&gt; 36000
  sleep 5
  &quot;hello&quot;
end</pre>

<a name='%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6'></a>
<h3>发送文件</h3>

<p>为了发送文件，你可以使用 <tt>send_file</tt> 辅助方法:</p>

<pre>get '/' do
  send_file 'foo.png'
end</pre>

<p>也可以带一些选项:</p>

<pre>send_file 'foo.png', :type =&gt; :jpg</pre>

<p>可用的选项有:</p>
<dl class="rdoc-list"><dt>filename</dt>
<dd>
<p>响应中的文件名，默认是真实文件的名字。</p>
</dd><dt>last_modified</dt>
<dd>
<p>Last-Modified
消息头的值，默认是文件的mtime（修改时间）。</p>
</dd><dt>type</dt>
<dd>
<p>使用的内容类型，如果没有会从文件扩展名猜测。</p>
</dd><dt>disposition</dt>
<dd>
<p>用于 Content-Disposition，可能的包括： <tt>nil</tt> (默认),
<tt>:attachment</tt> 和 <tt>:inline</tt></p>
</dd><dt>length</dt>
<dd>
<p>Content-Length 的值，默认是文件的大小。</p>
</dd></dl>

<p>如果Rack处理器支持，Ruby进程除streaming以外的方式会被使用。
如果你使用这个辅助方法， Sinatra会自动处理range请求。</p>

<a name='%E8%AE%BF%E9%97%AE%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1'></a>
<h3>访问请求对象</h3>

<p>传入的请求对象可以在请求层（过滤器，路由，错误处理）
通过 <tt>request</tt> 方法被访问：</p>

<pre># 在 http://example.com/example 上运行的应用
get '/foo' do
  request.body              # 被客户端设定的请求体（见下）
  request.scheme            # &quot;http&quot;
  request.script_name       # &quot;/example&quot;
  request.path_info         # &quot;/foo&quot;
  request.port              # 80
  request.request_method    # &quot;GET&quot;
  request.query_string      # &quot;&quot;
  request.content_length    # request.body的长度
  request.media_type        # request.body的媒体类型
  request.host              # &quot;example.com&quot;
  request.get?              # true (其他动词也具有类似方法)
  request.form_data?        # false
  request[&quot;SOME_HEADER&quot;]    # SOME_HEADER header的值
  request.referrer          # 客户端的referrer 或者 '/'
  request.user_agent        # user agent (被 :agent 条件使用)
  request.cookies           # 浏览器 cookies 哈希
  request.xhr?              # 这是否是ajax请求？
  request.url               # &quot;http://example.com/example/foo&quot;
  request.path              # &quot;/example/foo&quot;
  request.ip                # 客户端IP地址
  request.secure?           # false（如果是ssl则为true）
  request.forwarded?        # true （如果是运行在反向代理之后）
  request.env               # Rack中使用的未处理的env哈希
end</pre>

<p>一些选项，例如 <tt>script_name</tt> 或者 <tt>path_info</tt> 
也是可写的：</p>

<pre>before { request.path_info = &quot;/&quot; }

get &quot;/&quot; do
  &quot;all requests end up here&quot;
end</pre>

<p><tt>request.body</tt> 是一个IO或者StringIO对象：</p>

<pre>post &quot;/api&quot; do
  request.body.rewind  # 如果已经有人读了它
  data = JSON.parse request.body.read
  &quot;Hello #{data['name']}!&quot;
end</pre>

<a name='%E9%99%84%E4%BB%B6'></a>
<h3>附件</h3>

<p>你可以使用 <tt>attachment</tt> 辅助方法来告诉浏览器响应
应当被写入磁盘而不是在浏览器中显示。</p>

<pre>get '/' do
  attachment
  &quot;store it!&quot;
end</pre>

<p>你也可以传递一个文件名:</p>

<pre>get '/' do
  attachment &quot;info.txt&quot;
  &quot;store it!&quot;
end</pre>

<a name='%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6'></a>
<h3>查找模板文件</h3>

<p><tt>find_template</tt> 辅助方法被用于在渲染时查找模板文件:</p>

<pre>find_template settings.views, 'foo', Tilt[:haml] do |file|
  puts &quot;could be #{file}&quot;
end</pre>

<p>这并不是很有用。但是在你需要重载这个方法
来实现你自己的查找机制的时候有用。
比如，如果你想支持多于一个视图目录:</p>

<pre>set :views, ['views', 'templates']

helpers do
  def find_template(views, name, engine, &amp;block)
    Array(views).each { |v| super(v, name, engine, &amp;block) }
  end
end</pre>

<p>另一个例子是为不同的引擎使用不同的目录:</p>

<pre>set :views, :sass =&gt; 'views/sass', :haml =&gt; 'templates', :default =&gt; 'views'

helpers do
  def find_template(views, name, engine, &amp;block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:default]
    super(folder, name, engine, &amp;block)
  end
end</pre>

<p>你可以很容易地包装成一个扩展然后与他人分享！</p>

<p>请注意 <tt>find_template</tt> 并不会检查文件真的存在，
而是对任何可能的路径调用给入的代码块。这并不会带来性能问题，
因为 <tt>render</tt> 会在找到文件的时候马上使用
<tt>break</tt> 。
同样的，模板的路径（和内容）会在除development
mode以外的场合 被缓存。你应该时刻提醒自己这一点，
如果你真的想写一个非常疯狂的方法。</p>

<a name='%E9%85%8D%E7%BD%AE'></a>
<h2>配置</h2>

<p>运行一次，在启动的时候，在任何环境下：</p>

<pre>configure do
  # setting one option
  set :option, 'value'

  # setting multiple options
  set :a =&gt; 1, :b =&gt; 2

  # same as `set :option, true`
  enable :option

  # same as `set :option, false`
  disable :option

  # you can also have dynamic settings with blocks
  set(:css_dir) { File.join(views, 'css') }
end</pre>

<p>只当环境 (RACK_ENV environment 变量) 被设定为
<tt>:production</tt>的时候运行：</p>

<pre>configure :production do
  ...
end</pre>

<p>当环境被设定为 <tt>:production</tt> 或者
<tt>:test</tt>的时候运行：</p>

<pre>configure :production, :test do
  ...
end</pre>

<p>你可以使用 <tt>settings</tt> 获得这些配置:</p>

<pre>configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # =&gt; true
  settings.foo  # =&gt; 'bar'
  ...
end</pre>

<a name='%E5%8F%AF%E9%80%89%E7%9A%84%E8%AE%BE%E7%BD%AE'></a>
<h3>可选的设置</h3>
<dl class="rdoc-list"><dt>absolute_redirects</dt>
<dd>
<p>如果被禁用，Sinatra会允许使用相对路径重定向，
但是，Sinatra就不再遵守 RFC 2616标准 (HTTP 1.1),
该标准只允许绝对路径重定向。</p>

<p>如果你的应用运行在一个未恰当设置的反向代理之后，
你需要启用这个选项。注意 <tt>url</tt> 辅助方法
仍然会生成绝对 URL，除非你传入 <tt>false</tt>
作为第二参数。</p>

<p>默认禁用。</p>
</dd><dt>add_charsets</dt>
<dd>
<p>设定 <tt>content_type</tt> 辅助方法会
自动加上字符集信息的多媒体类型。</p>

<p>你应该添加而不是覆盖这个选项:</p>

<pre>settings.add_charsets &lt;&lt; &quot;application/foobar&quot;</pre>
</dd><dt>app_file</dt>
<dd>
<p>主应用文件，用来检测项目的根路径，
views和public文件夹和内联模板。</p>
</dd><dt>bind</dt>
<dd>
<p>绑定的IP 地址 (默认: 0.0.0.0)。
仅对于内置的服务器有用。</p>
</dd><dt>default_encoding</dt>
<dd>
<p>默认编码 (默认为 <tt>&quot;utf-8&quot;</tt>)。</p>
</dd><dt>dump_errors</dt>
<dd>
<p>在log中显示错误。</p>
</dd><dt>environment</dt>
<dd>
<p>当前环境，默认是 <tt>ENV['RACK_ENV']</tt>， 或者
<tt>&quot;development&quot;</tt> 如果不可用。</p>
</dd><dt>logging</dt>
<dd>
<p>使用logger</p>
</dd><dt>lock</dt>
<dd>
<p>对每一个请求放置一个锁， 只使用进程并发处理请求。</p>

<p>如果你的应用不是线程安全则需启动。 默认禁用。</p>
</dd><dt>method_override</dt>
<dd>
<p>使用 <tt>_method</tt> 魔法以允许在旧的浏览器中在
表单中使用 put/delete 方法</p>
</dd><dt>port</dt>
<dd>
<p>监听的端口号。只对内置服务器有用。</p>
</dd><dt>prefixed_redirects</dt>
<dd>
<p>是否添加 <tt>request.script_name</tt> 到
重定向请求，如果没有设定绝对路径。那样的话
<tt>redirect '/foo'</tt> 会和 <tt>redirect
to('/foo')</tt>起相同作用。默认禁用。</p>
</dd><dt>public_folder</dt>
<dd>
<p>public文件夹的位置。</p>
</dd><dt>reload_templates</dt>
<dd>
<p>是否每个请求都重新载入模板。 在development mode和 Ruby
1.8.6 中被企业（用来 消除一个Ruby内存泄漏的bug）。</p>
</dd><dt>root</dt>
<dd>
<p>项目的根目录。</p>
</dd><dt>raise_errors</dt>
<dd>
<p>抛出异常（应用会停下）。</p>
</dd><dt>run</dt>
<dd>
<p>如果启用，Sinatra会开启web服务器。
如果使用rackup或其他方式则不要启用。</p>
</dd><dt>running</dt>
<dd>
<p>内置的服务器在运行吗？ 不要修改这个设置！</p>
</dd><dt>server</dt>
<dd>
<p>服务器，或用于内置服务器的列表。 默认是 ['thin',
'mongrel', 'webrick'], 顺序表明了 优先级。</p>
</dd><dt>sessions</dt>
<dd>
<p>开启基于cookie的sesson。</p>
</dd><dt>show_exceptions</dt>
<dd>
<p>在浏览器中显示一个stack trace。</p>
</dd><dt>static</dt>
<dd>
<p>Sinatra是否处理静态文件。 当服务器能够处理则禁用。
禁用会增强性能。 默认开启。</p>
</dd><dt>views</dt>
<dd>
<p>views 文件夹。</p>
</dd></dl>

<a name='%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86'></a>
<h2>错误处理</h2>

<p>错误处理在与路由和前置过滤器相同的上下文中运行，
这意味着你可以使用许多好东西，比如 <tt>haml</tt>,
<tt>erb</tt>, <tt>halt</tt>，等等。</p>

<a name='%E6%9C%AA%E6%89%BE%E5%88%B0'></a>
<h3>未找到</h3>

<p>当一个 <tt>Sinatra::NotFound</tt> 错误被抛出的时候，
或者响应状态码是404，<tt>not_found</tt> 处理器会被调用：</p>

<pre>not_found do
  'This is nowhere to be found'
end</pre>

<a name='%E9%94%99%E8%AF%AF'></a>
<h3>错误</h3>

<p><tt>error</tt>
处理器，在任何路由代码块或者过滤器抛出异常的时候会被调用。
异常对象可以通过<tt>sinatra.error</tt> Rack 变量获得：</p>

<pre>error do
  'Sorry there was a nasty error - ' + env['sinatra.error'].name
end</pre>

<p>自定义错误：</p>

<pre>error MyCustomError do
  'So what happened was...' + env['sinatra.error'].message
end</pre>

<p>那么，当这个发生的时候：</p>

<pre>get '/' do
  raise MyCustomError, 'something bad'
end</pre>

<p>你会得到：</p>

<pre>So what happened was... something bad</pre>

<p>另一种替代方法是，为一个状态码安装错误处理器：</p>

<pre>error 403 do
  'Access forbidden'
end

get '/secret' do
  403
end</pre>

<p>或者一个范围：</p>

<pre>error 400..510 do
  'Boom'
end</pre>

<p>在运行在development环境下时，Sinatra会安装特殊的
<tt>not_found</tt> 和 <tt>error</tt> 处理器。</p>

<a name='Rack%20%E4%B8%AD%E9%97%B4%E4%BB%B6'></a>
<h2>Rack 中间件</h2>

<p>Sinatra 依靠 <a href="http://rack.rubyforge.org/">Rack</a>, 
一个面向Ruby web框架的最小标准接口。
Rack的一个最有趣的面向应用开发者的能力是支持“中间件”——坐落在服务器和你的应用之间，
监视 并/或 操作HTTP请求/响应以
提供多样类型的常用功能。</p>

<p>Sinatra 让建立Rack中间件管道异常简单， 通过顶层的
<tt>use</tt> 方法：</p>

<pre>require 'sinatra'
require 'my_custom_middleware'

use Rack::Lint
use MyCustomMiddleware

get '/hello' do
  'Hello World'
end</pre>

<p><tt>use</tt> 的语义和在 <a
href="http://rack.rubyforge.org/doc/classes/Rack/Builder.html">Rack::Builder</a>
DSL(在rack文件中最频繁使用)中定义的完全一样。例如，<tt>use</tt>
方法接受 多个/可变 参数，包括代码块：</p>

<pre>use Rack::Auth::Basic do |username, password|
  username == 'admin' &amp;&amp; password == 'secret'
end</pre>

<p>Rack中分布有多样的标准中间件，针对日志，
调试，URL路由，认证和session处理。
Sinatra会自动使用这里面的大部分组件，
所以你一般不需要显示地 <tt>use</tt> 他们。</p>

<a name='%E6%B5%8B%E8%AF%95'></a>
<h2>测试</h2>

<p>Sinatra的测试可以使用任何基于Rack的测试程序库或者框架来编写。
<a href="http://gitrdoc.com/brynary/rack-test">Rack::Test</a>
是推荐候选：</p>

<pre>require 'my_sinatra_app'
require 'test/unit'
require 'rack/test'

class MyAppTest &lt; Test::Unit::TestCase
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_my_default
    get '/'
    assert_equal 'Hello World!', last_response.body
  end

  def test_with_params
    get '/meet', :name =&gt; 'Frank'
    assert_equal 'Hello Frank!', last_response.body
  end

  def test_with_rack_env
    get '/', {}, 'HTTP_USER_AGENT' =&gt; 'Songbird'
    assert_equal &quot;You're using Songbird!&quot;, last_response.body
  end
end</pre>

<p>请注意: 内置的 Sinatra::Test 模块和 Sinatra::TestHarness 类 在
0.9.2 版本已废弃。</p>

<a name='Sinatra::Base%20-%20%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%BA%93%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BA%94%E7%94%A8'></a>
<h2>Sinatra::Base - 中间件，程序库和模块化应用</h2>

<p>把你的应用定义在顶层，对于微型应用这会工作得很好，
但是在构建可复用的组件时候会带来客观的不利，
比如构建Rack中间件，Rails
metal，带有服务器组件的简单程序库，
或者甚至是Sinatra扩展。顶层的DSL污染了Object命名空间，
并假定了一个微型应用风格的配置 (例如,
单一的应用文件， ./public 和 ./views
目录，日志，异常细节页面，等等）。 这时应该让
Sinatra::Base 走到台前了：</p>

<pre>require 'sinatra/base'

class MyApp &lt; Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Hello world!'
  end
end</pre>

<p>Sinatra::Base子类可用的方法实际上就是通过顶层 DSL
可用的方法。
大部分顶层应用可以通过两个改变转换成Sinatra::Base组件：</p>
<ul><li>
<p>你的文件应当引入 <tt>sinatra/base</tt> 而不是 <tt>sinatra</tt>;
否则，所有的Sinatra的 DSL 方法将会被引进到
主命名空间。</p>
</li><li>
<p>把你的应用的路由，错误处理，过滤器和选项放在
一个Sinatra::Base的子类中。</p>
</li></ul>

<p><tt>+Sinatra::Base+</tt>
是一张白纸。大部分的选项默认是禁用的，
包含内置的服务器。参见 <a
href="http://sinatra.github.com/configuration.html">选项和配置</a>
查看可用选项的具体细节和他们的行为。</p>

<a name='%E6%A8%A1%E5%9D%97%E5%8C%96%20vs.%20%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%96%B9%E5%BC%8F'></a>
<h3>模块化 vs. 传统的方式</h3>

<p>与通常的认识相反，传统的方式没有任何错误。
如果它适合你的应用，你不需要转换到模块化的应用。</p>

<p>和模块化方式相比只有两个缺点:</p>
<ul><li>
<p>你对每个Ruby进程只能定义一个Sinatra应用，如果你需要更多，
切换到模块化方式。</p>
</li><li>
<p>传统方式使用代理方法污染了 Object 。如果你打算
把你的应用封装进一个 library/gem，转换到模块化方式。</p>
</li></ul>

<p>没有任何原因阻止你混合模块化和传统方式。</p>

<p>如果从一种转换到另一种，你需要注意settings中的
一些微小的不同:</p>

<pre>Setting             Classic                 Modular

app_file            file loading sinatra    nil
run                 $0 == app_file          false
logging             true                    false
method_override     true                    false
inline_templates    true                    false</pre>

<a name='%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BA%94%E7%94%A8'></a>
<h3>运行一个模块化应用</h3>

<p>有两种方式运行一个模块化应用，使用 <tt>run!</tt>来运行:</p>

<pre># my_app.rb
require 'sinatra/base'

class MyApp &lt; Sinatra::Base
  # ... app code here ...

  # start the server if ruby file executed directly
  run! if app_file == $0
end</pre>

<p>运行:</p>

<pre>ruby my_app.rb</pre>

<p>或者使用一个 <tt>config.ru</tt>，允许你使用任何Rack处理器:</p>

<pre># config.ru
require './my_app'
run MyApp</pre>

<p>运行:</p>

<pre>rackup -p 4567</pre>

<a name='%E4%BD%BF%E7%94%A8config.ru%E8%BF%90%E8%A1%8C%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8'></a>
<h3>使用config.ru运行传统方式的应用</h3>

<p>编写你的应用:</p>

<pre># app.rb
require 'sinatra'

get '/' do
  'Hello world!'
end</pre>

<p>加入相应的 <tt>config.ru</tt>:</p>

<pre>require './app'
run Sinatra::Application</pre>

<a name='%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%20config.ru?'></a>
<h3>什么时候用 config.ru?</h3>

<p>以下情况你可能需要使用 <tt>config.ru</tt>:</p>
<ul><li>
<p>你要使用不同的 Rack 处理器部署 (Passenger, Unicorn, Heroku,
...).</p>
</li><li>
<p>你想使用一个或者多个 <tt>Sinatra::Base</tt>的子类.</p>
</li><li>
<p>你只想把Sinatra当作中间件使用，而不是端点。</p>
</li></ul>

<p><b>你并不需要切换到<tt>config.ru</tt>仅仅因为你切换到模块化方式，
你同样不需要切换到模块化方式， 仅仅因为要运行
<tt>config.ru</tt>.</b></p>

<a name='%E6%8A%8ASinatra%E5%BD%93%E6%88%90%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9D%A5%E4%BD%BF%E7%94%A8'></a>
<h3>把Sinatra当成中间件来使用</h3>

<p>不仅Sinatra有能力使用其他的Rack中间件，任何Sinatra
应用程序都可以反过来自身被当作中间件，被加在任何Rack端点前面。
这个端点可以是任何Sinatra应用，或者任何基于Rack的应用程序
(Rails/Ramaze/Camping/...)。</p>

<pre>require 'sinatra/base'

class LoginScreen &lt; Sinatra::Base
  enable :sessions

  get('/login') { haml :login }

  post('/login') do
    if params[:name] = 'admin' and params[:password] = 'admin'
      session['user_name'] = params[:name]
    else
      redirect '/login'
    end
  end
end

class MyApp &lt; Sinatra::Base
  # 在前置过滤器前运行中间件
  use LoginScreen

  before do
    unless session['user_name']
      halt &quot;Access denied, please &lt;a href='/login'&gt;login&lt;/a&gt;.&quot;
    end
  end

  get('/') { &quot;Hello #{session['user_name']}.&quot; }
end</pre>

<a name='%E5%8F%98%E9%87%8F%E5%9F%9F%E5%92%8C%E7%BB%91%E5%AE%9A'></a>
<h2>变量域和绑定</h2>

<p>当前所在的变量域决定了哪些方法和变量是可用的。</p>

<a name='%E5%BA%94%E7%94%A8/%E7%B1%BB%20%E5%8F%98%E9%87%8F%E5%9F%9F'></a>
<h3>应用/类 变量域</h3>

<p>每个Sinatra应用相当与Sinatra::Base的一个子类。
如果你在使用顶层DSL(<tt>require
'sinatra'</tt>)，那么这个类就是
Sinatra::Application，或者这个类就是你显式创建的子类。
在类层面，你具有的方法类似于 `get` 或者
`before`，但是你不能访问 `request` 对象或者 `session`,
因为对于所有的请求， 只有单一的应用类。</p>

<p>通过 `set` 创建的选项是类层面的方法：</p>

<pre>class MyApp &lt; Sinatra::Base
  # 嘿，我在应用变量域！
  set :foo, 42
  foo # =&gt; 42

  get '/foo' do
    # 嘿，我不再处于应用变量域了！
  end
end</pre>

<p>在下列情况下你将拥有应用变量域的绑定：</p>
<ul><li>
<p>在应用类中</p>
</li><li>
<p>在扩展中定义的方法</p>
</li><li>
<p>传递给 `helpers` 的代码块</p>
</li><li>
<p>用作`set`值的过程/代码块</p>
</li></ul>

<p>你可以访问变量域对象（就是应用类）就像这样：</p>
<ul><li>
<p>通过传递给代码块的对象 (<tt>configure { |c| ... }</tt>)</p>
</li><li>
<p>在请求变量域中使用`settings`</p>
</li></ul>

<a name='%E8%AF%B7%E6%B1%82/%E5%AE%9E%E4%BE%8B%20%E5%8F%98%E9%87%8F%E5%9F%9F'></a>
<h3>请求/实例 变量域</h3>

<p>对于每个进入的请求，一个新的应用类的实例会被创建
所有的处理器代码块在该变量域被运行。在这个变量域中，
你可以访问 `request` 和 `session`
对象，或者调用渲染方法比如 `erb` 或者
`haml`。你可以在请求变量域当中通过`settings`辅助方法
访问应用变量域：</p>

<pre>class MyApp &lt; Sinatra::Base
  # 嘿，我在应用变量域!
  get '/define_route/:name' do
    # 针对 '/define_route/:name' 的请求变量域
    @value = 42

    settings.get(&quot;/#{params[:name]}&quot;) do
      # 针对 &quot;/#{params[:name]}&quot; 的请求变量域
      @value # =&gt; nil (并不是相同的请求)
    end

    &quot;Route defined!&quot;
  end
end</pre>

<p>在以下情况将获得请求变量域：</p>
<ul><li>
<p>get/head/post/put/delete 代码块</p>
</li><li>
<p>前置/后置 过滤器</p>
</li><li>
<p>辅助方法</p>
</li><li>
<p>模板/视图</p>
</li></ul>

<a name='%E4%BB%A3%E7%90%86%E5%8F%98%E9%87%8F%E5%9F%9F'></a>
<h3>代理变量域</h3>

<p>代理变量域只是把方法转送到类变量域。可是，
他并非表现得100%类似于类变量域,
因为你并不能获得类的绑定: 
只有显式地标记为供代理使用的方法才是可用的，
而且你不能和类变量域共享变量/状态。(解释：你有了一个不同的
`self`)。 你可以显式地增加方法代理，通过调用
<tt>Sinatra::Delegator.delegate :method_name</tt>。</p>

<p>在以下情况将获得代理变量域：</p>
<ul><li>
<p>顶层的绑定，如果你做过 <tt>require &quot;sinatra&quot;</tt></p>
</li><li>
<p>在扩展了 `Sinatra::Delegator` mixin的对象</p>
</li></ul>

<p>自己在这里看一下代码:  <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/base.rb#L1128">Sinatra::Delegator
mixin</a> 已经 <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/main.rb#L28">被包含进了主命名空间</a>。</p>

<a name='%E5%91%BD%E4%BB%A4%E8%A1%8C'></a>
<h2>命令行</h2>

<p>Sinatra 应用可以被直接运行：</p>

<pre>ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-o HOST] [-s HANDLER]</pre>

<p>选项是：</p>

<pre>-h # help
-p # 设定端口 (默认是 4567)
-o # 设定主机名 (默认是 0.0.0.0)
-e # 设定环境 (默认是 development)
-s # 限定 rack 服务器/处理器 (默认是 thin)
-x # 打开互斥锁 (默认是 off)</pre>

<a name='%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6'></a>
<h2>必要条件</h2>

<p>推荐在 Ruby 1.8.7, 1.9.2, JRuby 或者 Rubinius 上安装Sinatra。</p>

<p>下面的Ruby版本是官方支持的:</p>
<dl class="rdoc-list"><dt> Ruby 1.8.6 </dt>
<dd>
<p>不推荐在1.8.6上安装Sinatra， 但是直到Sinatra
1.3.0发布才会放弃对它的支持。 RDoc 和
CoffeScript模板不被这个Ruby版本支持。
1.8.6在它的Hash实现中包含一个内存泄漏问题，
该问题会被1.1.1版本之前的Sinatra引发。
当前版本使用性能下降的代价排除了这个问题。你需要把Rack降级到1.1.x，
因为Rack &gt;= 1.2不再支持1.8.6。</p>
</dd><dt> Ruby 1.8.7 </dt>
<dd>
<p>1.8.7 被完全支持，但是，如果没有特别原因，
我们推荐你升级到 1.9.2 或者切换到 JRuby 或者 Rubinius.</p>
</dd><dt> Ruby 1.9.2 </dt>
<dd>
<p>1.9.2 被支持而且推荐。注意 Radius 和 Markaby
模板并不和1.9兼容。不要使用 1.9.2p0, 它被已知会产生
segmentation faults.</p>
</dd><dt> Rubinius </dt>
<dd>
<p>Rubinius 被官方支持 (Rubinius &gt;= 1.2.2)， 除了Textile模板。</p>
</dd><dt> JRuby </dt>
<dd>
<p>JRuby 被官方支持 (JRuby &gt;= 1.5.6)。
目前未知和第三方模板库有关的问题，
但是，如果你选择了JRuby，请查看一下JRuby rack 处理器，
因为 Thin web 服务器还没有在JRuby上获得支持。</p>
</dd></dl>

<p>我们也会时刻关注新的Ruby版本。</p>

<p>下面的 Ruby 实现没有被官方支持， 但是已知可以运行
Sinatra:</p>
<ul><li>
<p>JRuby 和 Rubinius 老版本</p>
</li><li>
<p>MacRuby</p>
</li><li>
<p>Maglev</p>
</li><li>
<p>IronRuby</p>
</li><li>
<p>Ruby 1.9.0 and 1.9.1</p>
</li></ul>

<p>不被官方支持的意思是，如果在不被支持的平台上有运行错误，
我们假定不是我们的问题，而是平台的问题。</p>

<p>Sinatra应该会运行在任何支持上述Ruby实现的操作系统。</p>

<a name='%E7%B4%A7%E8%BF%BD%E5%89%8D%E6%B2%BF'></a>
<h2>紧追前沿</h2>

<p>如果你喜欢使用 Sinatra 的最新鲜的代码，请放心的使用
master 分支来运行你的程序，它会非常的稳定。</p>

<pre>cd myapp
git clone git://github.com/sinatra/sinatra.git
ruby -Isinatra/lib myapp.rb</pre>

<p>我们也会不定期的发布预发布gems，所以你也可以运行</p>

<pre>gem install sinatra --pre</pre>

<p>来获得最新的特性。</p>

<a name='%E9%80%9A%E8%BF%87Bundler'></a>
<h3>通过Bundler</h3>

<p>如果你想使用最新的Sinatra运行你的应用，通过 <a
href="http://gembundler.com/">Bundler</a> 是推荐的方式。</p>

<p>首先，安装bundler，如果你还没有安装:</p>

<pre>gem install bundler</pre>

<p>然后，在你的项目目录下，创建一个 <tt>Gemfile</tt>:</p>

<pre>source :rubygems
gem 'sinatra', :git =&gt; &quot;git://github.com/sinatra/sinatra.git&quot;

# 其他的依赖关系
gem 'haml'                    # 举例，如果你想用haml
gem 'activerecord', '~&gt; 3.0'  # 也许你还需要 ActiveRecord 3.x</pre>

<p>请注意在这里你需要列出你的应用的所有依赖关系。
Sinatra的直接依赖关系 (Rack and Tilt) 将会，
自动被Bundler获取和添加。</p>

<p>现在你可以像这样运行你的应用:</p>

<pre>bundle exec ruby myapp.rb</pre>

<a name='%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84'></a>
<h3>使用自己的</h3>

<p>创建一个本地克隆并通过 <tt>sinatra/lib</tt>
目录运行你的应用， 通过 <tt>$LOAD_PATH</tt>:</p>

<pre>cd myapp
git clone git://github.com/sinatra/sinatra.git
ruby -Isinatra/lib myapp.rb</pre>

<p>为了在未来更新 Sinatra 源代码:</p>

<pre>cd myapp/sinatra
git pull</pre>

<a name='%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85'></a>
<h3>全局安装</h3>

<p>你可以自行编译 gem :</p>

<pre>git clone git://github.com/sinatra/sinatra.git
cd sinatra
rake sinatra.gemspec
rake install</pre>

<p>如果你以root身份安装 gems，最后一步应该是</p>

<pre>sudo rake install</pre>

<a name='%E6%9B%B4%E5%A4%9A'></a>
<h2>更多</h2>
<ul><li>
<p><a href="http://www.sinatrarb.com/">项目主页（英文）</a> -
更多的文档， 新闻，和其他资源的链接。</p>
</li><li>
<p><a href="http://www.sinatrarb.com/contributing">贡献</a> -
找到了一个bug？ 需要帮助？有了一个 patch?</p>
</li><li>
<p><a href="http://github.com/sinatra/sinatra/issues">问题追踪</a></p>
</li><li>
<p><a href="http://twitter.com/sinatra">Twitter</a></p>
</li><li>
<p><a href="http://groups.google.com/group/sinatrarb/topics">邮件列表</a></p>
</li><li>
<p><a href="irc://chat.freenode.net/#sinatra">IRC: #sinatra</a> on <a
href="http://freenode.net">freenode.net</a></p>
</li></ul>
